{"meta":{"title":"A2Data","subtitle":"","description":"","author":"JackFeng","url":"http://www.a2data.cn","root":"/"},"pages":[{"title":"","date":"2020-08-10T07:01:58.192Z","updated":"2020-08-10T07:01:58.192Z","comments":true,"path":"README.html","permalink":"http://www.a2data.cn/README.html","excerpt":"","text":"A2DataDataScience 公众号 专属博客"},{"title":"404 Not Found","date":"2020-08-01T03:24:02.867Z","updated":"2020-08-01T03:24:02.867Z","comments":true,"path":"404.html","permalink":"http://www.a2data.cn/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2020-08-01T03:20:39.634Z","updated":"2020-08-01T03:20:39.634Z","comments":true,"path":"categories/index.html","permalink":"http://www.a2data.cn/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2020-07-31T15:11:22.000Z","updated":"2020-07-31T15:11:22.852Z","comments":true,"path":"archives/index.html","permalink":"http://www.a2data.cn/archives/index.html","excerpt":"","text":""},{"title":"confession","date":"2020-08-03T10:41:34.000Z","updated":"2020-08-03T10:41:34.413Z","comments":true,"path":"confession/index.html","permalink":"http://www.a2data.cn/confession/index.html","excerpt":"","text":""},{"title":"books","date":"2020-08-03T09:52:03.000Z","updated":"2020-08-03T09:52:03.258Z","comments":true,"path":"books/index.html","permalink":"http://www.a2data.cn/books/index.html","excerpt":"","text":""},{"title":"history","date":"2020-08-03T10:41:12.000Z","updated":"2020-08-03T10:41:12.213Z","comments":true,"path":"history/index.html","permalink":"http://www.a2data.cn/history/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-08-01T03:57:10.000Z","updated":"2020-08-01T03:57:10.065Z","comments":true,"path":"contact/index.html","permalink":"http://www.a2data.cn/contact/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-08-07T07:47:53.365Z","updated":"2020-08-07T07:47:53.365Z","comments":true,"path":"friends/index.html","permalink":"http://www.a2data.cn/friends/index.html","excerpt":"本站信息 本站链接如下，请先添加本站后留言。回复较慢的情况下，请添加如下微信。小编微信：a2xf669 - name: DataSciece # 博客名 avatar: https://gitee.com/sqlsq_admin/cdn/raw/master/avatar.png # 头像链接 url: https://www.a2data.cn/ # 博客链接 backgroundColor: &#39;#d7d1d5&#39; # 卡片背景颜色 textColor: &#39;#5d5d5d&#39; # 卡片文字颜色 tags: [DataScience,A2Data,BigData,Python,Java,数据分析] # 标签 desc: 梦想用技术推动传统行业的发展！","text":"本站信息 本站链接如下，请先添加本站后留言。回复较慢的情况下，请添加如下微信。小编微信：a2xf669 - name: DataSciece # 博客名 avatar: https://gitee.com/sqlsq_admin/cdn/raw/master/avatar.png # 头像链接 url: https://www.a2data.cn/ # 博客链接 backgroundColor: &#39;#d7d1d5&#39; # 卡片背景颜色 textColor: &#39;#5d5d5d&#39; # 卡片文字颜色 tags: [DataScience,A2Data,BigData,Python,Java,数据分析] # 标签 desc: 梦想用技术推动传统行业的发展！ 友情规范 互换博客，要求原创不低于20篇。长期维护者优先。 - name: # 博客名 avatar: # 头像链接 url: # 博客链接 backgroundColor: &#39;#3E74C9&#39; # 卡片背景颜色 textColor: &#39;#fff&#39; # 卡片文字颜色 tags: [标签1, 标签2] # 标签 desc: 描述文字"},{"title":"movies","date":"2020-08-03T10:43:31.000Z","updated":"2020-08-03T10:43:31.717Z","comments":true,"path":"movies/index.html","permalink":"http://www.a2data.cn/movies/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-08-01T03:20:49.302Z","updated":"2020-08-01T03:20:49.302Z","comments":true,"path":"tags/index.html","permalink":"http://www.a2data.cn/tags/index.html","excerpt":"","text":""},{"title":"tools","date":"2020-08-03T12:30:41.000Z","updated":"2020-08-03T12:30:41.734Z","comments":true,"path":"tools/index.html","permalink":"http://www.a2data.cn/tools/index.html","excerpt":"","text":""},{"title":"sponsor","date":"2020-08-03T10:22:10.000Z","updated":"2020-08-03T10:22:10.496Z","comments":true,"path":"sponsor/index.html","permalink":"http://www.a2data.cn/sponsor/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-08-07T08:01:30.604Z","updated":"2020-08-07T08:01:30.604Z","comments":true,"path":"about/index.html","permalink":"http://www.a2data.cn/about/index.html","excerpt":"下面写关于自己的内容","text":"下面写关于自己的内容 一个成功跨行者的自述年轻，是我们唯一拥有权力去编织梦想的时光。 为什么说我的跨行经历呢，因为我的专业特殊，以及经历上的与众不同，全网唯一都不为过。下面来看看我的介绍。（来自粗人的自述） 年少风 学校： 山西师范大学体育学院(1本) 专业： 武术于民族传统体育 爱好： 软件控 &amp; 技术控 运动、健身、项目策划、有想法并愿意为之努力 Dream 梦想用大数据&amp;人工智能推动传统行业的发展。 行动是一切梦想的起点 没有什么，比犹豫和纠结更浪费时间。 只要你去做，那么一切就会简单起来。 大学特招之路特招 对于很多人来说，这是个比较特殊的渠道，对于我们上大学来说，需要在上大学前，就要参加比赛，打到省前三，才可以有二级证书。也就是成为二级运动员。 有了这个证书之后，你才可以报名参加特招考试。 我记得我那一届参赛选手有700+，然后我们整个系别招收人数不到70，也就基本上是十几个人里边选一个，而且是定点定考，就是你想去哪个学校，就得报哪个学校去考试。然后考文化课，以及专业，是以专业分数为优先录取，我当时考了89分，当时录取分数是往届最高的，75分。给大家基本普及一下我当时考试的内容。 很荣幸,我被录取了，录取名单在高考前就出来了，然后后边我还参加了一天的高考考试，用教练的话说，就是去体验体验高考的氛围。当时就自己写了点，然后睡了会，后边的姑娘还把试卷漏出来给我抄，我前边的同学也是认识的，学习好的那种，我都懒得抄，监考老师还帮我挡摄像头，我简直觉得自己遇到传说中的好老师，好队友，所以后来，我就没参加了。 怕影响别人。 因为我们的付出比常人更多，每天早上5点起，拉练一般最少是 5-7公里，当时有一个7.2 ，然后蛙跳，到7:30左右，晨练结束，开始吃饭，放松休息一下，从9点开始训练到中午，一般其他时间 都是以反应靶，空击、实战为主。 有一次去塔沟特训，教官只要第一名，真的是有几次吃不上早饭，不是因为你跑的慢，不达标，而是因为你们团队有人不符合，你快了不行，慢了也不行。这个经历是我受用终身的，人的潜力只有在特定的条件下才能最大价值的发挥出来。也让我从那时开始有了团队意识。 大学生涯2013年，我成功进入山西师范大学体育学院，可以毫不夸张的说，整个山西省百分之七八十的教师都是出自我们学校。 大一大二， 之后 暑期去过国企 ：北京公交总站，富士康，管理跆拳道馆，运营公众号合作。(那个时候，我就有了公众号，只不过开始都是给道管做) 为了梦想，你愿意付出什么？ 当别人都还在玩游戏，周六日出去玩的时候，你愿意去道馆代课么？当别人都舍不得买个u盘的时候，你愿意花5 6 百去买个1T 的移动硬盘吗？ 什么东西都是需要付出的，你做了多少未必有一定比例的收获，但是你不做，一定不会有收获。 你所有的付出都是为你心中的梦想去奠定基础。 久而久之，渐渐的发现，不论是一个技术工，还是一个教练，你的价值都只是在当前的一个工作时间， 一堂有趣的课程；学习ps （目前还是很low逼的设计）之后，我发现一门教程，可以影响很多人， 但是起初的付出只需要一分，而不论是教练或者是打工，你的价值都只是当前。 毕业时的抉择才是最艰难的 \\对于不爱学习的我：** 有一个技术梦，随着不断接触到计算机方向的东西。 起初的安装系统，到收集各类破解软件，觉得，哇，大牛 好厉害。之后，从开始辛苦的付出，到目前转行从业的大数据 人工智能 机器学习。 你的努力到底应该是怎样的呢？ 不是你有多少种想法，你掌握多少资源，你拥有多少朋友；而是 你在思考了之后，去做了什么，去舍弃了什么，去改变了什么！！！ 自媒体的所遇所感关于方向2018年10月，我开启了自己的公号之旅。也成了跟很多号主一样的作息，甚至经常凌晨一两点休息，一篇原创文章可能需要写2-3天，每天大概需要2-3小时，很多人就会说，不就是一篇文章么？ 有这么南么？ 首先，我开始的定位是大数据，大数据集群的安装是必不可少的一部分，不信你试试，搭建一台完全分布式的集群，配置好大数据的各个组件。 同时你又要一步一步操作，截图，分享。 如果你的机器不给力。可能卡死都有可能的。 所以不要以为什么都是那么简单的。看着做，跟自己做还是两码事！ 于是，从一个跨行的小白，就开始分享自己的大数据学习之旅，然后也有每个号主刚开始的激情，不断更，即使很晚也坚持去写。所以刚开始的阅读量还不错，但后来渐渐发现，定位不够垂直，大佬们说我写的太详细了。 但我从小白过来，我理解的只有小白才懂小白的痛点，为什么这么说呢？ 因为当你会了之后呢，你再去写的时候，你就会潜意识的略过一些较为基础，同时小白不懂得这些点。 然后我就坚持我的想法，写了下来了。 并且，我因为工作参与项目较多，所以分享的范围也比较广。 Linux Hadoop HiveSQL Python Java Vue Git 等等 `后续会聚焦在数据领域` 那么，你就会看到我公众号内容比较杂，但很多都是干货，骚操作。这点我也会花时间整理一下。重新上线，让大家方便快捷的涨点知识。少踩点坑。多一些经验以及实操。有些跨行的经验，后续我会更新在星球，或者网站。 相信现在大家看到公号，发现写文章的比看文章的还多，因为一方面，号主不断引领粉丝发展自媒体，另一方面，公众号如果你玩的好，套路深，收益还是蛮大的。 看阅读量来定价格接广告的。 甚至有的号，你可以看到只有几篇原创，但是阅读量很高。所以就很值钱。 我呢，甚至组建了好几拨人，团队式的发文，最终都失败了。(原因有很多)，我从中学会很多，由于开始niubility 吹的有点大， 起名叫做 Ai大数据与机器学习，大数据还好，机器学习 不咋懂，受众也很宅。只有大数据的还好。也坚持了半年，中间有些事情，耽搁一段时间没更文。 后来想聚焦与数据，各行各业都离不开数据。 所以改名叫做—-&gt; A2Data 后来改名的更加专业： DataScience 重点 如果你开始了，自媒体之旅，那么断更 将是你最大的敌人。 不知道你看没看过李佳琦的直播，他之所以火，是因为他每天连续直播3-4个小时。 你不知道有多少个公众号，你一天不断更，就会被淹没。 所以，如果你是为了通过这盈利。 那么坚持是必须的。 而且你会发现，如果跟你同一批用户，刚开始做，你断更了两个月， 你会发现别人的号都做起来了，mmmp，真是个魔化的世界。(有木有) So, 一定要坚持 不断输出 曝光 内容输出，垂直领域。 固定时间，保持高频输出 排版标题，规划，一定要有规划 复盘，也就是最重要的一点，很多人都不做的 关于内容简单来说，一个公众号也好，朋友圈也好，知乎简书，都是在打造个人品牌。甚至大到公司，都是在做宣传，品牌。 写作的价值？写作是人人都需要的底层能力 1、沟通能力决定了你链接资源的效率。 2、写作是倒逼成长的绝佳方法 3、写作是学习效果 个人能力的放大器 个人品牌如何打造？简单讲 技能定位 + 持续曝光 持续曝光，就需要借助写作能力。 思路 职场简语 **英文 + 经典语录 ** 软文要素闪电胰腺 三点一线 三点： 寻找软文的核心诉求 痒点： 消费者享受的体验 （Good Experience） 痛点： 无法获得该功能会有什么痛苦 （Terrible Felling） 利益点： 解决方案 （Benifit Point ） 一线：故事性【热点、冲突、惊悚、情感、悬念、幽默、争议、名人等】 GTB核心 即用故事性的叙述来铺垫和陈述GT，最后用B收尾。 图样理论 1、以图代文，分段易读。 2、切记开门见山，不可以直接上来就说品牌、产品等 3、内容由浅入深，有趣打头。 4、受众第一，要有读者心态。 软文的目的是被阅读，没有打开率，一切都是无用功 {读者心态--&gt; 娱乐、八卦、时事、搞笑。。。} 关于工具 其实，我是个不折不扣的工具控。 一般朋友们有什么软件，工具的需要，都会找我，什么黑科技啥的？(偷笑) 对于号主来说，排版是一个最大的问题。 根据我一直以来的经验，这里给大家几点建议。 关于知识 不知道你是否也看到了？ 有这么一个现象 自从入了互联网， 发现很多人喜欢 ‘囤知识 囤资料’ 收藏xxx的干货，百度云盘可能存了好几T 的资源 但是，你真正掌握的有多少呢？ 学习了，做了多少？ 很多人有一个错觉，自以为关注了好多公众号，加了很多好友，积攒了很多资料，其实大多数是打广告的资料，你真正看的也不会有的。 在这里，小编的建议是：希望你可以选择一个方向，踏踏实实的学一点，有的时候，什么都做，什么都会，结果也可能是，什么都做不好，什么都不会 该奋斗的年纪，就不要再飘了市场永远不会一成不变的，所以，改变就是好事为什么会说着一点呢？ 因为很多人本来写公众号是分享个人经历，成长的，看到市场的利益，就会变得利益化；于是乎，有了很多小白蜂拥而至。时间花在了增粉、阅读、加人，微群，发圈，你会发现越来越的文章只是题目不一样，内容都一样。 用户好感度就降低了。 所以，微信现在对原创号非常友好。 其实，以上不是重点，重点是在本该奋斗的年级，应该踏踏实实的去提升自己，拥抱市场，而不是所谓的跟风。 我断更期间，自己有时候玩会游戏，真香，健健身，发现真的是好。 日常工作我都是爬楼梯上楼的，试问？每天运动的人，跟每天不动的人，长期结果能一样吗？ 你去练了两天拳，跟练了几年的，能一样？ 所以在该努力的年纪，希望大家，沉淀下来，好好想想，自己到底需要什么？可以去做什么？ 改变了哪些？还需要补充哪些？ 我时常鼓励我的朋友，激励他们说：你看我跨行都可以的 你们会更优秀的。 摸鱼一时爽，一直摸鱼一直爽 为什么越来越多人，交完智商税，反而混的比之前更差了，首先说一下，例如你进了某某某大佬的知识星球，或者加个好友，并不代表你厉害了，而是你是想向他学习之一，你是付费用户，其次，你的摸鱼时间更久了，你会应酬大佬吧，也许会关注更多的圈子动态，你划水的本领越来越强了。而大佬还是大佬，因为他已经经历过曾经你没有经历过的时光，遇上你没有遇上的风口，例如我跨行大数据的风口，现在你试试？ 再说说，我删了2k人的感想，我的公众号，基本上发文章不推文，不怎么发圈，不发群，也没有建立自己的微信群。 所以阅读量 活跃度 也很少。加了很多号主，有认识的不认识的。 也有很多好友。发现莫名的被删，莫名的被拉群。工作都忙不过来，所以 我花了近半个月的时间，删除了2k+好友 退出了200+微信群。现在相对亲近多了。 所以没有必要的社交，不对等的资源的社交，最终只是被割韭菜的下场，资源不会跑的，关键看你有没有实力。 1、未来制造业将不再是主要的雇主，人工智能和自动化将取代工人。人应该回归去做人类更擅长的、具备创造力、体验性的工作。 2、网上90%的评论都是没脑子的评论，各种水军和谣言是精神排泄物。 信息开放的时代，取出对你真正有价值的信息，帮助，资源，其实是一门学问，以前人人都是产品经理，现在人人都是数据分析。 对于我来讲： 成功就是用99次失败去尝试一次成功的可能性 那么对于新人来讲：技术就是最好的入场劵！ 亲爱滴朋友们，感谢您的阅读，流年笑掷 未来可期"}],"posts":[{"title":"Hexo命令","slug":"Hexo/Hexo","date":"2020-08-01T02:45:51.000Z","updated":"2020-08-07T08:56:43.918Z","comments":true,"path":"posts/47ce27c8.html","link":"","permalink":"http://www.a2data.cn/posts/47ce27c8.html","excerpt":"Hexo 常用基本命令","text":"Hexo 常用基本命令 Hexo语法 Hexo hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo new post --p 文件夹名/文件名 &quot;title&quot; hexo new post --p Hexo/hexo &quot;title&quot; hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server） hexo deploy #部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 缩写hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 组合命令hexo s -g #生成并本地预览 hexo d -g #生成并上传 上传插件# 在生成以及部署文章之前，需要安装一个扩展： 如下图 # mac 用户 需要加 `sudo` npm install hexo-deployer-git --save CheckBox 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 + 默认选中 黄色 + 默认选中 青色 + 默认选中 蓝色 + 默认选中 增加 减少 叉 Radio 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 黄色 青色 蓝色 密码验证码：这里没有验证码验证码：DataScience","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/categories/Hexo/"},{"name":"Cmomand","slug":"Hexo/Cmomand","permalink":"http://www.a2data.cn/categories/Hexo/Cmomand/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-07-31T11:54:58.992Z","updated":"2020-08-07T10:29:40.876Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"http://www.a2data.cn/posts/4a17b156.html","excerpt":"Hexo 初始页面。","text":"Hexo 初始页面。 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/tags/Hexo/"}]},{"title":"数据库操作-TCL","slug":"DataBase/Mysql/5、数据库操作-TCL","date":"2020-06-15T16:16:16.000Z","updated":"2020-08-11T06:57:25.605Z","comments":true,"path":"posts/e4f3239b.html","link":"","permalink":"http://www.a2data.cn/posts/e4f3239b.html","excerpt":"数据库操作TCL","text":"数据库操作TCL TCL TCL（Transaction Control Language），事务控制语言。 主要用途：对数据库进行事务控制的指令。 操纵命令：COMMIT、ROLLBACK、SAVEPOINT、SET TRANSACTION COMMIT：提交事务。 ROLLBACK：回滚操作。 SAVEPOINT：设置保存点。 SET TRANSACTION：改变事务选项。 1、什么是事务？事务是数据库操作的逻辑单元，包含一系列数据操作，是一个不可分割的整体。 事务的特性——ACID： 原子性(Atomicity)，其包含的所有数据库操作指令要么都执行，如有执行失败会回滚为全都不执行。 一致性(Consistency)，执行前后的数据库有效性是一致的。 隔离性(lsolation)，一个事务不受其他事务的干扰，在多用户并发访问时相互不受干扰。 持久性(Durability)，一旦提交了事务，数据的改变永久保存本地。 2、事务的提交：COMMIT事务的执行内容只有使用commit进行提交后，其中的修改操作才可以成为永久性操作。 先转换MYSQL结束符： DELIMITER // 事务结构： START TRANSACTION｜BEGIN: 查询主体; COMMIT; // 案例： 对user表进行如下事务操作： 1. 姓名为Olivia的人员年龄修改为40 2. 插入新记录user_id为018的男性在职人员Ian，年龄23，电话13173629832，部门为CS 3. 删除原表中user_id为017的记录 4. 查询上述修改结果 start transaction; update user set age = &#39;40&#39; where user_name = &#39;Olivia&#39;; insert user values(&#39;018&#39;,&#39;Ian&#39;,&#39;23&#39;,&#39;0&#39;,&#39;13173629832&#39;,&#39;0&#39;,&#39;CS&#39;); delete from user where user_id = &#39;017&#39;; select * from user where user_dept = &#39;CS&#39; or user_name = &#39;Olivia&#39;; commit; // 我们先查询事务执行前的相关表内容： 执行事务： 3、事务的自动提交：AUTOCOMMITautocommit参数记录了数据库是否为自动提交模式，默认状态为on： 案例： 对user表中user_id为018的人员修改姓名为Peter，年龄为50。 我们开启两个终端，并仅将终端一的autocommit参数修改为OFF： set autocommit = 0// 在终端一进行姓名的修改操作，不执行commit。 我们可以在终端一中查询到修改后的记录： 而在终端二中，则姓名字段为修改前的记录： 若此时在终端二对user表进行年龄的修改操作，会因为正在进行的事务而报错： 将终端一中的事务提交后，我们完成终端二中的修改并查询结果： 4、事务的回滚：ROLLBACK事务在没有使用commit提交时，使用rollback可以将数据库恢复到事务提交前的状态。 案例： 对user表user_id为016的人员remove信息进行修改，并进行回滚操作。 修改前我们查询该条记录如下： 执行事务后并回滚，可以看到数据修改成功后又回滚到修改前状态： 5、设置保存点：SAVEPOINT在事务中设置savepoint，可以将事务回滚到savepoint前。 设置保存点： SAVEPOINT savepoint_name; 回滚到保存点： ROLLBACK TO SAVEPOINT savepoint_name; 解除保存点： RELEASE SAVEPOINT savepoint_name; 案例： start transaction; update user set remove = 1 where user_id = &#39;016&#39;; savepoint s1; delete from user where user_id = &#39;016&#39;; rollback to savepoint s1; release savepoint s1; // 6、事物隔离级别：SET TRANSACTION事务的隔离级别可用于防止事务的并发性问题。 事务有如下隔离级别： ​ read uncommitted 读未提交，该模式会出现脏读 ​ read committed 读已提交，该模式不支持重复读 ​ repeatable read 可重复读，也是MYSQL中默认隔离级别 ​ serializable 串行化，不允许读写并发操作 6.1、查看当前的事务隔离级别：SHOW VARIABLES LIKE &#39;TRANSACTION ISOLATION&#39;; 6.2、修改事务隔离级别：SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL READ 新的事务隔离级别; global：设置全局默认隔离级别 session：设置本次会话隔离级别 如果二者均不写：仅设置本次事务命令的隔离级别，下一个事务将回到默认隔离级别 案例：将当前会话的隔离级别修改为read committed。 set session transaction isolation level read committed; 当前会话隔离级别已更改为read committed： 新开终端再次查询隔离级别，其又回到了默认值repeatable read：","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.a2data.cn/categories/DataBase/"},{"name":"Mysql","slug":"DataBase/Mysql","permalink":"http://www.a2data.cn/categories/DataBase/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.a2data.cn/tags/Mysql/"}]},{"title":"数据库操作-DCL","slug":"DataBase/Mysql/4、数据库操作-DCL","date":"2020-06-15T16:16:16.000Z","updated":"2020-08-11T06:57:25.602Z","comments":true,"path":"posts/f8d580eb.html","link":"","permalink":"http://www.a2data.cn/posts/f8d580eb.html","excerpt":"数据库操作DCL","text":"数据库操作DCL DCL DCL（Data Control Language），数据库控制语言。 主要用途：对数据库访问权限进行控制的指令。 操纵命令：GRANT、REVOKE GRANT：对用户进行赋权。 REVOKE：对用户权限进行回收。 用户管理MYSQL8.0后版本不支持grant语句直接创建用户，因此需要先创建用户，再进行赋权。 创建用户CREATE USER &#39;username&#39;@&#39;hostname&#39; IDENTIFIED BY &#39;密码&#39;; 案例： create user &#39;csg1&#39; identified by &#39;123&#39;; 用Create创建的用户仅有系统默认权限usage，无其他权限。 删除用户DROP USER &#39;username&#39;@&#39;hostname&#39;; 案例： drop user csg1; 权限管理赋权GRANT priviledge_name[(list_name1,list?_name2)] ON dbname.table_name FROM &#39;username&#39;@&#39;hostname&#39;; 案例： 对账号&#39;csg1&#39;添加数据库&#39;mysqlpractice&#39;所有表的&#39;select&#39;权限。 grant select on mysqlpractice.* to csg1; 案例： 对全库全表赋权所有权限。 grant all on *.* to dba@localhost; 查看权限查看指定账号权限： SHOW GRANTS FOR &#39;username&#39;@&#39;hostname&#39;; 查看当前用户自身权限： SHOW GRANTS; 回收权限REVOKE priviledge_name[(list_name1,list?_name2)] FROM dbname.table_name FROM &#39;username&#39;@&#39;hostname&#39;; 案例： revoke select on mysqlpractice.* from csg1;","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.a2data.cn/categories/DataBase/"},{"name":"Mysql","slug":"DataBase/Mysql","permalink":"http://www.a2data.cn/categories/DataBase/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.a2data.cn/tags/Mysql/"}]},{"title":"数据库操作-DML","slug":"DataBase/Mysql/3、数据库操作-DML","date":"2020-06-15T16:16:16.000Z","updated":"2020-08-11T06:57:25.608Z","comments":true,"path":"posts/6656ad65.html","link":"","permalink":"http://www.a2data.cn/posts/6656ad65.html","excerpt":"数据库操作DML","text":"数据库操作DML DML DML（Data Manipulation Language），是通过对表中数据的插入、删除和修改等操作，实现对数据库的基本操作。 主要用途：对数据表进行数据插入、删除、修改、排序或检索操作。 操纵命令：INSERT、UPDATE、DELETE INSERT：把数据插入到数据表中。 UPDATE：修改数据记录。 DELETE：删除数据库中不必再继续保留的记录。 1、插入数据形式一INSERT INTO TABLE_NAME (字段名1,字段名2,.....) VALUES(数值1,数值2,....); 案例： INSERT INTO user(user_id,user_name,age,remove,tel,sex) VALUES(001,&quot;A2Data&quot;,22,0,18511990011,0); 形式二INSERT INTO TABLE_NAME SET 字段名1 = 数值1, 字段名2 = 数值2,....; 案例： INSERT INTO user SET user_id=001,user_name=&quot;A2Data&quot;,age=22,remove=0,tel=18511990011,sex=0; 2、修改数据UPDATE TABLE_NAME SET 字段名1 = 新数值1,字段名2 = 新数值2; 案例： UPDATE USER SET age = 25 , sex = 1; 3、解决重复记录的更新使用on duplicate key update可以解决插入或更改重复主键，即当insert内容和原表内容存在重复记录时，执行update操作。 INSERT INTO table_name1 SELECT * FROM table_name2 ON DUPLICATE KEY UPDATE column_name = VALUES(column_name); 注意：在使用on duplicate key update时，表中必须要存在至少一个unique key或者primary key。 案例：现有表v1和v2如下： v1表与v2表同时存在id为005的行，且name字段值不一致。 我们使用on duplicate key update对v1表插入v2内容： insert into v1 select name,tel,remove from v2 on duplicate key update name = values(name); 查看执行后的v1表内容，可以看到id为005的记录，其name字段值已修改为v2的相应记录： 4、删除数据方法一：DELETEDELETE FROM TABLE_NAME [WHERE 子句] 如不加WHERE子句则表中数据全部删除 案例： DELETE FROM user; 方法二：TRUNCATETRUNCATE优势：作为DDL语句，比DELETE运行速度更快，且使用资源更少 TRUNCATE TABLE TABLE_NAME 案例： TRUNCATE TABLE user; 5、数据库查询5.1、基本查询语句SELECT column_name FROM table_name WHERE 条件语句 [LIMIT 限制行数] WHERE限制条件一览表： 限制条件类别 对应标识 备注 比较 &gt;、&lt;、=、&gt;=、&lt;=、&lt;&gt; 集合 in、not in 无法获取null值 指定范围 between and 使用时需注意其结果包含边界值 空值判断 is null、is not null 且 and 或 or 案例： SELECT user_id,user_name FROM user WHERE age &gt; 20 and tel IS NOT NULL LIMIT 10; 别名 column_name AS 别名 table_name AS 别名 *注:*WHERE子句中不可使用别名 GROUP BY：用于对查询结果进行数据分组 HAVING：用于对分组后的结果进行统计，其后可以跟聚合函数 案例： user表记录了用户所在部门user_dept，筛选出部门平均年龄大于25的结果。 SELECT user_dept,AVG(age) as &#39;年龄&#39; FROM `user` GROUP BY user_dept HAVING AVG(age)&gt;25; HAVING语句用于对分组后的结果进行统计 ORDER BY：对查询结果进行排序,默认为ASC升序，DESC为降序 案例： SELECT user_id,user_name FROM `user` ORDER BY user_name ; DISTINCT：取消重复的结果 案例： SELECT DISTINCT user_dept FROM `user`; 5.2、模糊查询LIKESELECT column_name FROM table_name WHERE column_name LIKE 模式字符串 通配符 含义 % 匹配任意长度（0或多个）字符串，不能匹配空值 _ 匹配任意单个字符串，_表示1个长度 案例： 查询user表中所有姓名为A开头的人员信息。 SELECT * FROM user WHERE user_name like &#39;A%&#39;; RLIKE、REGEXP这两个主要用于在MYSQL中进行正则表达式的书写。 SELECT column_name FROM table_name WHERE column_name REGEXP/RLIKE 模式字符串; 通配符 含义 . 匹配任意单个字符 * 匹配0个或多个前一个得到的字符 ^ 匹配开头，如^s匹配以s或者S开头的字符串。 $ 匹配结尾，如s$匹配以s结尾的字符串。 {n} 匹配前一个字符反复n次。 ｜ 多个条件间的“或”连接 案例： 查询user表中姓名存在字段bb的人员。 select * from user where user_name regexp &#39;b&amp;#123;2&amp;#125;&#39;; 查询user表中姓名为n结尾的人员。 select * from user where user_name rlike &#39;n$&#39;; 查询user表中姓名存在an字段的人员。 select * from user where user_name rlike &#39;an&#39;; 5.3、存储过程存储过程基本结构构造存储过程： CREATE PROCEDURE 存储体名称(IN/OUT 参数名 参数类型) BEGIN 存储内容 END; 调用存储过程： CALL 存储体名称(参数) 终端运行存储过程案例： 构造存储体u1，筛选所有部门为R&amp;D的员工。 首先将MYSQL默认结束符进行修改： DELIMITER // 构造存储过程： CREATE PROCEDURE U1() BEGIN SELECT * FROM user WHERE user_dept = &#39;R&amp;D&#39;; END // 调用存储体： CALL u1()// 5.4、多表查询内连接SELECT * FROM TABLE_A INNER JOIN TABLE_B ON TABLE_A.COLUMN 比较运算符 TABLE_B.COLUMN; 内连接用于比较并返回满足连接条件的数据行，结果取交集。 inner join示意图： 注意：如果两边的表行数不一致，可能会出现丢失数据。 外连接SELECT * FROM TABLE_A LEFT|RIGHT|FULL JOIN TABLE_B ON TABLE_A.COLUMN 比较运算符 TABLE_B.COLUMN; 外连接的两个表有主从之分，主表全部保存，从表适配保存。 full outer join示意图： left/right outer join示意图： 6、锁表锁表； LOCK TABLES table_name LOCK_TYPE 解锁： UNLOCK TABLES; Lock_type包含read和write等。 锁为read类型的表，可读但不可写；其他会话对该表可读，但写入需要等到解锁后： 锁为write类型的表，可读也可写；但其他会话对该表的读或写需要等到解锁以后： 7、MYSQL慢查询：EXPLAINexplain语句用于分析MYSQL的查询性能，可以显示MySQL如何使用索引等来处理select语句以及连接表。 用explain查看查询是否使用索引： EXPLAIN SELECT * FROM table_name WHERE 查询条件； 案例： 对表Sheet1建立索引i1后，用explain查看任意查询情况： explain select * from Sheet1 where number = 1601; explain查询结果type为ref，即使用了索引查询，而非全表遍历查询all；所使用的索引(possible keys/key)为i1：","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.a2data.cn/categories/DataBase/"},{"name":"Mysql","slug":"DataBase/Mysql","permalink":"http://www.a2data.cn/categories/DataBase/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.a2data.cn/tags/Mysql/"}]},{"title":"数据库操作-DDL","slug":"DataBase/Mysql/2、数据库操作-DDL","date":"2020-06-15T16:16:16.000Z","updated":"2020-08-11T06:57:25.596Z","comments":true,"path":"posts/b794162c.html","link":"","permalink":"http://www.a2data.cn/posts/b794162c.html","excerpt":"数据库操作DDL","text":"数据库操作DDL DDL DDL（Data Definition Language）是连接存储世界与现实世界的高铁！ 主要用途： 对数据库对象进行创建、修改、删除等操作。 操作对象： 数据库、数据表、列、索引等。 定义命令： CREATE：创建数据库或表的命令。 DROP：删除已建数据库或表。 ALTER： 添加、修改或删除列，更新表名，字段类型等。 数据库操作1、创建数据库 -- IF NOT EXISTS --- 不存在则创建，存在则不创建 CREATE DATABASE IF NOT EXISTS DataScience; 2、删除数据库1、查看所有数据库 SHOW DATABASES; 2、删除指定数据库 DROP DATABASE IF EXISTS DataScience; 3、修改数据库字符集1、查看数据库字符集 SHOW VARIABLES LIKE&#39;character_set_database&#39;; 2、修改数据库字符集 ALTER DATABASE DataScience character SET &#39;gbk&#39;; 4、进入数据库USE DataSciecne; mysql&gt; use -&gt; datascience; Query OK, 0 rows affected (0.00 sec) 数据表操作1、创建表语法 CREATE TABLE tab_name( column_name1 type[len], column_name2 type[len], ...... column_nameN type[len]) PRIMARY KEY (`id`) [ ENGINE=InnoDB #存储引擎 DEFAULT CHARSET=utf8]; #字符集 创建用户表 CREATE TABLE FansUser( user_id int not null comment &#39;用户ID&#39;, user_name varchar(30) not null comment &#39;名称&#39;, age int, tel int not null comment &#39;电话&#39;, sex bit default 1 ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2、删除表 1、查看目前所有数据表 SHOW TABLES; 2、删除指定数据表 DROP TABLE IF EXISTS FansUser; 3、修改表3.0、表名 alter table FansUser rename FansUser1; --修改表名 ALTER TABLE FansUser RENAME User; || ALTER TABLE User RENAME To FansUser; 3.1、列名 ALTER TABLE FansUser CHANGE COLUMN old_column_name new_column_name varchar(30);--修改表列名 ALTER TABLE User change COLUMN sex status bit(1); 3.2、列的类型和约束 alter table User modify status char(10) --修改表列类型 alter table User change status sex bit(1) -- 修改类型及列名 3.3、新增列 注意：添加新列如无特殊约束条件，则默认添加到最后一列；如果添加到指定位置，则需要注意约束条件的正确使用。 FIRST 表示添加到列表的第一列 AFTER 表示添加到某个列之后 -- 指定位置 ALTER TABLE user ADD COLUMN remove bit(1) AFTER age; -- 默认添加 alter table user add column name1 varchar(10); --添加表列 3.4、删除列 ALTER TABLE user DROP column_name1; 4、复制表 user 表存在，user1 不存在。 4.0、结构 -- 要复制的表 在后边。 # like 只是复制表结构 CREATE TABLE user1 LIKE user; || -- 通过关键字as create table user1 as select * from user limit 0; || create table user1 select * from user limit 0; 4.1、数据及内容 --通过关键字as通过复制另一张表的表结构和数据创建新表 create table user1 as select * from user; 4.2、部分数据 # 根据条件创建表，并且将查询出来得数，存入表中 create table user1 as selecet * from user where age&lt;25; 4.3、部分字段 # 查询部分字段数据 create table user1 as select age,name form user; 索引索引相当于数据表的目录，其优点是可以提高检索数据的速度，但同时也增加了系统维护工作，以及会减慢写入速度。 索引不适用场景 数据较少的表或列 查询频率较低的列 数据类型为 TEXT 、IMAGE、BIT 的数据 字段经常性修改 不常出现在 WHERE 子句及排序的字段 索引选取类型 占用空间较少的数据型优选 简单的整型数据优于字符型 避开存在 NULL 以及 NOT NULL的字段 索引选取字段 数据表的主键、外键 常与其他数据表进行连接的字段 常出现在 WHERE 子句中的字段 常用于排序的字段 1、创建索引方法一：在创建表时创建索引 CREATE TABLE table_name column_name1 type[len], column_name2 type[len], ...... column_nameN type[len]) [UNIQUE/FULLTEXT/SPATIAL] INDEX [index_name](column_name[(length)]) 方法二：在已存在的表中创建索引 CREATE [UNIQUE/FULLTEXT/SPATIAL] INDEX index_name ON table_name(column_name[(length)]) 关于length参数：如果是 CHAR，VARCHAR 类型，length 可以小于字段实际长度；如果是 BLOB 和 TEXT 类型，必须指定length。 2、查看索引&amp;删除索引索引不能修改，想更改索引只能删除后重新创建。 查看： SHOW INDEX FROM table_name; 删除： DROP INDEX index_name ON table_name;","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.a2data.cn/categories/DataBase/"},{"name":"Mysql","slug":"DataBase/Mysql","permalink":"http://www.a2data.cn/categories/DataBase/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.a2data.cn/tags/Mysql/"}]},{"title":"认识Mysql","slug":"DataBase/Mysql/1、认识Mysql","date":"2020-06-15T16:16:16.000Z","updated":"2020-08-11T06:57:25.611Z","comments":true,"path":"posts/4354b039.html","link":"","permalink":"http://www.a2data.cn/posts/4354b039.html","excerpt":"认识mysql","text":"认识mysql 背景介绍 数据库，就是数据的仓库。它是长期存储在计算机内，有组织、可共享的数据的集合。简而言之，即放置信息的文件柜。 数据库分类 当今互联网中，最常见的数据库模型主要为两种，即关系型数据库（SQL）和非关系型数据库（NoSQL 、Not Only SQL)。 关系型数据库 1、定义：指采用了关系模型来组织数据的数据库，其以行和列的形式存储数据，以便于用户理解，关系型数据库这一系列的行和列被称为表，一组表组成了数据库。 2、特点 （1）存储方式：以行和列的方式组成表格进行存储。 （2）扩展方式：只具备纵向扩展能力。 （3）查询方式：采用结构化查询语言（即SQL）进行查询。 （4）原子性：记录之前的版本，允许回滚。 （5）一致性：事务开始和结束之间的中间状态不会被其他事务看到。 （6）隔离性：适当的破坏一致性来提升性能与并行度。 （7）持久性：每一次的事务提交后就会保证不会丢失。 3、缺点：性能没有非关系型数据库好，一旦想更改存储结构，面对海量数据，操作起来会很复杂。 非关系型数据库 1、定义：数据存储不需要固定的表结构，通常也不存在连接操作。 2、特点 （1）不需要预定义模式：不需要事先定义数据模式，预定义表结构。 （2）无共享架构：相对于将所有数据存储的存储区域网络中的全共享架构。 （3）弹性可扩展：可以在系统运行的时候，动态增加或者删除结点。 （4）分区：相对于将数据存放于同一个节点，NoSQL数据库需要将数据进行分区，将记录分散在多个节点上面。 （5）异步复制：和RAID存储系统不同的是，NoSQL中的复制，往往是基于日志的异步复制。 （6）BASE：相对于事务严格的ACID特性，NoSQL数据库保证的是BASE特性。 3、适用场景 （1）数据模型比较简单。 （2）需要灵活性更强的IT系统。 （3）对数据库性能要求较高。 （4）不需要高度的数据一致性。 （5）对于给定key，比较容易映射复杂值的环境。 数据库管理系统 这又是啥？ 面对不同种类的数据库，如何精准获取数据库中的数据？智慧的人类创造了一个神奇的产品！！！ 数据库管理系统。数据库管理系统是为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能。 MySQL 江湖地位！ MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。它是最流行的关系型数据库管理系统之一，它也是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 为啥选 MySQL ? MySQL由于其体积小、速度快、总体拥有成本低，尤其是具有开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。 MAC安装MYSQL：下载安装包：点击链接下载MYSQL安装包： https://dev.mysql.com/downloads/mysql/ 终端输入mysql,发现提示command not found，需要先设置环境路径； 终端输入*/user/local/mysql/bin*，查看mysql是否安装成功： 在终端加入环境路径：如果是bash,执行open ~/.bash_profile；如果是zsh,执行open ~/.zshrc； 在bash_profile或zshrc文件中添加语句PATH=$PATH:/usr/local/mysql/bin,并保存； 将更改立即生效：终端输入source ~/.bash_profile 或 source ~/.zshrc 注：如果没有zshrc文件，需要先创建空白文件，再将bash_profile的内容复制粘贴过来，包括上述语句，最后输入上述语句使修改生效 登录和退出MYSQL：登陆：终端输入mysql -uroot -p，输入密码 -u后是用户名，-p后是密码（如不是登陆本机的MYSQL，还有 -h后面加服务器主机地址）。 退出MYSQL：终端输入\\q; 或 quit; 或 exit;","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.a2data.cn/categories/DataBase/"},{"name":"Mysql","slug":"DataBase/Mysql","permalink":"http://www.a2data.cn/categories/DataBase/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.a2data.cn/tags/Mysql/"}]},{"title":"anaconda闪退","slug":"Python/anaconda闪退","date":"2020-05-13T02:00:30.000Z","updated":"2020-08-07T10:27:12.346Z","comments":true,"path":"posts/4136.html","link":"","permalink":"http://www.a2data.cn/posts/4136.html","excerpt":"anaconda Windows闪退解决方案 。","text":"anaconda Windows闪退解决方案 。 anaconda 打开闪退 记录windwos 系统下 anaconda 打开闪退修复方式。 解决方式 1、 管理员模式运行 conda prompt 2、执行命令conda update anaconda-navigator # 片刻之后 会遇到如下 输入y 即可 3、 重启服务执行anaconda-navigator –reset anaconda-navigator --reset 4、更新客户端执行conda update anaconda-client conda update anaconda-client conda update -f anaconda-client 5、 启动运行 以管理员身份运行 anaconda","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"Anaconda","slug":"Anaconda","permalink":"http://www.a2data.cn/tags/Anaconda/"}]},{"title":"Day2.基础语法","slug":"Python/Day2-基础语法","date":"2020-05-12T13:12:00.000Z","updated":"2020-08-07T10:13:22.475Z","comments":true,"path":"posts/64528.html","link":"","permalink":"http://www.a2data.cn/posts/64528.html","excerpt":"数据可视化，基础语法。","text":"数据可视化，基础语法。 Day2. Python基础语法基础语法想学好数据分析，最好掌握Python语言。Python语言简洁，有大量的第三方库，功能强大，能解决数据分析的大部分问题。在数据科学领域，Python有许多非常著名的工具库：比如科学 计算工具Numpy和Pandas库，深度学习⼯具Keras和TensorFlow，以及机器学习工具Scikit-learn，使用率都非常高。总之，在数字化时代掌握⼀门编程语言，尤其是Python语言的使用是⾮常有必要的。相信使用Python的流行，不必多说，接下来我们一起学习基础语法。需要注意编程中除了文字部分可以使用中文，标点符号一定要使用英文输入法否则会报错。 输入与输出name=input(&quot;What&#39;s your name?&quot;) sum= 100+100 print(&#39;hello, %s&#39; %name) print(&#39;sum= %d&#39; %sum) input是输入函数，input（）括号中存放的是提示文，双引号里面存放字符串类型数据。在Jupyter Notebook 中运行后会出现一个输入框。将内容输入对话框中，内容会被赋值给变量name。 print是输出函数，括号里是输出的内容，第一个print函数，打印出字符串。%name代表变量name的数值，因为是字符串类型，所以在前面加上%s作为代替。第二个print函数中，%sum代表变量sum的数值，是数值型，在前面加上%d作为代替。 运行结果如下： What&#39;s your name?DataScience hello, DataScience sum= 200 判断语句: if … else …**if … else … **是经典的判断语句，需要注意的是在if 后有个冒号，同样在else后⾯也存在冒号。 另外需要注意的是，Python采用代码缩进和冒号的方式来区分代码之间的层次关系。所以代码缩进在Python中是一种语法，如果代码缩进不统一，比如有的是tab有的是空格，会怎样呢？会产生错误或者异常。相同层次的代码⼀定要采用相同层次的缩进。 score = int(input(&#39;请输入你的成绩&#39;)) if score &gt;= 90: print(&#39;优秀&#39;) else: if score &lt; 60: print(&#39;不及格&#39;) else: print(&#39;及格&#39;) 代码中实现输入分数，判断是否优秀和及格。score后面加上int()作用是将input函数中获得的字符串数值转换为整数integer. 运行结果： 请输入你的成绩: 58 不及格 循环语句：for … insum = 0 for number in range(11): sum = sum + number print(sum) 运行结果 55 for循环是⼀种迭代循环机制，迭代即重复相同的逻辑操作。如果规定循环的次数，我们可以使用range函数，它在for循环中比较常用。range(11)代表从数字0到10，不包括末尾11，也相当于range(0,11)，range里面还可以增加步长，比如range(1,11,2)代表的是数组[1,3,5,7,9] 循环语句: whilesum = 0 number = 1 while number &lt; 11: sum = sum + number number = number + 1 print(sum) 运行结果： 55 1到10的求和也可以⽤while循环来写，这里while控制了循环的次数。while循环是条件循环，在while循环中对于变量的计算方式更加灵活。因此while循环适合循环次数不确定的循环，⽽for循环的条件相对确定，适合固定次数的循环。 注释：#注释在python中使用#，也可使用快捷键 ”Ctrl“ 和 ”/“。 如果是多行注释，使用三个单引号，或者三个双引号，比如： #单行注释 &#39;&#39;&#39; 这是多⾏注释，⽤三个单引号 这是多⾏注释，⽤三个单引号 这是多⾏注释，⽤三个单引号 &#39;&#39;&#39; ””” 这是多⾏注释，⽤三个双引号 这是多⾏注释，⽤三个双引号 这是多⾏注释，⽤三个双引号 ””” 数据类型：列表、元组、字典、集合Python3 中有六个标准的数据类型： Number（数字） String（字符串） List（列表） Tuple（元组） Set（集合） Dictionary（字典） 列表：[list]lists=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;] lists.append(&#39;d&#39;) print(lists) print(len(lists)) lists.insert(0,&#39;mm&#39;) lists.pop() print(lists) 运行结果： [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 4 [&#39;mm&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;] 列表是Python中常用的数据结构，相当于数组，具有增删改查的功能，我们可以使用len()即英文length长度，函数获得lists中元素的个数；使⽤ append()在尾部添加元素，使用insert()在列表中插⼊元素，使用pop()删除尾部元素。 元组 (tuple)tuples = (&#39;tupleA&#39;,&#39;tupleB&#39;) print(tuples[0]) 运行结果： tupleA 元组tuple和list⾮常类似，但是tuple⼀旦初始化就不能修改。因为不能修改所以没有append(), insert() 这样的⽅法，可以像访问数组⼀样进⾏访问，⽐如tuples[0]，但不能赋值。 字典 {dictionary}#定义⼀个dictionary score = &amp;#123;&#39;小李&#39;:95,&#39;小王&#39;:96&amp;#125; #添加⼀个元素 score[&#39;小张&#39;]=98 print(score) #删除⼀个元素 score.pop(&#39;小王&#39;) print(score) #查看⼀个key对应的值 print(score[&#39;小李&#39;]) 运行结果： &amp;#123;&#39;小李&#39;: 95, &#39;小王&#39;: 96, &#39;小张&#39;: 98&amp;#125; &amp;#123;&#39;小李&#39;: 95, &#39;小张&#39;: 98&amp;#125; 95 字典其实就是{key, value}键值对，多次对同⼀个key放入value，后面的值会把前面的值覆盖，同样字典也有增删改查。增加字典的元素相当于赋值，比如score[‘小张’] = 98，删除⼀个元素使⽤pop，字典不支持直接修改元素中的key，可将旧元素删除后添加一个元素。 集合：sets = set([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]) # 创建集合也可使用花括号&amp;#123;&amp;#125; s = &amp;#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&amp;#125; s.add(&#39;d&#39;) s.remove(&#39;b&#39;) print(s) &#39;c&#39; in s 运行结果： &amp;#123;&#39;c&#39;, &#39;d&#39;, &#39;a&#39;&amp;#125; True 集合set和字典dictionary类似，不过它只是key的集合，不存储value。同样可以增删查，增加使⽤add，删除使⽤remove，查询看某个元素是否在这个集合里，使用in。 引⽤模块/包：import导⼊⼀个模块 import model_name #导⼊多个模块 import module_name1,module_name2 #导⼊包中指定模块 from package_name import moudule_name #导⼊包中所有模块 from package_name import * Python语言中import的使用很简单，直接使用import module_name语句导入即可。这里import的本质是什么呢？import的本质路径搜索。import引用可以是模块module，或者包package。 针对module，实际上是引⽤⼀个.py ⽂件。而针对package，可以采⽤from … import …的方式，这里实际上是从⼀个目录中引用模块，这时目录结构中必须带有⼀个_ init_.py⽂件。 函数：defdef addone(score): return score + 1 print(addone(99)) 运行结果： 100 def是函数装饰器，将函数代码块打包。函数代码块以def关键词开头，后接函数名和圆括号，在圆括号里是传进来的参数，然后通过return进行函数结果得反馈。 课程讲到这里，只是基础的部分，更多需要用到的内容，可以再补充学习，或者做题练习。学习最好的方式是做中学”learning by doing”，建议小伙伴们把以上代码自己动手敲一遍，并提问自己问题，以检验是否掌握以上知识点。 小作业1、如果我想在Python中引⽤matplotlib库该如何引⽤？ 没有matplotib包的话 pip install matplotlib 已安装直接引入即可 import matplotlib 2、求1+3+5+7+…+99的求和，⽤Python该如何写？ sum = 0 for number in range(1,100,2): sum = sum + number print(sum)","categories":[{"name":"数据可视化","slug":"数据可视化","permalink":"http://www.a2data.cn/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"数据可视化","slug":"数据可视化","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}]},{"title":"Day1.概述","slug":"Python/Day1-概述","date":"2020-05-12T13:11:39.000Z","updated":"2020-08-07T10:13:22.469Z","comments":true,"path":"posts/5590.html","link":"","permalink":"http://www.a2data.cn/posts/5590.html","excerpt":"数据可视化，基础概述。","text":"数据可视化，基础概述。 Day1. 概述Python数据可视化介绍做为⼀名数据分析师，掌握可视化技能是必不可少的。大部分情况下，上级更关心呈现的结果。当可视化的结果呈现在你眼前时，你才能直观地体会到“数据之美”。图片在内容表达上，要远胜于文字，它不仅能体现数据真实性，还能给人很大的想象空间。 我们经常听到的Tableau 和 PowerBI 是商业可视化工具，在可视化灵活分析上功能强⼤，主要目标用户是较专业的数据分析师。同时在工作场景中使用率高，因此掌握对于晋升和求职都很有帮助，之后DataScience也会推出相关培训。 Python是数据分析的首选语言，如果我们的学习目标是数据挖掘工程师，或者算法工程师，那么最重要的就是要了解，并且熟练掌握Python的数据可视化，在校学生以及科研人员也可使用Python进行可视化。此外当我们在使用Python与数据库交互时，获取数据后直接在Python进行分析和观察会更为方便。 Python里包括了众多可视化库，比如：Matplotlib、Seaborn、Bokeh、Plotly、Pyecharts、Mapbox和Geoplotlib。其中使用频率，最需要掌握的就是Matplotlib和Seaborn。 Matplotlib是Python的可视化基础库，作图风格和MATLAB类似，所以称为Matplotlib。⼀般学习Python数据可视化，都会从 Matplotlib⼊⼿，然后再学习其他的Python可视化库。 Seaborn是⼀个基于Matplotlib的⾼级可视化效果库，针对Matplotlib做了更⾼级的封装，让作图变得更加容易 本次课程的内容包含有Python安装，语言基础，绘图基础，和使用Matplotlib和Seaborn库绘制十个常用的可视化试图，如：折线图，直方图，箱线图等，并掌握试图在不同的情况下的适用场景。 安装与环境搭建Python主要有两个版本： 2.7.x和 3.X。 有部分旧的项目使用的包是基于2.7版本的，如果是这样只能使用2.7，目前我们只需要使用新的3.X版本。对于基础的同学，推荐使用Anaconda方式安装Python环境。 Anaconda下载下载地址：https://www.anaconda.com/products/individual 打开页面后，点击下载，根据操作系统选择下载Python3.7版本，分为64为和32位版本，查看操作系统可知下载64或是32，如果计算机设备不是很旧，通常是下载64位。 Anaconda安装打开下载好的安装包，点击”Next” 下一页 ： “I Agree”— 下一页： Install For: Just Me 如果只有一个用户 All User 如果电脑有多个用户选择All User，我这里选择All User，继续点击”Next” 下一页： 选择目标文件夹：如果C盘空间充裕，可选择默认地址； 点击“Next” 下一页： 高级选项： 第一个是加入环境变量，第二个是默认使用Python2.7 ；两个都勾选，点击”Next” 等待安装完成后，点击”FInish“完成安装 启动Jupyter NotebookJupyter Notebook是一个开源的Web应用程序，允许用户创建和共享包含代码、方程式、可视化和文本的文档。使用Jupyter Notebook可以让我们在网页中编辑，运行和调试代码，使用起来非常方便。 Aanconda安装好后，找到菜单目录，找到Anaconda Navigtor图标，双击打开，出现以下界面： 选择Jupyter Notebook，点击“Launch”。启动Jupyter Notebook，此时网页浏览器会打开File，文件界面。 我们可以在桌面建立一个文件，命名为“数据可视化”，来保存代码文件。 在Jupyter Notebook中，选择路径：Desktop/数据可视化/，在右上角处点击New，新建一个Python3文件： 文件建好后，我们在文本框中编辑代码，点击按钮“运行”可以进行调试并出结果。 有关于Jupyter Notebook的更多使用方法，可以在网上搜索相关文档进行学习。","categories":[{"name":"数据可视化","slug":"数据可视化","permalink":"http://www.a2data.cn/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"数据可视化","slug":"数据可视化","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}]},{"title":"Java 集合体系","slug":"Java/JavaSE/Java-集合体系","date":"2020-05-07T15:56:08.000Z","updated":"2020-08-07T10:25:19.989Z","comments":true,"path":"posts/9618.html","link":"","permalink":"http://www.a2data.cn/posts/9618.html","excerpt":"Java集合体系","text":"Java集合体系 1、集合体系0、Collection 集合的体系结构： ​ 有不同的数据结构(数据的组织，存储方式) 学习方式： 最顶层 实现： 最底层 Collection—-&gt; List—&gt; ArrayList 常用： add 添加 clear 清空 contains 是否包含指定元素 isEmpty 是否为空 remove 删除 size 返回集合中的元素个数 toArray 返回包含此集合中所有元素的数组。(遍历数组即可) Modifier and Type Method and Description boolean add(E e) 确保此集合包含指定的元素（可选操作）。 boolean addAll(Collection c) 将指定集合中的所有元素添加到这个集合（可选操作）。 void clear() 从这个集合中移除所有的元素（可选操作）。 boolean contains(Object o) 返回 true如果集合包含指定元素。 boolean containsAll(Collection c) 返回 true如果这个集合包含指定集合的所有元素。 boolean equals(Object o) 将指定的对象与此集合进行比较，以进行相等性。 int hashCode() 返回此集合的哈希代码值。 boolean isEmpty() 返回 true如果集合不包含任何元素。 Iterator iterator() 返回此集合中的元素的迭代器。 default Stream parallelStream() 返回一个可能并行 Stream与集合的来源。 boolean remove(Object o) 从这个集合中移除指定元素的一个实例，如果它是存在的（可选操作）。 boolean removeAll(Collection c) 删除此集合中包含的所有元素（可选操作）的所有元素（可选操作）。 default boolean removeIf(Predicate filter) 删除满足给定谓词的这个集合的所有元素。 boolean retainAll(Collection c) 仅保留包含在指定集合中的这个集合中的元素（可选操作）。 int size() 返回此集合中的元素的数目。 default Spliterator spliterator() 创建此集合中的元素的 Spliterator。 default Stream stream() 返回一个序列 Stream与集合的来源。 Object[] toArray() 返回包含此集合中所有元素的数组。 T[] toArray(T[] a) 返回包含此集合中所有元素的数组；返回数组的运行时类型是指定的数组的运行时类型。 1、Iterator 集合的遍历方式： 1、toArray(),可以把集合转换成数组,然后遍历数组即可 【有序】 2、iterator(),返回迭代器对象，可以通过迭代器对象来迭代集合 next() : 返回下一个元素。 hasNext() : 判断是否有元素可以获取 注意： 迭代器是依赖于集合的，相当于集合的一个副本,但迭代器在操作的时候，如果发现和集合不一样，则抛出异常。 Exception in thread “main ” java.util.ConcurrentModificationExeption 解决方案： 使用迭代器遍历时，用迭代器本身修改。 List.listIterator() package learn; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; /** * * @author JackFeng * @date 2020/3/25 */ public class IteratorDemo &amp;#123; public static void main(String[] args) &amp;#123; // method(); // 创建集合对象 Collection c = new ArrayList(); //添加元素 c.add(&quot;hello&quot;); c.add(&quot;2020&quot;); c.add(&quot;你好啊&quot;); //获取数组 使用迭代器 Iterator it = c.iterator(); while (it.hasNext())&amp;#123; System.out.println(it.next()); &amp;#125; &amp;#125; private static void method() &amp;#123; //快捷键：CTRL + ALT + M 将代码封装成方法 // 创建集合对象 Collection c = new ArrayList(); //添加元素 c.add(&quot;hello&quot;); c.add(&quot;2020&quot;); c.add(&quot;你好啊&quot;); //获取数组 Object[] objects = c.toArray(); // 遍历数组 for (int i = 0; i &lt;objects.length ; i++) &amp;#123; System.out.println(objects[i]); &amp;#125; &amp;#125; &amp;#125; 2、迭代并发修改 判断集合中是否有 “hello ” 如果有，则添加元素 “wolrd” 异常： Exception in thread &quot;main&quot; java.util.ConcurrentModificationException package learn; import java.util.*; /** * * @author JackFeng * @date 2020/3/25 */ public class ListIteratorDemo &amp;#123; public static void main(String[] args) &amp;#123; // mothod(); //创建集合对象 // Collection c = new ArrayList(); List c = new ArrayList(); // 添加元素 c.add(&quot;hello&quot;); c.add(&quot;2020您好&quot;); //迭代器遍历 /* Iterator it = c.iterator(); while (it.hasNext())&amp;#123; String s = (String) it.next(); if (s.equals(&quot;hello&quot;)) &amp;#123; c.add(&quot;world&quot;); &amp;#125; &amp;#125;*/ ListIterator lit = c.listIterator(); while (lit.hasNext()) &amp;#123; String s = (String) lit.next(); if (s.equals(&quot;hello&quot;)) &amp;#123; // 注意 使用迭代器添加，不可使用集合添加，迭代器就会同步集合 lit.add(&quot;world&quot;); &amp;#125; &amp;#125; System.out.println(c); &amp;#125; private static void mothod() &amp;#123; //创建集合对象 Collection c = new ArrayList(); // 添加元素 c.add(&quot;hello&quot;); c.add(&quot;2020您好&quot;); if (c.contains(&quot;hello&quot;))&amp;#123; c.add(&quot;world&quot;); &amp;#125; System.out.println(c); &amp;#125; &amp;#125; 3、泛型 泛型：是一种广泛的类型 优点： 避免类型转换的问题 减少黄色警告线 简化代码书写 什么情况使用泛型—— ** ** package learn; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; /** * * @author JackFeng * @date 2020/3/25 */ public class GenericDemo &amp;#123; public static void main(String[] args) &amp;#123; // 创建集合对象 // Collection c = new ArrayList(); Collection&lt;Student&gt; c = new ArrayList&lt;Student&gt;(); //创建元素对象 Student s = new Student(&quot;Jack&quot;, 22); Student s1 = new Student(&quot;Jack1&quot;, 25); // 添加元素 c.add(s); c.add(s1); //遍历集合对象 // Iterator ir = c.iterator(); Iterator&lt;Student&gt; ir = c.iterator(); while (ir.hasNext()) &amp;#123; // 转换出错 // Exception in thread &quot;main&quot; java.lang.ClassCastException: learn.Student cannot be cast to java.lang.String // String str = (String) ir.next(); // System.out.println(str); Student stu = ir.next(); System.out.println(stu.name); &amp;#125; &amp;#125; &amp;#125; class Student&amp;#123; String name; int age; public Student(String name, int age) &amp;#123; this.name = name; this.age = age; &amp;#125; public String getName() &amp;#123; return name; &amp;#125; public void setName(String name) &amp;#123; this.name = name; &amp;#125; public int getAge() &amp;#123; return age; &amp;#125; public void setAge(int age) &amp;#123; this.age = age; &amp;#125; &amp;#125; 4、foreache 增强for循环，一般用于遍历集合或者数组 格式： for（元素的类型 变量： 集合或者数组对象) { 可以使用变量； } package learn; import java.util.ArrayList; import java.util.Collection; /** * * @author JackFeng * @date 2020/3/25 */ public class ForEachDemo &amp;#123; public static void main(String[] args) &amp;#123; //创建集合对象 // Collection c = new ArrayList(); Collection&lt;String&gt; c = new ArrayList&lt;String&gt;(); //添加集合元素 c.add(&quot;hello&quot;); c.add(&quot;20200325&quot;); //增强for循环 /* for (Object obj:c ) &amp;#123; System.out.println(obj); &amp;#125;*/ for (String string:c ) &amp;#123; // 在增强for循环中不可修改集合 否则会出现 并发修改错误 // c.add(&quot;123&quot;); System.out.println(string.toUpperCase()); &amp;#125; &amp;#125; &amp;#125; 2、数据结构0、数组 数组： int [] arr = { 11,12,13,14}; 查找快，增删慢 1、链表 链表： 由链子连接起来的一堆结点 结点： 地址值，值，下一个结点地址值 获取x结点 方式： 遍历查找 x结点的后边添加新的结点： x结点的下一个结点地址值修改为新的地址值，把新结点的下一个地址值改为 x+1 查询慢，增删快 2、栈&amp;队列 栈：先进后出 堆：先进先出 3、集合List 序列： 指哪插哪 特点： 有序（存储和读取顺序一样） 整数索引 允许重复的 功能： 增 add(int index, E element) —– 在指定索引位置添加指定元素 删 remove(int index) —– 删除指定元素并返回 改 set(int index, E element) —- 将指定索引位置的元素替换为指定元素，并将原来的元素返回。 查 get(int index) —– 根据索引返回元素(防止越界(不存在)) 常用子类 ArrayList： 底层是数组结构，查询快，增删慢 LinkedList: 底层结构是链表，查询慢，增删快 常用 void addLast getFirst getLast removeFirst removeLast Modifier and Type Method and Description boolean add(E e) 将指定的元素列表的结束。 void add(int index, E element) 在列表中指定的位置上插入指定的元素。 boolean addAll(Collection c) 追加指定集合的所有元素到这个列表的末尾，按他们的指定集合的迭代器返回。 boolean addAll(int index, Collection c) 将指定集合中的所有元素插入到该列表中，从指定位置开始。 void addFirst(E e) 在此列表的开始处插入指定的元素。 void addLast(E e) 将指定的元素列表的结束。 void clear() 从这个列表中移除所有的元素。 Object clone() 返回该 LinkedList浅拷贝。 boolean contains(Object o) 返回 true如果这个列表包含指定元素。 Iterator descendingIterator() 返回在反向顺序在deque容器元素的迭代器。 E element() 检索，但不删除，此列表的头（第一个元素）。 E get(int index) 返回此列表中指定位置的元素。 E getFirst() 返回此列表中的第一个元素。 E getLast() 返回此列表中的最后一个元素。 int indexOf(Object o) 返回此列表中指定元素的第一个出现的索引，或-如果此列表不包含元素，或- 1。 int lastIndexOf(Object o) 返回此列表中指定元素的最后一个发生的索引，或-如果此列表不包含元素，或- 1。 ListIterator listIterator(int index) 返回此列表中元素的列表迭代器（在适当的顺序），从列表中的指定位置开始。 boolean offer(E e) 将指定的元素添加到列表的尾部（最后一个元素）。 boolean offerFirst(E e) 在列表的前面插入指定的元素。 boolean offerLast(E e) 在列表的结尾插入指定的元素。 E peek() 检索，但不删除，此列表的头（第一个元素）。 E peekFirst() 检索，但不删除该列表的第一个元素，或返回 null如果这个列表是空的。 E peekLast() 检索，但不删除该列表的最后一个元素，或返回 null如果这个列表是空的。 E poll() 检索并删除此列表的头（第一个元素）。 E pollFirst() 检索并移除此列表的第一个元素，或返回 null如果这个列表是空的。 E pollLast() 检索并移除此列表的最后一个元素，或返回 null如果这个列表是空的。 E pop() 从这个列表所表示的堆栈中弹出一个元素。 void push(E e) 将一个元素推到由该列表所表示的堆栈上。 E remove() 检索并删除此列表的头（第一个元素）。 E remove(int index) 移除此列表中指定位置的元素。 boolean remove(Object o) 从该列表中移除指定元素的第一个发生，如果它是存在的。 E removeFirst() 移除并返回此列表中的第一个元素。 boolean removeFirstOccurrence(Object o) 删除此列表中指定元素的第一个出现（当遍历从头到尾的列表）。 E removeLast() 移除并返回此列表中的最后一个元素。 boolean removeLastOccurrence(Object o) 删除此列表中指定元素的最后一次（当遍历从头到尾的列表时）。 E set(int index, E element) 用指定元素替换此列表中指定位置的元素。 int size() 返回此列表中元素的数目。 Spliterator spliterator() 创建一个后期绑定和快速失败 Spliterator超过此列表中的元素。 Object[] toArray() 返回一个数组，包含在这个列表中的所有元素在适当的顺序（从第一个到最后一个元素）。 T[] toArray(T[] a) 返回一个数组，包含在这个列表中的所有元素在适当的顺序（从第一到最后一个元素）；返回数组的运行时类型是指定的数组的运行时类型。 package learn; import java.util.ArrayList; import java.util.List; /** * * @author JackFeng * @date 2020/3/26 */ /* * 定义一个方法，返回指定列表中指定元素的索引位置 * * * 升级 * */ public class ListedListDemo &amp;#123; public static void main(String[] args) &amp;#123; List list = new ArrayList(); list.add(&quot;hello&quot;); list.add(&quot;A2Data&quot;); list.add(&quot;scala&quot;); int index = index(list, &quot;python&quot;); System.out.println(index); boolean flag = contains(list, &quot;scala&quot;); System.out.println(flag); boolean flag1 = list.contains(&quot;java&quot;); System.out.println(flag1); &amp;#125; public static int index(List list, Object object) &amp;#123; // 索引遍历方式 for (int i = 0; i &lt;list.size() ; i++) &amp;#123; // 获取列表中的元素 Object o = list.get(i); // 判断列表中的元素和指定元素是否相等 // 如果使用 == 是拿地址值去比较的 if (o.equals(object))&amp;#123; return i; &amp;#125; &amp;#125; // 查找不到指定元素 return -1; &amp;#125; public static boolean contains(List list, Object o) &amp;#123; // 获取指定元素在指定列表中的索引位置 int index = index(list, o); // 判断是否村子 if (index &gt;= 0) &amp;#123; return true; &amp;#125; else &amp;#123; return false; &amp;#125; &amp;#125; &amp;#125; 4、集合Set 特点： 无序（存储和读取顺序有可能不一样） 不允许重复（要求元素唯一） 没有索引 HashSet的add() 方法流程： 首先会使用当前集合中的每一个元素和新添加的元素进行hash值比较 如果hash值不同，则直接添加新的元素 如果hash值相同，比较地址值，或使用 equals方法进行比较 比较结果一样，则认为是重复不添加 所有结果都不一样则添加 package learn; import java.util.HashSet; import java.util.Iterator; /** * Created by JackFeng on 2020/3/26. */ /* *使用HashSet存储字符串 并且遍历 * * */ public class HashSetDemo &amp;#123; public static void main(String[] args) &amp;#123; // 创建集合对象 // HashSet&lt;String&gt; hs = new HashSet&lt;&gt;(); HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); //添加元素对象 set.add(&quot;hello&quot;); set.add(&quot;2020&quot;); set.add(&quot;您好啊&quot;); //遍历集合 // mothod(set); // method1(set); // method2(set); &amp;#125; private static void method2(HashSet&lt;String&gt; set) &amp;#123; //增强for for (String s:set ) &amp;#123; System.out.println(s); &amp;#125; &amp;#125; private static void method1(HashSet&lt;String&gt; set) &amp;#123; //迭代器 Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()) &amp;#123; String s = it.next(); System.out.println(s); &amp;#125; &amp;#125; private static void mothod(HashSet&lt;String&gt; set) &amp;#123; //数组 Object[] objects = set.toArray(); for (int i = 0; i &lt;objects.length ; i++) &amp;#123; System.out.println(objects[i]); &amp;#125; &amp;#125; &amp;#125; HashSet方法优化package learn; import java.util.HashSet; import java.util.Objects; /** * * @author JackFeng * @date 2020/3/26 */ public class HashSetDemoTo &amp;#123; public static void main(String[] args) &amp;#123; //创建集合对象 HashSet&lt;Students&gt; hs = new HashSet&lt;Students&gt;(); //创建元素对象 Students s = new Students(&quot;JackFeng&quot;, 22); Students s1 = new Students(&quot;JackFeng&quot;, 22); Students s2 = new Students(&quot;Jack&quot;, 25); //添加元素 hs.add(s); hs.add(s1); hs.add(s2); //遍历集合对象 for (Students students:hs ) &amp;#123; System.out.println(students); &amp;#125; &amp;#125; &amp;#125; class Students&amp;#123; String name; int age; public Students(String name, int age) &amp;#123; this.name = name; this.age = age; &amp;#125; public String getName() &amp;#123; return name; &amp;#125; public void setName(String name) &amp;#123; this.name = name; &amp;#125; public int getAge() &amp;#123; return age; &amp;#125; public void setAge(int age) &amp;#123; this.age = age; &amp;#125; @Override public String toString() &amp;#123; return &quot;Students&amp;#123;&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, age=&quot; + age + &#39;&amp;#125;&#39;; &amp;#125; @Override public boolean equals(Object o) &amp;#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Students students = (Students) o; return age == students.age &amp;&amp; Objects.equals(name, students.name); &amp;#125; @Override public int hashCode() &amp;#123; return Objects.hash(name, age); &amp;#125; &amp;#125; Collections 面试题：Collection和collections 有何区别？ collection 是集合体系的最顶层，包含了集合体系的共性 collections 是一个工具类，方法都是用于操作collection 常用方法： binarySearch ——- 二分查找(元素有序) copy —— 源列表覆盖目标列表（目标》=源列表） fill —— 使用指定的对象填充指定列表的所有元素 reverse —– 反转 shuffle —– 随机置换 sort —– 排序 （自然顺序排序） swap —- 指定列表中的两个索引位置互换 Modifier and Type Method and Description static boolean addAll(Collection c, T... elements) 将所有指定的元素添加到指定的集合中。 static Queue asLifoQueue(Deque deque) 返回一个 Deque视图为后进先出（LIFO） Queue。 static int binarySearch(List&gt; list, T key) 使用二进制搜索算法搜索指定对象的指定列表。 static int binarySearch(List list, T key, Comparator c) 使用二进制搜索算法搜索指定对象的指定列表。 static Collection checkedCollection(Collection c, 类 type) 返回一个指定集合的动态类型安全的观点。 static List checkedList(List list, 类 type) 返回一个动态类型安全的查看指定的列表。 static Map checkedMap(Map m, 类 keyType, 类 valueType) 返回一个动态类型安全的查看指定的Map。 static NavigableMap checkedNavigableMap(NavigableMap m, 类 keyType, 类 valueType) 返回一个动态类型安全的查看指定的导航电子Map。 static NavigableSet checkedNavigableSet(NavigableSet s, 类 type) 返回一个动态类型安全的集合视图指定通航。 static Queue checkedQueue(Queue queue, 类 type) 返回一个动态类型安全的查看指定队列。 static Set checkedSet(Set s, 类 type) 返回一个指定的动态类型安全的观点。 static SortedMap checkedSortedMap(SortedMap m, 类 keyType, 类 valueType) 返回一个动态类型安全的查看指定的排序图。 static SortedSet checkedSortedSet(SortedSet s, 类 type) 返回一个动态类型安全的查看指定的排序设置。 static void copy(List dest, List src) 将所有的元素从一个列表复制到另一个列表中。 static boolean disjoint(Collection c1, Collection c2) 返回 true如果两个指定集合没有共同的元素。 static Enumeration emptyEnumeration() 返回一个没有元素的枚举。 static Iterator emptyIterator() 返回一个没有元素的迭代器。 static List emptyList() 返回一个空列表（不可变）。 static ListIterator emptyListIterator() 返回一个没有元素的列表迭代器。 static Map emptyMap() 返回一个空Map（不可变）。 static NavigableMap emptyNavigableMap() 返回一个空的导航Map（不可变）。 static NavigableSet emptyNavigableSet() 返回一个空的导航集（不可变）。 static Set emptySet() 返回一个空集（不可变）。 static SortedMap emptySortedMap() 返回一个空的排序映射（不可变）。 static SortedSet emptySortedSet() 返回一个空的排序集（不可变）。 static Enumeration enumeration(Collection c) 返回指定集合的枚举数。 static void fill(List list, T obj) 用指定元素替换指定列表的所有元素。 static int frequency(Collection c, Object o) 返回指定集合中等于指定对象的元素的数目。 static int indexOfSubList(List source, List target) 返回指定的源列表中指定的目标列表的第一个发生的起始位置，或-如果没有这样的发生，则- 1。 static int lastIndexOfSubList(List source, List target) 返回指定的源列表中指定的目标列表的最后一个发生的起始位置，或-如果没有这样的发生，则- 1。 static ArrayList list(Enumeration e) 返回一个数组列表，该列表包含在返回的顺序中由枚举返回的元素的元素。 static &gt;T max(Collection coll) 返回最大元素的集合，根据其元素的自然排序。 static T max(Collection coll, Comparator comp) 返回给定集合的最大元素，根据指定的比较器诱导的顺序。 static &gt;T min(Collection coll) 返回最小的元素的集合，根据其元素的自然排序。 static T min(Collection coll, Comparator comp) 返回给定集合的最小元素，根据指定的比较器诱导的顺序。 static List nCopies(int n, T o) 返回一个不可变列表包含指定对象的 n副本。 static Set newSetFromMap(Map map) 返回一个由指定的映射支持的集合。 static boolean replaceAll(List list, T oldVal, T newVal) 将列表中的某一特定值的所有出现替换为另一个。 static void reverse(List list) 反转指定列表中元素的顺序。 static Comparator reverseOrder() 返回一个比较器，对一系列的实施 Comparable界面对象的自然顺序相反。 static Comparator reverseOrder(Comparator cmp) 返回一个对指定比较器的反向排序的比较器。 static void rotate(List list, int distance) 按指定的距离旋转指定列表中的元素。 static void shuffle(List list) 随机置换指定列表使用随机默认源。 static void shuffle(List list, Random rnd) 随机排列指定列表使用指定的随机源。 static Set singleton(T o) 返回只包含指定对象的不可改变的集合。 static List singletonList(T o) 返回只包含指定对象的不可改变的列表。 static Map singletonMap(K key, V value) 返回一个不可改变的Map，只将指定的指定的键映射到指定的值。 static &gt;void sort(List list) 指定列表为升序排序，根据其元素的 natural ordering。 static void sort(List list, Comparator c) 根据指定的比较器指定的顺序对指定的列表进行排序。 static void swap(List list, int i, int j) 在指定的列表中的指定位置上交换元素。 static Collection synchronizedCollection(Collection c) 返回由指定集合支持的同步（线程安全）集合。 static List synchronizedList(List list) 返回由指定列表支持的同步（线程安全）列表。 static Map synchronizedMap(Map m) 返回由指定的Map支持的同步（线程安全）Map。 static NavigableMap synchronizedNavigableMap(NavigableMap m) 返回指定的导航Map支持的同步（线程安全）导航Map。 static NavigableSet synchronizedNavigableSet(NavigableSet s) 返回由指定的导航集支持的同步（线程安全）导航集。 static Set synchronizedSet(Set s) 返回一个由指定集合支持的同步（线程安全）集。 static SortedMap synchronizedSortedMap(SortedMap m) 返回一个由指定的排序映射支持的同步（线程安全）排序的Map。 static SortedSet synchronizedSortedSet(SortedSet s) 返回一个由指定的排序集支持的同步（线程安全）排序集。 static Collection unmodifiableCollection(Collection c) 返回指定集合的一个不可修改的视图。 static List unmodifiableList(List list) 返回指定列表中的一个不可修改的视图。 static Map unmodifiableMap(Map m) 返回指定映射的一个不可修改的视图。 static NavigableMap unmodifiableNavigableMap(NavigableMap m) 返回指定的导航电子Map的一个不可修改的视图。 static NavigableSet unmodifiableNavigableSet(NavigableSet s) 返回指定通航设置不可修改的视图。 static Set unmodifiableSet(Set s) 返回指定的设置不可修改的视图。 static SortedMap unmodifiableSortedMap(SortedMap m) 返回指定的排序图上一个不可修改的视图。 static SortedSet unmodifiableSortedSet(SortedSet s) 返回指定的排序设置不可修改的视图。 模拟斗地主发牌package learn; import java.util.ArrayList; import java.util.Collections; /** * Created by JackFeng on 2020/3/26. */ /* * * 模拟斗地主发牌 * */ public class CollectionsTest &amp;#123; public static void main(String[] args) &amp;#123; //创作扑克牌 //花色 String[] color = &amp;#123;&quot;黑桃&quot;, &quot;红桃&quot;, &quot;梅花&quot;, &quot;方片&quot;&amp;#125;; //数字 String[] nums = &amp;#123;&quot;A&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;&amp;#125;; //牌盒 ArrayList&lt;String&gt; box = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt;color.length ; i++) &amp;#123; // 得到每一个花色的牌 for (int j = 0; j &lt;nums.length ; j++) &amp;#123; // 得到每一个数字 box.add(color[i] + nums[j]); &amp;#125; &amp;#125; box.add(&quot;大王&quot;); box.add(&quot;小王&quot;); // System.out.println(box.size()); // 洗牌 使用置换方法 Collections.shuffle(box); // System.out.println(box); // 牌友分牌 54-3 /3 = 17张 3张底牌 ArrayList&lt;String&gt; A = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; B = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; C = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt;box.size() -3; i++) &amp;#123; /* * i = 0; i % 3 = 0; * i = 1; i % 3 = 1; * i = 2; i % 3 = 2; * */ if (i % 3 == 0) &amp;#123; A.add(box.get(i)); &amp;#125; else if (i % 3 == 1) &amp;#123; B.add(box.get(i)); &amp;#125; else if (i % 3 == 2) &amp;#123; C.add(box.get(i)); &amp;#125; &amp;#125; System.out.println(A); //底牌 for (int i = box.size()-3; i &lt; box.size() ; i++) &amp;#123; System.out.println(box.get(i)); &amp;#125; System.out.println(); &amp;#125; &amp;#125; 5、集合MapInterface Map&lt;K,V&gt; 参数类型 K -钥匙的Map保持型 V -映射的值的类型 public interface Map&lt;K,V&gt; 映射键到值的对象。一张Map不能包含重复的键，每个键可以映射到至多一个值。 Map 和 Collection 的区别? Map: 双列集合,常用于处理有对应关系的数据，key是不可以重复的 Collection： 单列集合，collection有不同的子体系，有的允许重复有索引有序，有的不允许重复且无序。 Map常用功能： 映射功能 put key映射到value,若key存在，则覆盖value，并且返回原来的value；不存在则返回为null 获取功能 get 根据指定的key 返回对应的value Set 获取所有的Key Collection values 获取所有的Value size 返回对应关系的个数 删除功能 clear 清空所有对应关系 remove 根据指定的key删除对应关系，并返回对应的value值，如果没有删除成功，返回null 判断功能 containsKey 判断指定的key是否存在，存在返回True 否则返回False containsValue 判断指定的value是否存在 isEmpty 判断是否有对应关系 遍历功能： Set Modifier and Type Method and Description void clear() 从这个映射中移除所有的映射（可选操作）。 default V compute(K key, BiFunction remappingFunction) 试图计算出指定键和当前的映射值的映射（或 null如果没有当前映射）。 default V computeIfAbsent(K key, Function mappingFunction) 如果指定的键是不是已经与价值相关的（或映射到 null），尝试使用给定的映射功能，进入到这个Map除非 null计算其价值。 default V computeIfPresent(K key, BiFunction remappingFunction) 如果指定键的值是存在和非空的，尝试计算一个新的映射，给出了键和它当前的映射值。 boolean containsKey(Object key) 返回 true如果这Map包含一个指定的键映射。 boolean containsValue(Object value) 返回 true如果映射到指定的值的一个或多个键。 Set&gt; entrySet() 返回一个 Set视图的映射包含在这个Map。 boolean equals(Object o) 将指定的对象与此映射的相等性进行比较。 default void forEach(BiConsumer action) 在该映射中的每个条目执行给定的操作，直到所有的条目被处理或操作抛出异常。 V get(Object key) 返回指定的键映射的值，或 null如果这个Map不包含的键映射。 default V getOrDefault(Object key, V defaultValue) 返回指定的键映射的值，或 defaultValue如果这个Map不包含的键映射。 int hashCode() 返回此映射的哈希代码值。 boolean isEmpty() 返回 true如果这个Map不包含键值的映射。 Set keySet() 返回一个 Set的关键视图包含在这个Map。 default V merge(K key, V value, BiFunction remappingFunction) 如果指定的键已与值相关联的值或与空值相关联的，则将其与给定的非空值关联。 V put(K key, V value) 将指定的值与此映射中的指定键关联（可选操作）。 void putAll(Map m) 从指定的映射到这个Map（可选操作）复制所有的映射。 default V putIfAbsent(K key, V value) 如果指定的键是不是已经与价值相关的（或映射到 null）将其与给定的值并返回 null，否则返回当前值。 V remove(Object key) 如果存在（可选操作），则从该Map中移除一个键的映射。 default boolean remove(Object key, Object value) 仅当它当前映射到指定的值时，为指定的键移除条目。 default V replace(K key, V value) 仅当它当前映射到某一值时，替换指定的键的条目。 default boolean replace(K key, V oldValue, V newValue) 仅当当前映射到指定的值时，替换指定的键的条目。 default void replaceAll(BiFunction function) 将每个条目的值替换为在该项上调用给定函数的结果，直到所有的条目都被处理或函数抛出异常。 int size() 返回这个映射中的键值映射的数目。 Collection values() 返回一个 Collection视图的值包含在这个Map。 Tips方法实例package learn; import java.util.Collection; import java.util.HashMap; import java.util.Set; /** * * @author JackFeng * @date 2020/3/27 */ public class MapDemo &amp;#123; public static void main(String[] args) &amp;#123; //创建Map对象 HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); // put 映射关系 System.out.println(map.put(&quot;001&quot;, &quot;Jack&quot;)); // 输出为null System.out.println(map.put(&quot;002&quot;, &quot;Jack Jie&quot;)); // 输出为null System.out.println(map.put(&quot;001&quot;, &quot;Jack Feng&quot;)); // 输出为Jack System.out.println(map); //&amp;#123;001=Jack Feng&amp;#125; //`containsKey` System.out.println(map.containsKey(&quot;001&quot;)); //containsValue System.out.println(map.containsValue(&quot;Jack Feng&quot;)); // clear() // map.clear(); //isEmpty // System.out.println(map.isEmpty()); // method(map); // Collection Collection&lt;String&gt; values = map.values(); for (String key:values ) &amp;#123; System.out.println(key); &amp;#125; &amp;#125; private static void method(HashMap&lt;String, String&gt; map) &amp;#123; //set 不允许重复 Set&lt;String&gt; keys= map.keySet(); for (String key:keys ) &amp;#123; System.out.println(key); &amp;#125; &amp;#125; &amp;#125; Map遍历 遍历方式： A(比较繁琐)： 获取所有的key，遍历得到每一个key，让每个key去找对应的value B： entrySet() 使用HashMap存储数据（可以自定义对象作为Key） package learn; import java.util.HashMap; import java.util.Map; import java.util.Set; /** * * @author JackFeng * @date 2020/3/27 */ public class MapTest &amp;#123; public static void main(String[] args) &amp;#123; // 创建map对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // 映射关系 map.put(&quot;001&quot;, &quot;A&quot;); map.put(&quot;002&quot;, &quot;B&quot;); map.put(&quot;003&quot;, &quot;a2data.cn&quot;); // 第一种遍历方式 // 方式1 获取所有的key 用过key 来获取value method(map); // 第二种遍历方式 System.out.println(&quot;第二种遍历方式&quot;); Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet(); // 遍历集合 // 需要用map 去修饰 Ectry ，因为是map的内部类 // 方式2 获取entry对象 ，通过entry 对象来获取 key value for (Map.Entry&lt;String, String&gt; entry:entries ) &amp;#123; // 获取 key value String key = entry.getKey(); String value = entry.getValue(); System.out.println(&quot;key:&quot;+key + &quot;-----&quot; + &quot;value:&quot;+value); &amp;#125; &amp;#125; private static void method(HashMap&lt;String, String&gt; map) &amp;#123; System.out.println(&quot;第一种遍历方式&quot;); // 召集所有key Set&lt;String&gt; keys = map.keySet(); //遍历map对象 for (String key:keys ) &amp;#123; // 每个key 找到value String value = map.get(key); System.out.println(&quot;key:&quot;+key + &quot;-----&quot; + &quot;value:&quot;+value); &amp;#125; &amp;#125; &amp;#125; Key：自定义对象 package learn; import java.util.HashMap; import java.util.Map; import java.util.Objects; import java.util.Set; /** * * @author JackFeng * @date 2020/3/27 */ public class HashMapTest &amp;#123; public static void main(String[] args) &amp;#123; // 创建Map对象 HashMap&lt;Message, String&gt; hashMap = new HashMap&lt;Message,String&gt;(); // 创建Key对象 Message ms = new Message(&quot;未读消息&quot;,12); Message ms1 = new Message(&quot;已读消息&quot;,22); Message ms2 = new Message(&quot;已读消息&quot;,22); // 如果想要这个不添加 重写 hashcode 和 equals // 添加映射关系 hashMap.put(ms, &quot;001&quot;); hashMap.put(ms1, &quot;002&quot;); hashMap.put(ms2, &quot;002&quot;); // 遍历 我们使用 Entry 使用entrySet Set&lt;Map.Entry&lt;Message, String&gt;&gt; entrys = hashMap.entrySet(); for (Map.Entry&lt;Message, String&gt; entry:entrys ) &amp;#123; Message key = entry.getKey(); String value = entry.getValue(); System.out.println( key + value ); // 发现输出是如下 是因为少写了 toString 方法 //learn.Message@74a14482002 //learn.Message@4554617c001 &amp;#125; &amp;#125; &amp;#125; class Message&amp;#123; String name; int nums; public Message(String name, int nums) &amp;#123; this.name = name; this.nums = nums; &amp;#125; public String getName() &amp;#123; return name; &amp;#125; public void setName(String name) &amp;#123; this.name = name; &amp;#125; public int getNums() &amp;#123; return nums; &amp;#125; public void setNums(int nums) &amp;#123; this.nums = nums; &amp;#125; // 解决输出 是地址值 @Override public String toString() &amp;#123; return &quot;Message&amp;#123;&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, nums=&quot; + nums + &#39;&amp;#125;&#39;; &amp;#125; @Override public boolean equals(Object o) &amp;#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Message message = (Message) o; return nums == message.nums &amp;&amp; Objects.equals(name, message.name); &amp;#125; @Override public int hashCode() &amp;#123; return Objects.hash(name, nums); &amp;#125; &amp;#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"},{"name":"集合体系","slug":"集合体系","permalink":"http://www.a2data.cn/tags/%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB/"}]},{"title":"Java 常用API-II","slug":"Java/JavaSE/Java-常用API-II","date":"2020-05-07T15:55:37.000Z","updated":"2020-08-07T10:24:57.905Z","comments":true,"path":"posts/2834.html","link":"","permalink":"http://www.a2data.cn/posts/2834.html","excerpt":"JavaAPP-II","text":"JavaAPP-II 5、API-II5.0、常用类1、Object String toString() : 返回对象得字符串表示 ​ return getClass().getName() + “@” +Integer.toHexString(hashCode()) getClass(): 返回一个字节码对象 Integer.toHexString(): 返回指定参数的十六进制字符串形式 **hashCode():**返回该对象的哈希码值（内存地址） package api; /** * * @author JackFeng * @date 2020/3/24 */ public class ObjectDemo &amp;#123; public static void main(String[] args) throws ClassNotFoundException &amp;#123; // 获取对象字节码的方式 ----- 应用层 反射 //方式1 通过Object类的getClass()方法获取 Teacher t = new Teacher(); Class clazz = t.getClass(); System.out.println(clazz); //方式2 通过类名调用熟悉class来获取 Class&lt;Teacher&gt; clazz1 = Teacher.class; // 方式3 通过class类的静态方法 forName() 来获取 此时需要跑异常，例如输入错误 Class clazz2 = Class.forName(&quot;api.Teacher&quot;); // true System.out.println(clazz == clazz1); // true System.out.println(clazz1 == clazz2); &amp;#125; &amp;#125; 2、Object-equals == : 比较两个对象是否相等 i基本类型比值，引用类型比地址值。（需要重写） @Override public boolean equals(Object o) &amp;#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); &amp;#125; 3、System Modifier and Type Method and Description static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 从指定的源数组中复制一个数组，开始在指定的位置，到目标数组的指定位置。 复制数组： 1、源数组 2、源数组的起始索引位置 3、目标数组 4、目标数组的起始索引位置 5、指定接受的元素个数 currentTimeMillis() 返回当前时间以毫秒为单位。 gc() 运行垃圾收集器。 exit(int status) 终止当前正在运行的java虚拟机。 4、Date java.util.Date 根据“指定时间” 创建Date对象 常用方法： 毫秒值 —- Date 返回值 void ，参数Long 获取 —-Date 返回值long 无参数 getTime setTime Date(long date) 分配一个 Date对象并将它初始化为代表指定的毫秒数自基准时间被称为“时代”，即1970年1月1日，00:00:00 GMT。 5、SimpleDateFormat DataFormat 解析日期或时间 SimpleDateFormat是格式和语言环境敏感的方式解析一个类的具体日期。可以格式化（日期→文本），分析（文本→日期），和归一化。 String format(Date date) 将日期格式化为日期/时间字符串。 2020-03-25 2020年3月25日 SimpleDateFormat() 使用默认的 FORMAT现场默认模式和日期格式的符号构建了一个 SimpleDateFormat。 SimpleDateFormat(String pattern) 使用给定的模式和默认的日期格式符号默认 FORMAT现场构建了一个 SimpleDateFormat。 package learn; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; /** * * @author JackFeng * @date 2020/3/25 */ public class SimpleDateFormatDemo &amp;#123; public static void main(String[] args) throws ParseException &amp;#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;); //格式化 Date date = new Date(); String s = sdf.format(date); // 2020年03月25日 System.out.println(s); //解析 Date d = sdf.parse(&quot;2020年3月25日&quot;); System.out.println(d.toLocaleString()); &amp;#125; &amp;#125; 6、Calendar 日历，提供操作年月日时的方法。 获取，月是 从 0开始。 所以 一般情况下 要 +1 int month = c.get(Calendar.MONTH) +1 7、包装类 包装类：封装了基本数据类型的类，Java 为我们提供了更多复杂的方法和一些变量 7.1 String 转IntInterger 1、int intValue（） 2、static int parseInt( String s) 7.2 Int 转 StringString 1、 + “ ” 2、 String toString() —- 无参 3、 static toString() 类似 8、自动装箱和拆箱package learn; import java.util.ArrayList; /** * * @author JackFeng * @date 2020/3/25 */ public class IntegerDemo &amp;#123; public static void main(String[] args) &amp;#123; // 自动装箱 // 相当于 Integer i = new Integer(10); Integer i1 = 10; // 自动拆箱 // 相当于 int a = i.intValue(); Integer i2 = 10; int a = i2; // Integer i3 = new Integer(i1.intValue() + i2.intValue()); Integer i3 = i1 + i2; // 应用场景 ArrayList arrayList = new ArrayList(); // 自动装箱 ,arrayList.add(new Integer(1)) arrayList.add(1); &amp;#125; &amp;#125; 5.1、正则表达式 正则表达式： ​ 规则规范，用于匹配字符串 boolean matcher( String regex) ：判断当前字符串是否匹配指定的正则表达式。 常用正则表达式字符 一、校验数字的表达式 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$ 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]$ 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\\d$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0$ 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d*[1-9]\\d*))|0?.0+|0$ 正浮点数：^[1-9]\\d.\\d|0.\\d*[1-9]\\d*$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 负浮点数：^-([1-9]\\d.\\d|0.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0)$ 二、校验字符的表达式 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$&quot;等字符：[^%&amp;’,;=?$\\x22]+ 禁止输入含有的字符：[^\\x22]+ 三、特殊需求表达式 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+).\\w+([-.]\\w+)$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]&gt;.?&lt;/\\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用) IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 校验QQ号： 必须0-15 位 不能以0 开头 必须是数字 package learn; /** * * @author JackFeng * @date 2020/3/25 */ public class RegexDemo &amp;#123; public static void main(String[] args) &amp;#123; String qq = &quot;66860619&quot;; boolean matches = qq.matches(&quot;[1-9][0-9]&amp;#123;4,14&amp;#125;&quot;); System.out.println(matches); String a1 = &quot;00001&quot;; boolean matches1 = a1.matches(&quot;[1-9][0-9]&amp;#123;4,14&amp;#125;&quot;); System.out.println(matches1); &amp;#125; &amp;#125; 正则判断元音 aeiou AEIOU public static boolean check(String s)&amp;#123; // 转换成小写 s = s.toLowerCase(); return s.matches(&quot;\\\\w[aeiou]\\\\w&quot;); &amp;#125; Splitpackage learn; /** * * @author JackFeng * @date 2020/3/25 */ public class SplitDemo &amp;#123; public static void main(String[] args) &amp;#123; String s = &quot; -1 2 22 123 88&quot;; System.out.println(&quot;正常分割&quot;); String[] arr = s.split(&quot; &quot;); print(arr); // 正则分割 String[] arr1 = s.split(&quot; +&quot;); System.out.println(&quot;正则分割&quot;); print(arr1); &amp;#125; public static void print(String[] arr)&amp;#123; for (int i = 0; i &lt;arr.length ; i++) &amp;#123; System.out.println(arr[i]); &amp;#125; &amp;#125; &amp;#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"},{"name":"JavaSE","slug":"Java/JavaSE","permalink":"http://www.a2data.cn/categories/Java/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"},{"name":"API","slug":"API","permalink":"http://www.a2data.cn/tags/API/"},{"name":"正则","slug":"正则","permalink":"http://www.a2data.cn/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"Java面向对象 (继承、多态)","slug":"Java/JavaSE/Java面向对象-继承、多态","date":"2020-05-07T15:55:15.000Z","updated":"2020-08-07T10:25:40.895Z","comments":true,"path":"posts/43249.html","link":"","permalink":"http://www.a2data.cn/posts/43249.html","excerpt":"Java面向对象 继承 多态","text":"Java面向对象 继承 多态 面向对象 (继承、多态)1、static静态 static（静态） 关键字 用于修饰成员变量和成员方法 特点： 被所有的对象所共享 可以使用类名调用 静态加载优先于对象 随着类的加载而加载 注意事项： 静态方法只能访问静态成员 非静态方法既可以访问静态也可以访问非静态 非静态方法中不可以定义静态变量 静态方法中不可以定义this，super关键字 优缺点： 优点 对对象的共享数据提供单独的存储空间，节省空间 直接被类名调用，不用在堆内存创建对象 缺点 访问出现局限性（只能访问静态） package one; /** * Created by JackFeng on 2020/3/8. */ public class StaticDemo &amp;#123; public static void main(String[] args) &amp;#123; /* * Math 主要的数学运算方法 * */ // static double abs ( double a) : 返回绝对值 System.out.println(Math.abs(15)); System.out.println(Math.abs(-10)); System.out.println(&quot;----------&quot;); // ceil 天花板 向上取整 System.out.println(Math.ceil(1.2)); System.out.println(Math.ceil(1.6)); System.out.println(&quot;----------&quot;); // floor 向下取整 System.out.println(Math.floor(1.2)); System.out.println(Math.floor(1.8)); System.out.println(&quot;==========&quot;); // round 四舍五入 System.out.println(Math.round(1.2)); System.out.println(Math.round(1.6)); System.out.println(&quot;---------&quot;); // max min System.out.println(Math.max(3,8)); // pow 次幂 第一个参数的第二个参数次幂 System.out.println(&quot;2 的3 次方&quot;); System.out.println(Math.pow(2,3)); // random 随机数 大于0 &lt;1 System.out.println(Math.random()); &amp;#125; &amp;#125; 2、代码块 写一个数据操作的工具类，取最大值，已经取数组中指定索引的值 MyArray 工具类 package com.a2data; /** * Created by JackFeng on 2020/3/13. */ public class MyArrays &amp;#123; // 数组操作 有关的工具类 ，不需要创建对象，所以 可以私有他的构造方法 private MyArrays()&amp;#123;&amp;#125; // 取最大值 public static int getMax(int[] arr)&amp;#123; // 定义参照物 int max = arr[0]; for (int i = 1; i &lt;arr.length ; i++) &amp;#123; if (max&lt;arr[i])&amp;#123; // 替换参照物 max = arr[i]; &amp;#125; &amp;#125; return max; &amp;#125; // 获取指定数组中指定元素的索引位置 public static int getIndex(int[] arr,int a)&amp;#123; for (int i = 0; i &lt;arr.length ; i++) &amp;#123; if (arr[i]== a) return i; &amp;#125; return -1; &amp;#125; &amp;#125; MyArrayDemo 工具类使用 package com.a2data; /** * Created by JackFeng on 2020/3/13. */ public class MyArrayDemo &amp;#123; public static void main(String[] args) &amp;#123; int[] arr = &amp;#123;1, 2, 3, 4, 5, 21&amp;#125;; int max = MyArrays.getMax(arr); System.out.println(max); int index = MyArrays.getIndex(arr, 3); int index1 = MyArrays.getIndex(arr, 6); System.out.println(index); System.out.println(index1); &amp;#125; &amp;#125; 局部代码块： ​ 存在于方法中，控制变量的生命周期（作用域） 构造代码块： ​ 去构造方法中的共性，每次创建对象都会执行，并且在构造方法执行之前执行。 静态代码块： ​ 随着类的加载而加载，只加载一次，加载类时需要加载的驱动 3、继承 继承：Extends ​ 多个类有共同的成员变量和成员方法，抽取到另外一个类中（父类） 只能继承一个父类。 — 只有一个亲爹 只能继承父类非私有成员 支持多层继承 — 还可以有一个亲爷爷 super 与this相似，获取父类的成员和方法。 就近原则！ 方法重写： ​ 在子父类当中,子类的方法和父类的方法完全一样，子类重写了父类的方法(覆盖)。并且super 调用父类的方法即可。 注意事项： 不能重写父类私有的方法 必须大于等于父类方法的权限 注解：@ @Override 继承中构造方法的执行顺序： 子父类继承关系 创建了子类的对象，就会调用子类的构造方法 子类构造方法第一行没有调用父类构造方法，默认调用父类无参构造 肯定先执行父类方法，因为要先给父类的成员变量进行初始化，子类可能会用到。 super() 在子类构造方法的第一行中调用父类的构造方法 继承优缺点 优点： 提高代码的复用性，可维护性 缺点： 耦合性的影响。 开发原则： 高内聚低耦合 内聚：自己完成某件事的能力 耦合：类与类的关系 package com.a2data; /** * Created by JackFeng on 2020/3/13. */ public class ExtendsDemo &amp;#123; public static void main(String[] args) &amp;#123; Zi zi = new Zi(); zi.function(); &amp;#125; static class Die &amp;#123; int num = 11; Die()&amp;#123; System.out.println(&quot;我是父类无参构造&quot;); &amp;#125; public Die(int num)&amp;#123; System.out.println(&quot;我是父类有参构造&quot;); &amp;#125; public void method()&amp;#123; System.out.println(&quot;我是父类的方法&quot;); &amp;#125; &amp;#125; static class Zi extends Die&amp;#123; int num = 2020; Zi()&amp;#123; this(1); // 第一行不调用子类，或者其他方法，默认调用父类 System.out.println(&quot;我是子类无参构造&quot;); &amp;#125; Zi(int num)&amp;#123; System.out.println(&quot;我是子类有参构造&quot;); &amp;#125; public void method()&amp;#123; System.out.println(&quot;我是子类的方法&quot;); &amp;#125; void function()&amp;#123; // this.method(); this.num = 20; &amp;#125; &amp;#125; &amp;#125; this和super的区别 this和super的区别： this： 当前对象的引用 调用子类的成员变量 调用子类的成员方法 在子类的构造方法第一行调用子类其他构造方法 super ： 子类对象的父类引用 调用父类的成员变量 调用父类的成员方法 在子类的构造方法第一行调用父类的构造方法 4、匿名对象&amp;final 匿名对象：没有名字的对象 场景： ​ 当方法只是使用一次的时候，可以使用匿名对象 ​ 可以当做参数传递，但无法进行操作 注意： ​ 匿名对象可以调用成员对象，并赋值，但是并没有意义，因为只调用一次 package com.a2data; /** * Created by JackFeng on 2020/3/13. */ public class AnonyDemo &amp;#123; public static void main(String[] args) &amp;#123; // Student s = new Student(); // s.study(); new Student(); // 匿名对象，没有变量名引用的对象 &amp;#125; &amp;#125; class Student&amp;#123; String name; int age; public void study()&amp;#123; System.out.println(&quot;加油提升自己&quot;); &amp;#125; &amp;#125; Final 修饰符： 可以用于修饰类，成员方法和成员变量 final所修饰的类，不可被继承，不能有子类 final所修饰的方法，不能被重写。 final所修饰的变量，是不可修改的，是常量 常量： 字面值常量： 1,2,3 自定义常量：被final所修饰的成员变量，一旦初始化则不可改变 注意： 自定义常量必须初始化，可以选择显示初始化或者构造初始化 5、抽象类 abstract: 关键字，用于修饰方法和类 抽象方法： ​ 不同类的方法是相似的，但是具体内容又不太一样，所以我们智能抽取它的申明，没有具体的方法体，没有具体方法体的方法就是抽象方法 抽象类： ​ 有抽象方法的类必须是抽象类 ​ 特点： 抽象方法只能在抽象类里边 抽象类和抽象方法必须被abstract修饰 抽象类不能创建对象（不能实例化） 抽象类中可以有非抽象的方法 抽象类和类的关系也是继承 抽象类的成员特点 成员变量 可以有成员变量 可以有常量 成员方法 可以有抽象方法 可以有非抽象方法 构造方法 可以有构造方法的，需要对抽象类的成员变量进行初始化 注意： ​ 一个类继承了抽象类需要重写他所有的抽象方法,否则这个类就得是抽象类 package com.a2data; import sun.plugin2.message.JavaReplyMessage; /** * Created by JackFeng on 2020/3/15. */ /* * * 普通教练，高级教练 * * * 共性： * 属性 姓名 年龄 性别 * 行为 教学 * * */ public class AbastractTest &amp;#123; public static void main(String[] args) &amp;#123; BasicTeacher bt = new BasicTeacher(); bt.name = &quot;小白教练&quot;; bt.teach(); JobTeacher jt = new JobTeacher(); jt.name = &quot;小灰教练&quot;; jt.teach(); &amp;#125; &amp;#125; abstract class Teacher&amp;#123; String name; // 姓名 int age; // 年龄 String gender; public abstract void teach(); &amp;#125; class BasicTeacher extends Teacher&amp;#123; @Override public void teach() &amp;#123; System.out.println(name + &quot;讲基础内容&quot;); &amp;#125; &amp;#125; class JobTeacher extends Teacher&amp;#123; @Override public void teach() &amp;#123; System.out.println(name+ &quot;讲高级实战内容&quot;); &amp;#125; &amp;#125; 6、接口 interface: 接口是一个比抽象类还抽象的类，接口里所有的方法全是抽象方法,接口和类的关系是实现，implements 格式： interface 接口名 { ​ } 特点： 只能有抽象方法 只能有常量 只能用 publie&amp;abstract 方法 默认使用public static final 来修饰成员变量 建议 手动输入默认修饰符（public&amp;abstract），虽然不输入也会是默认的。 注意： 接口不能创建对象（不能实例化） 类与接口的关系是实现关系，一个类实现一个接口必须实现它的所有方法 类与类：继承关系，单一继承，多层继承 类与接口：实现关系，多实现 接口与接口关系： 继承关系，多层继承 接口优点： 1、类与接口的关系，实现关系，而且是多实现，一个类可以实现多个接口，类与类之间是继承关系，java中的继承是单一继承，一个类只能有一个父类，打破了继承的局限性 2、对外提供规则（统一要求，例如Use接口,充电器接口） 3、降低程序的耦合性 定义规则，模块化开发 高内聚低耦合，提高开发效率 接口和抽象类的区别： 共性： 抽取出抽象的概念 区别1：与类的关系 类与接口是实现关系，多实现 类与抽象类是继承关系，Java中的继承是单一继承，一个类只能有一个父类，java中的继承是多层继承 区别2：成员 成员变量： 抽象类可以有成员变量，也可以有常量 接口只能有常量 成员方法： 抽象类可以有抽象方法，也有非抽象方法 接口只能有抽象方法，默认修饰符 public abstract 构造方法： 抽象类有构造方法的 接口没有构造方法 接口开发的思路 分析： ​ 由下至上 不断向上抽取 实现： ​ 由上至下 先实现共性 应用： ​ 使用具体的子类 package com.a2data; /** * Created by JackFeng on 2020/3/15. */ /* * * 篮球运动员和教练 * 乒乓球运动员和教练 * 篮球运动员和教练要出国访问，需要学习英语 * * * * */ public class InterfaceTest &amp;#123; public static void main(String[] args) &amp;#123; //篮球运动员对象 BasketBallPlayer bp = new BasketBallPlayer(); bp.name = &quot;姚明&quot;; bp.age = 35; bp.gender = &quot;男&quot;; bp.sleep(); bp.study(); bp.speak(); System.out.println(&quot;------------&quot;); //乒乓球教练对象 PingpangCoache pp = new PingpangCoache(); pp.name = &quot;刘教练&quot;; pp.age = 40; pp.gender = &quot;男&quot;; pp.sleep(); pp.teach(); // pp.speak() &amp;#125; &amp;#125; class Person&amp;#123; String name; int age; String gender; public Person() &amp;#123; &amp;#125; public Person(String name, int age, String gender) &amp;#123; // 成员变量初始化 this.name = name; this.age = age; this.gender = gender; &amp;#125; public void eat()&amp;#123; System.out.println(&quot;吃饭&quot;); &amp;#125; public void sleep()&amp;#123; System.out.println(&quot;睡觉&quot;); &amp;#125; &amp;#125; interface SpeakEnglish &amp;#123; public abstract void speak(); &amp;#125; // 运动员 abstract class Player extends Person&amp;#123; //学习 public abstract void study(); &amp;#125; // 教练 abstract class Coach extends Person&amp;#123; // 教 public abstract void teach(); &amp;#125; //篮球运动员 class BasketBallPlayer extends Player implements SpeakEnglish&amp;#123; @Override public void study() &amp;#123; System.out.println(&quot;学扣篮&quot;); &amp;#125; @Override public void speak() &amp;#123; System.out.println(&quot;说英语&quot;); &amp;#125; &amp;#125; //乒乓球运动员 class PingpangPlayer extends Player&amp;#123; @Override public void study() &amp;#123; System.out.println(&quot;学颠球&quot;); &amp;#125; &amp;#125; //篮球教练 class BasketBallCoach extends Coach implements SpeakEnglish&amp;#123; @Override public void teach() &amp;#123; System.out.println(&quot;教扣篮&quot;); &amp;#125; @Override public void speak() &amp;#123; System.out.println(&quot;说英语&quot;); &amp;#125; &amp;#125; //乒乓球教练 class PingpangCoache extends Coach&amp;#123; @Override public void teach() &amp;#123; System.out.println(&quot;教颠球&quot;); &amp;#125; &amp;#125; 7、多态前提 多态的前提： 子父类继承关系 方法的重写 父类引用指向子类对象 动态绑定：运行期间调用的方法，是根据具体的类型，具体的方法 优缺点： 优点： 可以提高可维护性(多态前提所保证的)，提高代码的可扩展性 缺点： 无法直接访问子类特有的成员 package com.a2data; /** * Created by JackFeng on 2020/3/15. */ public class PoymorphicDemo &amp;#123; public static void main(String[] args) &amp;#123; // Cat cat = new Cat(); // cat.eat(); // 父类引用 Animal a // 指向 = // 子类对象 new Cat() // 动态绑定 Animal a = new Cat(); a.eat(); &amp;#125; &amp;#125; class Animal &amp;#123; public void eat()&amp;#123; System.out.println(&quot;c吃东西&quot;); &amp;#125; &amp;#125; class Cat extends Animal&amp;#123; public void eat()&amp;#123; System.out.println(&quot;猫吃鱼&quot;); &amp;#125; &amp;#125; 特点 多态的成员特点： 成员变量 编译时看的是左边，运行时看的是左边 成员方法 编译时看的是左边，运行时看的是右边 静态方法 编译时看的是左边，运行时看的是左边 编译时看的都是左边，运行时成员方法看的是右边，其他（成员变量和静态方法）看的都是左边 package com.java; import java.util.Date; /** * Created by JackFeng on 2020/3/15. */ public class PoymorphicDemo &amp;#123; public static void main(String[] args) &amp;#123; // 成员变量 // 在继承中没有被重写的概念，没有动态绑定的概念 // 执行的是父类的 Dad d = new Kid(); System.out.println(d.num); // 成员方法 // 运行看右边 System.out.println(&quot;----------&quot;); d.method(); // 静态方法 d.function(); // 使用变量去调用静态方法，相当于用变量类型的类名去调用 所以输出父类的静态方法 &amp;#125; &amp;#125; class Dad&amp;#123; int num = 1; public void method()&amp;#123; System.out.println(&quot;我是父类的方法&quot;); &amp;#125; public static void function()&amp;#123; System.out.println(&quot;我是父类的静态方法&quot;); &amp;#125; &amp;#125; class Kid extends Dad&amp;#123; int num = 21; public void method()&amp;#123; System.out.println(&quot;我是子类的方法&quot;); &amp;#125; public static void function()&amp;#123; System.out.println(&quot;我是子类的静态方法&quot;); &amp;#125; &amp;#125; 多态转型 多态中的向上转型和向下转型： 引用类型之间的转换 向上转型 由小到大（子类型转换成父类型) 向下转型 由大到小 基本数据类型的转换 自动类型转换 由小到大 byte short char – int — long — float – double 强制类型转换 由大到小 package com.java; /** * Created by JackFeng on 2020/3/15. */ public class polymorphicDemo &amp;#123; public static void main(String[] args) &amp;#123; Animal a = new Dog(); // 向上转型 a.eat(); Dog d = (Dog) a; // 向下转型 本身是什么类型 转换成什么类型 d.swim(); &amp;#125; &amp;#125; class Animal&amp;#123; public void eat()&amp;#123; System.out.println(&quot;吃东西&quot;); &amp;#125; &amp;#125; class Dog extends Animal&amp;#123; public void eat()&amp;#123; System.out.println(&quot;啃骨头&quot;); &amp;#125; public void swim()&amp;#123; System.out.println(&quot;狗刨&quot;); &amp;#125; &amp;#125; 8、权限修饰符包 特点：（package） 可以由多层 不同包下的文件名可以重复 包的声明必须在第一行代码 包使用场景类的全名： 包名.类名 同包： ​ 相同包下的类可以直接访问，不需要做其他的操作 异包: ​ 1、使用类的全名 ​ 2、使用关键字import将类导入 注意： ***** 代表的是通配符，代表导入了这个包下所有的类,并没有导入子包下的类 权限修饰符 pubilc —- 访问都是对外的 当前类，相同包下不同的类，不同包下的类 default 当前类，相同包下不同的类 当前包下使用(与protected)区别 private 仅限当前类 protected — 数据保护 当前类，相同包下不同的类 让子类对象使用 9、内部类成员内部类 1、在类的成员位置，和成员变量以及成员方法所在的位置是一样的 2、在内部类当中，可以直接访问外部类的成员，包括私有成员 修饰符： 可以使用权限修饰符修饰成员内部类,但是如果使用私有来修饰，则无法在其他类中访问 可以使用static 修饰成员内部类，不用再创建外部类对象 匿名内部类： 必须在定义匿名内部类得时候创建它得对象 格式： new 类/接口(){ 继承这个类得子类对象，可以重写父类方法 实现这个类得子类对象，必须实现这个接口得所有方法 }； 原理： 创建了继承这个类得子类对象或者创建了实现这个接口得子类对象 应用场景： 作为参数传递 package com.java; /** * Created by JackFeng on 2020/3/15. */ public class InnerDemo &amp;#123; public static void main(String[] args) &amp;#123; Outer.Inner i = new Outer().new Inner(); i.function(); &amp;#125; &amp;#125; class Outer&amp;#123; private int num = 10; public void method()&amp;#123; Inner i = new Inner(); i.function(); &amp;#125; class Inner&amp;#123; public void function()&amp;#123; // 私有成员 可以i直接访问 System.out.println(num); &amp;#125; &amp;#125; &amp;#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"},{"name":"JavaSE","slug":"Java/JavaSE","permalink":"http://www.a2data.cn/categories/Java/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"},{"name":"JDK","slug":"JDK","permalink":"http://www.a2data.cn/tags/JDK/"}]},{"title":"Java常用API","slug":"Java/JavaSE/Java常用API","date":"2020-05-07T15:54:55.000Z","updated":"2020-08-07T10:25:24.403Z","comments":true,"path":"posts/32274.html","link":"","permalink":"http://www.a2data.cn/posts/32274.html","excerpt":"Java常用API-I","text":"Java常用API-I 常用API1、String类功能赋值 String S = “hello “ Objcet： 是类层次结构的根类，所有类都直接活间接的继承该类 判断功能 boolean equals(Object obj) —-比较字符串的内容是否相同 boolean equalsIgnoreCase(String str) —- 比较字符串内容是否相同，忽略大小写 boolean startsWith(String str) —- 判断字符串对象是否以指定的str开头 boolean endsWitn(String str) —- 判断字符串对象是否以指定的str结尾 获取功能 int length() —- 获取字符串的长度 char charAt(int index) —- 获取指定索引处的字符 int indexOf(String str) —- 获取str 在字符串对象中第一次出现的索引 String substring(int start) —- 从start开始截取字符串 String substring(int start,int end) — 从s-e 截取，包括s 不包括e 统计录入大小写数字 package myTest; import java.util.Scanner; /** * Created by JackFeng on 2020/3/2. */ public class StringTest &amp;#123; public static void main(String[] args) &amp;#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个字符串数据：&quot;); String s = sc.nextLine(); //定义统计变量 int BigCount = 0; int SmaCount = 0; int numberCount = 0; //遍历字符 for (int i = 0; i &lt;s.length() ; i++) &amp;#123; char ch = s.charAt(i); if (ch &gt;= &#39;A&#39; &amp;&amp; ch&lt;= &#39;Z&#39;) &amp;#123; BigCount++; &amp;#125;else if(ch &gt;= &#39;a&#39; &amp;&amp; ch&lt;= &#39;z&#39;)&amp;#123; SmaCount++; &amp;#125;else if (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)&amp;#123; numberCount++; &amp;#125;else &amp;#123; System.out.println(&quot;该字符&quot;+ch+&quot;非法&quot;); &amp;#125; &amp;#125; System.out.println(&quot;大写字符&quot;+BigCount); System.out.println(&quot;小写字符&quot;+SmaCount); System.out.println(&quot;数字字符&quot;+numberCount); &amp;#125; &amp;#125; 转换功能 char[ ] toCharArray() —- 把字符串转换为字符数组 String toLlowerCase() —- 把字符串转换为小写字符串 String toUpperCase() —- 把字符串转换为大写字符串 字符串的遍历： A：length() 加上charAt() B：字符串转换字符数组，然后遍历数组 空格&amp;分割 去除字符串两端空格： String trim() 按照指定符号分割字符串 String[ ] split (String str) 实现字符串反转 package myTest; import java.util.Scanner; /** * Created by JackFeng on 2020/3/2. */ /* * 键盘录入：abc 输出 cba * * 反转方法： * A： 把字符串倒着遍历，得到每一个字符拼接成字符串 * B： 把字符串转换成字符数组，然后对字符数组进行反转，最后把字符数组转换为字符串 * * */ public class StringTest1 &amp;#123; public static void main(String[] args) &amp;#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个字符串：&quot;); String s = sc.nextLine(); // 调用方法A // String result = reverse(s); //调用方法B String result = reFan(s); //输出结果 System.out.println(&quot;result:&quot;+result); &amp;#125; // 方案A public static String reverse (String s)&amp;#123; String ss = &quot;&quot;; // 倒着遍历 for (int i = s.length()-1; i &gt;=0 ; i--) &amp;#123; ss+=s.charAt(i); &amp;#125; return ss; &amp;#125; // 方案B public static String reFan( String s)&amp;#123; // 把字符串转换为字符数组 char[] chs = s.toCharArray(); for (int start = 0,end = chs.length-1; start &lt;=end ; start++,end--) &amp;#123; char temp = chs[start]; chs[start] = chs[end]; chs[end] = temp; &amp;#125; // 把字符数组转换为字符串 String ss = new String(chs); return ss; &amp;#125; &amp;#125; 2、StringBuilder类功能 StringBuilder : 可变的字符串，字符串缓冲区类 String 内容是固定 StringBuider 内容是可变的 构造方法： StringBuilder() 成员方法： public int capacity() :返回当前容量 public int length() :返回长度(字符数) 容量 —- 理论值 长度 —- 实际值 常用方法 添加功能： public StringBuilder append(任意类型) 添加数据，并返回自身对象 链式编程 sb.append(“hello”).append(“world) 反转功能 public StringBuilder reverse() StringBuilder ——&gt;String toString() —— 转成String String ——&gt; StringBuilder StringBuilder (String str) —– 构造方法 键盘录入对称判断package myTest; import java.util.Scanner; /** * Created by JackFeng on 2020/3/2. */ /* * 判断一个字符串是否是对称字符串 * * 例如 abc 不是 aba abba aaa 是对称字符串 * * */ public class StringBuilderDemo &amp;#123; public static void main(String[] args) &amp;#123; // 键盘录入 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个字符串：&quot;); String s = sc.nextLine(); // 方法实现 // 调用方法 boolean b = isDuiChen(s); System.out.println(&quot;b:&quot;+b); &amp;#125; public static boolean isDuiChen(String s)&amp;#123; StringBuilder sb = new StringBuilder(s); sb.reverse(); String result = sb.toString(); return result.equals(s); &amp;#125; &amp;#125; 3、对象数组 对象数组练习： 定义学生类 创建学生数组 创建学生对象 把学生对象作为元素赋值给学生数组 遍历学生数组 package com.datascience.myArray; /** * Created by JackFeng on 2020/3/2. */ public class StudentDemo &amp;#123; public static void main(String[] args) &amp;#123; // 创建学生数组 Student[] students = new Student[3]; //创建学生对象 Student s1 = new Student(&quot;荣耀王者&quot;, 50); Student s2 = new Student(&quot;星耀&quot;, 10); Student s3 = new Student(&quot;王者&quot;, 20); //学生对象 作为元素赋值给学生数组 students[0] = s1; students[1] = s2; students[2] = s3; //遍历学生数组 for (int i = 0; i &lt;students.length ; i++) &amp;#123; Student s = students[i]; System.out.println(s); //这样输出的是地址值 System.out.println(s.getName()+&quot;=====&quot;+s.getAge()); &amp;#125; &amp;#125; &amp;#125; 学生类 package com.datascience.myArray; /** * Created by JackFeng on 2020/3/2. */ // alt + insert 可以快速生成 get/set 方法等 public class Student &amp;#123; private String name; private int age; public Student(String name,int age) &amp;#123; this.name = name; this.age = age; &amp;#125; public Student() &amp;#123; &amp;#125; public String getName() &amp;#123; return name; &amp;#125; public void setName(String name) &amp;#123; this.name = name; &amp;#125; public int getAge() &amp;#123; return age; &amp;#125; public void setAge(int age) &amp;#123; this.age = age; &amp;#125; &amp;#125; 4、集合ArrayList ArrayList： 大小可变数组的实现 : 特殊的数据类型：泛型 构造方法： ArrayList() 添加元素： pubilc boolean add(E e) — 添加元素 public void add (int index, E element) — 指定索引处 添加元素 获取元素： public E get(int index) —- 返回指定索引出的元素 集合长度： public int size() 返回集合中元素的个数 删除元素： public boolean remove(object o) 删除指定的元素，返回删除是否成功 pubilc E remove(int index) 删除指定索引出的元素，返回被删除的元素 修改元素： public E set(int index, E element) 修改指定索引出的元素，返回被修改的元素 AarryList(集合)遍历： size() + get 方法 package com.myArray; import java.util.ArrayList; /** * Created by JackFeng on 2020/3/ */ public class ArrayListDemo &amp;#123; public static void main(String[] args) &amp;#123; // 创建集合对象 ArrayList&lt;Object&gt; array = new ArrayList&lt;&gt;(); // 这里如果是String 接受就是String Object 接受就是Object // add(E e) 添加元素 array.add(&quot;hello&quot;); array.add(&quot;world&quot;); array.add(&quot;Data&quot;); System.out.println(array); // 在指定索引处添加一个元素 // 第一个位置添加 Science array.add(1,&quot;Science&quot;); System.out.println(&quot;====&quot;); System.out.println(&quot;array&quot;+ array); //获取元素 get System.out.println(array.get(1)); // 集合长度 size System.out.println(&quot;集合的长度：&quot;+array.size()); // 删除元素 remove System.out.println(&quot;remove：&quot;+array.remove(&quot;hello&quot;)); System.out.println(&quot;remove：&quot;+array.remove(&quot;hello&quot;)); // 不存在则失败，这里就是失败了 false //删除指定元素 remove (int index) System.out.println(&quot;remove：&quot;+ array.remove(1)); // 修改元素 set (int index , E element) System.out.println(&quot;set:&quot;+ array.set(1,&quot;hhha&quot;)); // System.out.println(array); // 添加元素 array.add(&quot;aaa&quot;); array.add(&quot;abc&quot;); array.add(&quot;acd&quot;); //遍历集合 System.out.println(&quot;================&quot;); for (int i = 0; i &lt;array.size() ; i++) &amp;#123; System.out.println(array.get(i)); &amp;#125; // 标准遍历 for (int i = 0; i &lt;array.size() ; i++) &amp;#123; // object Object s = array.get(i); System.out.println(s); &amp;#125; &amp;#125; &amp;#125; Test package com.myArray; import java.util.ArrayList; import java.util.Scanner; /** * Created by JackFeng on 2020/3/ */ /* * * 创建一个集合：存储学生对象，学生对象的数据来自键盘录入，最后遍历集合 * * * 分析： * A： 定义学生类 String name , String age * B： 创建集合对象 * C： 键盘录入数据，创建学生对象，把键盘录入的数据赋值给学生对象的成员变量 * D： 把学生对象作为元素存储到集合中 * E： 遍历集合 * * */ public class ArrayListTest &amp;#123; public static void main(String[] args) &amp;#123; //创建集合对象 ArrayList&lt;Student&gt; array = new ArrayList&lt;Student&gt;(); //d调用方法 addStudent(array); addStudent(array); addStudent(array); //遍历集合 for (int i = 0; i &lt;array.size() ; i++) &amp;#123; Student s = array.get(i); System.out.println(s.getName() +&quot;-------&quot;+ s.getAge()); &amp;#125; &amp;#125; /* * 提高复用性，键盘录入学生信息 封装成一个方法 * * 两个明确： * 返回值类型： void * 参数列表： ArrayList&lt;Student&gt; * * * */ public static void addStudent (ArrayList&lt;Student&gt; array)&amp;#123; //键盘录入 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入姓名：&quot;); String name = sc.nextLine(); System.out.println(&quot;请输入年龄：&quot;); String age = sc.nextLine(); //赋值给成员变量 Student s = new Student(); s.setName(name); s.setAge(age); //学生对象存储到集合中 array.add(s); &amp;#125; &amp;#125; 简易学生管理系统 步骤： ​ A： 定义学生类 ​ B： 主界面的代码编写 ​ C： 查看所有学生 ​ D： 添加学生 ​ E： 修改学生 ​ F： 删除学生 Student package myStudentManager; /** * Created by JackFeng on 2020/3/4. */ /* * * 学生类 * */ public class Student &amp;#123; private String id; // 姓名 private String name; // private String age; private String address; public Student() &amp;#123; &amp;#125; public Student(String id, String name, String age, String address) &amp;#123; this.id = id; this.name = name; this.age = age; this.address = address; &amp;#125; public String getId() &amp;#123; return id; &amp;#125; public void setId(String id) &amp;#123; this.id = id; &amp;#125; public String getName() &amp;#123; return name; &amp;#125; public void setName(String name) &amp;#123; this.name = name; &amp;#125; public String getAge() &amp;#123; return age; &amp;#125; public void setAge(String age) &amp;#123; this.age = age; &amp;#125; public String getAddress() &amp;#123; return address; &amp;#125; public void setAddress(String address) &amp;#123; this.address = address; &amp;#125; &amp;#125; Test package myStudentManager; import java.util.ArrayList; import java.util.Scanner; /** * Created by JackFeng on 2020/3/4. */ public class StudentMangerTest &amp;#123; public static void main(String[] args) &amp;#123; //创建集合对象，存储学生数据 ArrayList&lt;Student&gt; array = new ArrayList&lt;&gt;(); while (true) &amp;#123; // 主界面 System.out.println(&quot;---------欢迎来到学生管理系统----------&quot;); System.out.println(&quot;1 查看所有学生&quot;); System.out.println(&quot;2 添加学生&quot;); System.out.println(&quot;3 删除学生&quot;); System.out.println(&quot;4 修改学生&quot;); System.out.println(&quot;5 退出&quot;); System.out.println(&quot;请输入你的选择：&quot;); // 键盘录入 Scanner sc = new Scanner(System.in); String choice = sc.nextLine(); switch (choice) &amp;#123; case &quot;1&quot;: // 查看所有学生 findAllStudent(array); break; case &quot;2&quot;: // 添加学生 addStudent(array); break; case &quot;3&quot;: //删除学生 delStudent(array); break; case &quot;4&quot;: //修改学生 updataStudent(array); break; case &quot;5&quot;: //退出 // break; case 穿透 default: System.out.println(&quot;谢谢你的使用！&quot;); System.exit(0); // jvm 退出 break; &amp;#125; &amp;#125; &amp;#125; //1 查看所有学生 public static void findAllStudent(ArrayList&lt;Student&gt; array)&amp;#123; // 判断集合中是否有数据，如果没有数据，给出提示，并让该方法不继续往下执行 if (array.size()==0)&amp;#123; System.out.println(&quot;不好意思，暂无学生信息，请重新选择你的操作&quot;); return;// void 没有返回值 可以直接return &amp;#125; // \\t System.out.println(&quot;学号\\t\\t姓名\\t年龄\\t地址&quot;); for (int i = 0; i &lt; array.size(); i++) &amp;#123; Student s = array.get(i); System.out.println(s.getId()+&quot;--&quot;+s.getName()+&quot;--&quot;+s.getAge()+&quot;---&quot;+s.getAddress()); &amp;#125; &amp;#125; // 添加学生 public static void addStudent(ArrayList&lt;Student&gt; array)&amp;#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); // id 定义在外边 因为下边还要用 String id; // 代码重复使用 while (true)&amp;#123; System.out.println(&quot;请输入 学生ID：&quot;); // String id = sc.nextLine(); id = sc.nextLine(); //判断学号是否存在 // 定义标记默认为false boolean flag = false; for (int i = 0; i &lt;array.size() ; i++) &amp;#123; Student s = array.get(i); if (s.getId().equals(id))&amp;#123; flag = true; // 说明学号被占用 &amp;#125; &amp;#125; if (flag)&amp;#123; System.out.println(&quot;你输入的学号已经被占用&quot;); &amp;#125;else &amp;#123; break; &amp;#125; &amp;#125; System.out.println(&quot;请输入 学生姓名：&quot;); String name = sc.nextLine(); System.out.println(&quot;请输入 学生年龄：&quot;); String age = sc.nextLine(); System.out.println(&quot;请输入 学生地址：&quot;); String address = sc.nextLine(); //创建学生对象 Student s = new Student(); s.setId(id); s.setAge(age); s.setName(name); s.setAddress(address); // 把学生对象添进 集合 array.add(s); System.out.println(&quot;学生信息添加成功====姓名为： &quot;+s.getName()); &amp;#125; public static void delStudent(ArrayList&lt;Student&gt; array)&amp;#123; //根据学号删除 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入要删除学生的学号：&quot;); String id = sc.nextLine(); // 定义一个索引 int index = -1; //遍历集合 for (int i = 0; i &lt;array.size() ; i++) &amp;#123; //获取每个学生的对象 Student s = array.get(i); if (s.getId().equals(id))&amp;#123; // array.remove(i); // 根据索引删除 index = i; break; &amp;#125; // System.out.println(&quot;删除学生成功！&quot;); &amp;#125; if (index == -1)&amp;#123; System.out.println(&quot;不好意思，您输入的学号不存在，请重新输入&quot;); &amp;#125;else &amp;#123; array.remove(index); // 根据索引删除 System.out.println(&quot;删除学生成功&quot;); &amp;#125; &amp;#125; // 修改学生 public static void updataStudent(ArrayList&lt;Student&gt; array)&amp;#123; // 创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入你要修改学生的学号：&quot;); String id = sc.nextLine(); // 定义一个索引 int index = -1; for (int i = 0; i &lt;array.size() ; i++) &amp;#123; //获取每一个学生对象 Student s = array.get(i); if (s.getId().equals(id))&amp;#123; index = i; break; &amp;#125; &amp;#125; if (index == -1)&amp;#123; System.out.println(&quot;不好意思，你要修改的学生信息不存在，请重新你的选择&quot;); &amp;#125;else &amp;#123; System.out.println(&quot;请输入学生新姓名：&quot;); String name = sc.nextLine(); System.out.println(&quot;请输入学生新年龄：&quot;); String age = sc.nextLine(); System.out.println(&quot;请输入学生新住址：&quot;); String address = sc.nextLine(); Student s = new Student(); s.setId(id); s.setName(name); s.setAddress(address); s.setAge(age); // 修改集合中的学生信息 array.set(index, s); System.out.println(&quot;修改学生信息成功&quot;); &amp;#125; &amp;#125; &amp;#125; 5、IO字符流 IO流用来处理设备之间的数据传输 文件复制，上传、下载文件 IO流分类 输出流 FileWriter 输入流 FileReader 常见的换行符： Windows \\r\\n Linux \\n Mac \\r 5.0、写数据package myIo; import java.io.FileWriter; import java.io.IOException; /** * Created by JackFeng on 2020/3/8. */ /* * 需求： 往文件中写数据 * * 写数据 -- 输出流 ---FileWriter * * * */ public class FileWriterDemo &amp;#123; public static void main(String[] args) throws IOException &amp;#123; // 创建输出流对象 // 调用系统资源创建一个文件,创建输出流对象，把输出流对象指向文件 // 不写路径 就会在 在相对路径下创建！ // FileWriter fw = new FileWriter(&quot;D:\\\\Practice\\\\Java\\\\JavaSE\\\\a.txt&quot;); // 默认为false FileWriter fw = new FileWriter(&quot;D:\\\\Practice\\\\Java\\\\JavaSE\\\\a.txt&quot;,true); // true 为追加写入 // 写字符串数据 // fw.write(&quot;IO你好&quot;); // 数据没有直接写入 到文件中， 其实是写到了内存缓冲区 // fw.flush(); // 刷新缓冲区 // 释放资源 通知系统释放和该文件相关的资源 // 写数据的几种方法 /* * 1、write(String str) 写一个字符串数据 * * */ // 1 // fw.write(&quot;abcde&quot;); //2 // fw.write(&quot;abcd&quot;,1,2); // 3 // fw.write(97); // 4 写一个数组 // char[] chs = &amp;#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&amp;#125;; // fw.write(chs); // 5 // fw.write(chs, 0, 1); // 数据换行 + 数据追加写入 // \\n 可以换行，windows 没有换行 ，\\r\\n for (int i = 0; i &lt; 10 ; i++) &amp;#123; fw.write(&quot;Hi&quot;+i); fw.write(&quot;\\r\\n&quot;); &amp;#125; fw.close(); // 先刷新缓冲区。再通知系统释放资源 &amp;#125; &amp;#125; 5.1、读数据package myIo; import java.io.FileReader; import java.io.IOException; /** * Created by JackFeng on 2020/3/8. */ public class FileReaderDemo &amp;#123; public static void main(String[] args) throws IOException &amp;#123; // 创建输入流 对象 FileReader fr = new FileReader(&quot;D:\\\\Practice\\\\Java\\\\JavaSE\\\\a.txt&quot;); /* // 读数据方法 // 1. int read() // 第一次读数据 int ch = fr.read(); System.out.println(ch); System.out.println((char)ch); // 第二次 ch = fr.read(); System.out.println(ch); System.out.println((char)ch); // 如果读取数据的返回值 是 -1的时候 说明结束了*/ // 标准代码 // 读取 字符串 /* int ch; while ((ch=fr.read())!= -1)&amp;#123; // System.out.println(ch); System.out.print((char)ch); &amp;#125;*/ //第二种读取数据方式 一次读取一个数组的数据 // 标准代码 效率较高 // char[] chs = new char[5]; char[] chs = new char[1024]; // 一般写1024 及其整数倍 int len; while ((len= fr.read(chs)) != -1)&amp;#123; System.out.print(new String(chs,0,len)); // 以数组方式读入 &amp;#125; fr.close(); // 释放资源 &amp;#125; &amp;#125; 5.2、文件复制package myIo; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; /** * Created by JackFeng on 2020/3/8. */ public class CopyFileDemo &amp;#123; public static void main(String[] args) throws IOException &amp;#123; // 创建输入刘对象 FileReader fr = new FileReader(&quot;D:\\\\Practice\\\\Java\\\\JavaSE\\\\src\\\\myIo\\\\FileWriterDemo.java&quot;); // 创建输出流对象 FileWriter fw = new FileWriter(&quot;Copy.java&quot;); //读写数据 /* int ch; while ((ch=fr.read())!=-1)&amp;#123; fw.write(ch); &amp;#125;*/ char[] chs = new char[1024]; int len; while ((len= fr.read(chs))!= -1)&amp;#123; fw.write(chs,0,len); &amp;#125; fr.close(); fw.close(); &amp;#125; &amp;#125; 5.3、字符缓冲流BufferedWriter —- 高效写入 BufferedReader — 高效读取 不是直接传入文件，而是传入 FileWriter 特殊功能 BufferedWriter Void newLine() —- 写一个换行符，这个换行符由系统决定的 BufferedReader String readLine() —- 一次读取一行数据,但是不读取换行符 package myIo; import java.io.*; /** * Created by JackFeng on 2020/3/8. */ public class BufferedDemo &amp;#123; public static void main(String[] args) throws IOException &amp;#123; // 创建输出缓冲流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;a.txt&quot;)); bw.write(&quot;hello world&quot;); // bw.flush(); for (int i = 0; i &lt; 10 ; i++) &amp;#123; bw.write(&quot;Hi&quot;+i); // bw.write(&quot;\\r\\n&quot;); bw.newLine(); // 等同于 bw.write(&quot;\\r\\n&quot;); &amp;#125; bw.close(); // 创建输入缓冲流对象 BufferedReader br = new BufferedReader( new FileReader(&quot;a.txt&quot;)); // 一次写一个字符 /* int ch; while ((ch=br.read())!= -1)&amp;#123; System.out.print((char) ch); &amp;#125;*/ // 一次读写一个数组 /* char[] chs = new char[1024]; int len; while ((len = br.read(chs))!= -1) // System.out.print(chs,0,len); 这里会报错 需要 new String 构造 System.out.println(new String(chs,0,len)); br.close();*/ String line; // br.readLine while((line= br.readLine())!=null)&amp;#123; System.out.println(line); &amp;#125; br.close(); &amp;#125; &amp;#125; 集合数据写入文件 package myIo; import java.io.BufferedWriter; import java.io.FileWriter; import java.io.IOException; import java.util.ArrayList; /** * Created by JackFeng on 2020/3/8. */ public class ArrayListToFileTest &amp;#123; public static void main(String[] args) throws IOException &amp;#123; // 创建集合对象 ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;(); // 给集合添加元素 array.add(&quot;hello&quot;); array.add(&quot;world&quot;); array.add(&quot;今天是2020，三八妇女节&quot;); // 创建缓冲流输出对象 BufferedWriter bw = new BufferedWriter( new FileWriter(&quot;array.txt&quot;)); //遍历集合写入到文件 for (int i = 0; i &lt;array.size() ; i++) &amp;#123; String s = array.get(i); bw.write(s); bw.newLine(); // 读取换行 bw.flush(); &amp;#125; bw.close(); &amp;#125; &amp;#125; 文件存入集合 package myIo; import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import java.util.ArrayList; /** * Created by JackFeng on 2020/3/8. */ public class FileToArrayList &amp;#123; public static void main(String[] args) throws IOException &amp;#123; // 创建输入缓冲流对象 BufferedReader br = new BufferedReader(new FileReader(&quot;array.txt&quot;)); // 创建集合对象 ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); // 读取数据 每次读取一行数据， 把该行数据作为一个元素存储到集合中 String line; while ((line = br.readLine())!= null)&amp;#123; array.add(line); &amp;#125; br.close(); //遍历集合 for (int i = 0; i &lt;array.size() ; i++) &amp;#123; String s = array.get(i); System.out.println(s); &amp;#125; &amp;#125; &amp;#125; 学生管理添加升级版本 package myIo; import myStudentManager.Student; import java.io.BufferedWriter; import java.io.FileWriter; import java.io.IOException; import java.util.ArrayList; import java.util.Scanner; /** * Created by JackFeng on 2020/3/8. */ public class ArratListToFileTest &amp;#123; public static void main(String[] args) throws IOException &amp;#123; ArrayList&lt;Student&gt; array = new ArrayList&lt;&gt;(); // 写方法添加学生对象 addStudent(array); addStudent(array); addStudent(array); // 创建输出缓冲流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;std.txt&quot;)); for (int i = 0; i &lt;array.size() ; i++) &amp;#123; Student s = array.get(i); // 链式编程 /// 姓名,年龄,。。。 采用 StringBuilder StringBuilder sb = new StringBuilder(); sb.append(s.getId()).append(&quot;,&quot;).append(s.getName()).append(&quot;,&quot;).append(s.getAddress()).append(&quot;,&quot;).append(s.getAge()); bw.write(sb.toString()); // 转化为string bw.newLine(); // 换行 bw.flush(); // 刷新 &amp;#125; bw.close(); &amp;#125; // 添加学生 public static void addStudent(ArrayList&lt;Student&gt; array)&amp;#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); // id 定义在外边 因为下边还要用 String id; // 代码重复使用 while (true)&amp;#123; System.out.println(&quot;请输入 学生ID：&quot;); // String id = sc.nextLine(); id = sc.nextLine(); //判断学号是否存在 // 定义标记默认为false boolean flag = false; for (int i = 0; i &lt;array.size() ; i++) &amp;#123; Student s = array.get(i); if (s.getId().equals(id))&amp;#123; flag = true; // 说明学号被占用 &amp;#125; &amp;#125; if (flag)&amp;#123; System.out.println(&quot;你输入的学号已经被占用&quot;); &amp;#125;else &amp;#123; break; &amp;#125; &amp;#125; System.out.println(&quot;请输入 学生姓名：&quot;); String name = sc.nextLine(); System.out.println(&quot;请输入 学生年龄：&quot;); String age = sc.nextLine(); System.out.println(&quot;请输入 学生地址：&quot;); String address = sc.nextLine(); //创建学生对象 Student s = new Student(); s.setId(id); s.setAge(age); s.setName(name); s.setAddress(address); // 把学生对象添进 集合 array.add(s); System.out.println(&quot;学生信息添加成功====姓名为： &quot;+s.getName()); &amp;#125; &amp;#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"},{"name":"JavaSE","slug":"Java/JavaSE","permalink":"http://www.a2data.cn/categories/Java/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"},{"name":"API","slug":"API","permalink":"http://www.a2data.cn/tags/API/"}]},{"title":"Java面向对象(封装)","slug":"Java/JavaSE/Java面向对象-封装","date":"2020-05-07T15:54:34.000Z","updated":"2020-08-07T10:25:37.004Z","comments":true,"path":"posts/8589.html","link":"","permalink":"http://www.a2data.cn/posts/8589.html","excerpt":"Java面向对象 封装！","text":"Java面向对象 封装！ 面向对象（封装） 面向对象思想： 面向对象是基于面向过程的编程思想。 面向过程：强调每一个功能的步骤 面向对象：强调的是对象，然后用对象去调用功能 特点 A:符合我们思考习惯的思想 B:可以将复杂的事情简单化 C:执行者—-指挥者 类和对象 A：属性 —- 就是事物的描述信息 B：行为 —- 事物能够做什么 类：一组相关属性和行为的集合 对象： 就是该事物的具体体现 成员变量 位置： 类中，方法外 初始化值：不需要 成员方法 去掉static 关键字 Phone package myTest; /** * Created by JackFeng on 2020/3/2. */ public class Phone &amp;#123; String barnd; int price; String color; public void call(String name) &amp;#123; System.out.println(&quot;给&quot; + name + &quot;打电话&quot;); &amp;#125; public void sendMessage()&amp;#123; System.out.println(&quot;给所有人群发短信&quot;); &amp;#125; &amp;#125; PhoneDemo package myTest; /** * Created by JackFeng on 2020/3/2. */ public class PhoneDemo &amp;#123; public static void main(String[] args) &amp;#123; Phone p = new Phone(); System.out.println(p.barnd + &quot;---&quot; +p.price+ &quot;----&quot;+p.color); p.barnd = &quot;iphone&quot;; p.price = 8888; p.color = &quot;金色&quot;; System.out.println(p.barnd + &quot;---&quot; +p.price+ &quot;----&quot;+p.color); p.call(&quot;DataScience&quot;); p.sendMessage(); &amp;#125; &amp;#125; 成员变量和局部变量的区别 区别： A: 在类中的位置不同 成员变量：类中，方法外 局部变量：方法中或者方法声明上(形式参数) B：在内存中的位置不同 成员变量：堆内存 局部变量：栈内存 C：生命周期不同 成员变量：随着对象的创建而存在，随着对象的消失而消失 局部变量：随着方法的调用而存在，随着方法调用完毕而消失 D：初始化值的问题 成员变量：有默认值 局部变量：没有默认值，必须先定义，赋值，最后使用 package myTest; /** * Created by JackFeng on 2020/3/2. */ public class Variable &amp;#123; // 成员变量 int x; public void show ()&amp;#123; //局部变量 // int y; // 如果y 没有值 就会报错 int y = 1; // 赋值就会不报错 System.out.println(y); // 调用x 有默认值 System.out.println(x); &amp;#125; &amp;#125; 标准学生类代码 package myTest; /** * Created by JackFeng on 2020/3/2. */ public class StudentDemo &amp;#123; public static void main(String[] args) &amp;#123; // 无参 + set方法 Student s = new Student(); s.setName(&quot;Data&quot;); s.setAge(26); System.out.println(s.getName()+&quot;====&quot;+s.getAge()); // 带参构造 Student s2 = new Student(&quot;DataScinece&quot;, 26); System.out.println(s2.getName()+&quot;====&quot;+s2.getAge()); &amp;#125; &amp;#125; 学生类 package myTest; /** * Created by JackFeng on 2020/3/2. */ public class Student &amp;#123; private String name; private int age; // 构造方法 // 无参数 public Student()&amp;#123;&amp;#125; // 有参数 public Student(String name, int age )&amp;#123; this.name = name; this.age = age; &amp;#125; // get set 方法 public String getName() &amp;#123; return name; &amp;#125; public void setName(String name) &amp;#123; this.name = name; &amp;#125; public int getAge() &amp;#123; return age; &amp;#125; public void setAge(int age) &amp;#123; this.age = age; &amp;#125; &amp;#125; 类名 如果类名作为形式参数传递 要的是该类的对象 如果类名作为返回值类型 返回的是该类的对象","categories":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"},{"name":"JavaSE","slug":"Java/JavaSE","permalink":"http://www.a2data.cn/categories/Java/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"},{"name":"JDK","slug":"JDK","permalink":"http://www.a2data.cn/tags/JDK/"}]},{"title":"Java基础语法","slug":"Java/JavaSE/Java基础语法","date":"2020-05-07T15:54:10.000Z","updated":"2020-08-07T10:25:33.685Z","comments":true,"path":"posts/34708.html","link":"","permalink":"http://www.a2data.cn/posts/34708.html","excerpt":"Java基础语法","text":"Java基础语法 1、基础语法Hello Wolrd 首先定义类 —— public class 类名 在类定义之后加上一对大括号 —— {} 在大括号中间添加一个主(main)方法/函数 —— public static void main(String[] args){} 在主方法的大括号中间添加一行输出语句 —— System.out.println(“Hello World”) 完整代码 public class HelloWorld&#123; public class static void main(String[] args)&#123; System.out.println(&quot;Hello World!&quot;) &#125; &#125; Javac —— 编译 javac HelloWorld.java Java + HelloWorld 运行 初学者注意事项 单词拼写问题 — class &gt; Class — String &gt; string — System &gt; system — main &gt; mian 中文符合问题 — 提示非法字符 1.1、Java入门1.1.0、注释 注释 // #单行注释 /*…*/ #多行注释 /...*/ #文本注释 JAVA 语句用 ； 分号结束。 命名 A、类：首字母大写 B、方法/函数：首字母小写第二个单词首字母大写 C、变量： 首字母小写第二个单词首字母大写 D、常量：全部字母大写 标识符程序员对程序中的各个元素加以命名时，使用的命名记号，称为标识符。 标识符以字母 下划线（__） 美元符（$）开始的一个字符序列， 后可跟 字母，下划线，美元符，数字。 1.1.1、关键字 JAVA关键字(保留字）* abstract default if private this boolean do implements protected throw break double impor public throws byte else instanceof return transient case extends int short try catch final interface statictfp volatile char finally long strictfp volatile class float native super while const for new switch null continue goto package synchronized 1.1.2、常量 常量：程序执行中，值不可发生改变 变量：在程序执行中，值会发生变化 常量分类 —— A： 字符串常量 ‘DataScience’ —— B： 整数常量 123 —— C： 小数常量 1.23 —— D： 字符常量 ‘a’,’1’ —— E： 布尔常量 true ,false—— F： 空常量 （null、’’) public class CL&amp;#123; public static void main(String[] args)&amp;#123; // 字符串常量 System.out.println(&quot;DataScience&quot;) // 整数常量 System.out.println(123) // 小数常量 System.out.println(1.23) // 字符串量 System.out.println(&quot;Data&quot;) // 布尔常量 System.out.println(true) &amp;#125; &amp;#125; 1.1.3、变量 变量的申明： 访问[修饰符] 数据类型 变量名称=初始值 变量的分类：1、按照声明位置： 成员变量： 类的内部，方法的外部定义的变量 局部变量： 方法或代码块的内部定义的变量 区别： 成员变量有默认初始值，局部变量没有 成员变量的作用域在整个类的内部，局部变量在当前方法或代码块中 变量实例： /** * Created by JackFeng on 2019/8/28. */ /* * 常量: 在程序的执行过程中，其值不可以发生改变的量 * * 常量的分类： * A： 字符串常量 * B： 整数常量 * C： 小数常量 * D： 字符常量 * E： 布尔常量 true ,false * F： 空常量 * * */ public class Variable &amp;#123; public static void main(String[] args) &amp;#123; // A System.out.println(&quot;欢迎关注公众号DataScience&quot;); // B System.out.println(12); System.out.println(-66); // C System.out.println(23.56); //D System.out.println(&#39;a&#39;); // E System.out.println(true); &amp;#125; &amp;#125; 1.1.4、数据类型 数据类型 —— Java是强类型语言，针对每一种数据都给出了明确的数据类型。 数据类型分类： A：基本数据类型 B：引用数据类型 （类、接口、数组） 基本数据类型（以及占用字节数） A、整数 byte 1 short 2 int 4 long 8 B、浮点数 float 4 double 8 C、字符 char 2 D、布尔 boolean 1 注意 A：整数默认是int类型，浮点数默认是double类型 B： 定义long类型数据的时候，要加L或者l，建议加L 定义float类型数据的时候，要加F或者f，建议加F 整型变量 类型 占用储存空间 表数范围 byte 1字节 -128~127 short 2字节 -2^15~2^15-1 int 4字节 -2^31~2^31-1 long 8字节 -2^63~2^63-1 浮点型变量 类型 占用储存空间 表数范围 float 4字节 -3.403E38~3.403E38 double 8字节 -1.798E308~1.798E308 字符型变量： char 一个字符2字节 布尔型变量： true false 符号常量 final 变量类型 变量名=初始化值 值常量整型常量、浮点型常量、符号型常量、字符串常量、布尔型常量（true false） 空常量 转义字符 含义 \\b 退格（backspace） \\t 水平制表（Tab） \\f 走纸换页，只对打印有效 \\n 换行 \\r 回车 \\ 反斜杠字符 &#39; 单引号字符 &quot; 双引号字符 \\ddd 1–3位八进制数所代表的ASCII字符 \\uxxxx 1-4位十六进制数所代表的unicode字符 1.1.5、 计算机存储单元 bit(比特位) —–字节（byte） 单位换算： 1B(字节) = 8it 1KB = 1024B 1MB = 1024KB 1GB = 1024MB 1TB = 1024GB 1PB = 1024TB 1ZB = 1024PB 1.1.6、标识符标识符： 包、类、方法、变量 等起名字的符号 组成规则： A：unicode 字符 数字字符，英文大小写字母，汉字（不建议使用汉字） B：下划线 _ C：美元符 $ 注意事项： A: 不能以数字开头 B：不能是Java中的关键字 常见命名规则： A：基本要求 见名知意 B：常见的命名 1、包（其实就是文件夹，用于对类进行管理） 全部小写，多级包.隔开 EG: com， com.datascience 2、类 单个单词首字母大写 EG:Dog 多个单词首字母大写 EG:BigDog 3、方法和变量 单个单词首字母小写 EG： dog 多个单词组成第二个开始首字母大写 EG: bigDog,maxAge 1.1.7、运算符优先级 优先级 运算符 结合性 1 （） [ ] . 从左向右 2 ！ +（正） -（负） ~ ++ – 从右向左 3 / * % 从左向右 4 + (加) -（减） 从左向右 5 《 》 &gt;&gt;&gt; 从左向右 6 &lt;&lt;=&gt;&gt; instanceof 从左向右 7 == ！= 从左向右 8 &amp; （按位与） 从左向右 9 ^ 从左向右 10 | 从左向右 11 &amp;&amp; 从左向右 12 || 从左向右 13 ?: 从右向左 14 = += -= *= /= %= &amp;= |= ^= ~= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= 从右向左 1.2、基本类型数据转换1.2.1、定义变量变量格式： 数据类型 变量名 = 初始化值 数据类型： byte,short,int,long,float,double,char,boolean Demo public class VariableDemo &amp;#123; /* * 变量的定义 * */ public static void main(String[] args)&amp;#123; // 定义byte 类型 byte a = 10; System.out.println(10); System.out.println(a); // 定义 short类型 short b = 11; System.out.println(b); // 定义int类型 int c = 12; System.out.println(c); // 定义long类型 long d = 1231L; System.out.println(d); // 定义float类型 float e = 1.23F; System.out.println(e); // 定义double类型 double f = 1.23; System.out.println(f); // 定义char类型 char g = &#39;a&#39;; System.out.println(g); // 定义boolean类型 boolean h = true; System.out.println(h); &amp;#125; &amp;#125; 1.2.2、变量定义的注意事项package one; /** * Created by JackFeng on 2020/2/22. */ public class BianLiang &amp;#123; /* * 变量定义的注意事项 * A: 变量未赋值，不能直接使用 * B：变量只在所属的范围内有效（仅在它所在的大括号中有效） * C: 一行可以多个变量（不建议） * */ public static void main(String[] args)&amp;#123; // 定义变量aa、 int aa = 2020; System.out.println(aa); &amp;#123; // 大括号中的就是代码块 int ab = 131; System.out.println(ab); &amp;#125; // 定义多个变量 int a1, a2; a1 =11; a2 = 20; System.out.println(a1); System.out.println(a2); &amp;#125; &amp;#125; 1.2.3、类型转化package one; /** * Created by JackFeng on 2020/2/25. */ /* * +: 加法运算符 * * 运算中，要求参与运算的数据类型必须一致 * * * 类型转化： * 隐式转化 * 强制转化 * 隐式转化： * byte,short,char -- int --long --float --double * byte+ int === int 类型 * 强制转化： * 目标类型 变量名 = （目标类型）（被转化的数据） * 建议：数据做运算，最好以结果类型为准（不要随意转化，否则可能损失精度） * int a = 10; * byte b = 20; * int c = a+b * * byte d = (byte)(a + b) * * * */ public class TypeCastDemo &amp;#123; public static void main(String[] args) &amp;#123; // 1、 定义同类型变量 int a = 11; int b = 22; int c = a + b; System.out.println(c); // 定义一个 byte 类型 一个int类型 int a1 = 10; byte a2 = 20; System.out.println(a1+a2); &amp;#125; &amp;#125; 1.2.4、运算符1.2.4.1、运算符 运算符： 用于 常量和变量操作的符号 表达式：用运算符号链接起来符合java语法的句子 ​ EG: a,b a+b 1.2.4.2、运算符分类1、算术运算符 +，-，*，/ ，%，++，– *+，-，，/** // +,-,*,/ 使用 // 定义变量 int a = 3; int b = 4; System.out.println(a+b); System.out.println(a-b); System.out.println(a*b); System.out.println(a/b); // 整数相除 只能得到整数，要想得到小数 必须有浮点数参与运算 System.out.println(3.0/4); System.out.println(3/4.0); % (取余) *%*：用于获取 两个数据相除时候的余数 */*： 用于获取 两个数据相除时候的商 int a1=3; int a2=5; System.out.println(a2/a1); System.out.println(a2%a1); + +： 加法运算 正常加法运算 int a =10; int b = 12; 字符参与加法运算，是拿字符在计算机中存储的数据值来参与运算的 “A” 65 ‘a’ 97 ‘0’ 48 字符串参与加法运算，其实不是做加法，而是字符串的拼接 例如： int a =1; int b =2; System.out.println(“hello”+a) hello1 System.out.println(a+b+”hello”) ​ 3hello 注意 执行顺序（会对结果产生影响）： 从左–&gt;右 ++，– ++，– ： 自增自减，用于对变量+1 或 -1 单独使用： 放在变量前后都可以，结果一样 其它操作： ++ 在后边，先拿变量做操作，然后变量再++ ++ 在前边，先变量++，再拿变量做操作 package myOperator; /** * Created by JackFeng on 2020/2/25. */ /* * ++ -- : 自增自减 * * */ public class OpeartorDemo1 &amp;#123; public static void main(String[] args) &amp;#123; // 定义变量 int a = 123; System.out.println(&quot;a:&quot;+a); // ++ int b = a++; System.out.println(&quot;a:&quot;+a); System.out.println(&quot;b:&quot;+b); int c = ++a; System.out.println(&quot;a:&quot;+a); System.out.println(&quot;c:&quot;+c); &amp;#125; &amp;#125; 2、赋值运算符 赋值运算符： 基本赋值运算符：= 扩展赋值运算符：+=，-=，*=，/=,….. package myOperator; /** * Created by JackFeng on 2020/2/25. */ /* * 赋值运算符： * 基本的赋值运算符： = * 扩展的赋值运算符： +=，-=，*=，/= ... * * */ public class OpeartorDemo2 &amp;#123; public static void main(String[] args) &amp;#123; // 定义变量 int a = 25; // 把 25 赋值给int 类型的变量a // += 操作 // 拿+= 左边和右边的数据做 加法，然后赋值给左边 a += 5; System.out.println(a); // 注意： 扩展的赋值运算符,隐含了 强制类型转换 // 有一个变量 a, a+=5; // 相当于： a=(a的数据类型)(a+5) short s = 1; s += 1; System.out.println(s); &amp;#125; &amp;#125; 3、关系运算符 关系运算符： ==， !=，&gt;,&gt;=,&lt;,&gt;= 关系运算符结果是 boolean类型.（false/true） 注意事项： 不要把两个== 写成 = （除非你赋值） 4、逻辑运算符 逻辑运算符： 释义：用于链接关系表达式 逻辑运算分类： &amp;，|，^,! &amp;&amp;, || &amp;（或） 有false 则false |（与） 有true则true ^（异或） 相同则false，不同则true ！（非） true则false，false 则 true &amp;&amp; &amp;&amp; 和 &amp; 的结果一样 &amp;&amp; 与 &amp; 的区别： &amp;&amp; 有短路效果，左边为false，右边不执行 &amp; 左边无论是什么，右边都会执行 || || 和 | 的结果一样 || 与 | 的区别： || 左边为true ，右边不执行 | 左边无论是啥，右边都执行 5、三元运算符 三元运算符： 关系表达式？表达式1：表达式2 执行流程： A： 计算关系表达式的值（true/false） B: 结果展示 如果是true，表达式1就是结果 如果是false，表达式2就是结果 // 三元运算符 int aa = 10; int bb = 20; int cc = (aa &gt; bb) ? aa : bb; System.out.println(&quot;====&quot;); System.out.println(&quot;cc&quot;+cc); //输出 ==== cc:20 案例：取三个数中的最大值 // 获取三个数的最大值 int q = 11; int w = 12; int e = 22; // 先获取两个数据的最大值,然后再和第三个数据比较即可 int temp = (q &gt; w) ? q : w; int max = (temp &gt; e) ? temp : e; System.out.println(&quot;+++++++++&quot;); System.out.println(&quot;max:&quot;+max); 1.2.5、键盘录入package myScanner; /** * Created by JackFeng on 2020/2/25. */ /* * * 键盘录入： * 如何实现？ JDK提供的类Scanner * 使用步骤： * A: 导包 * import java.util.Scanner; * 在一个类中顺序： package &gt; import &gt; class * B: 创建键盘录入对象 * Scanner sc = new Scanner(System.in) * C: 接受数据 * int i = sc.nextInt(); * * * * */ import java.util.Scanner; public class ScannerDemo &amp;#123; public static void main(String[] args) &amp;#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入数据： &quot;); int i = sc.nextInt(); System.out.println(&quot;i:&quot;+i); &amp;#125; &amp;#125; 录入数据求和 // 录入数据 并且求和 System.out.println(&quot;请输入第一个数据： &quot;); int aa = sc.nextInt(); System.out.println(&quot;请输入第二个数据： &quot;); int bb = sc.nextInt(); // 数据求和 int sum = aa + bb; System.out.println(&quot;sum:&quot;+sum); // 比较两个数据是否相等 // boolean flag = (aa == bb) ? true : false; boolean flag = (aa == bb); System.out.println(flag); // 录入三个数据,三个数据的最大值 System.out.println(&quot;请输入第三个数据： &quot;); int cc = sc.nextInt(); int temp = (aa &gt; bb) ? aa : bb; int max = (temp&gt;cc)?temp:cc; System.out.println(&quot;max:&quot;+max); 1.2.6、流程控制语句顺序结构 从上往下，依次执行！ 选择结构 if语句： if(关系表达式){ ​ 语句体 } 执行流程 A: 首先计算关系表达式的值，看是true/false B: 如果是true，就执行语句体 C: 如果是False，则不执行 // if 关系表达式 int a = 10; int b = 20; if(a==b)&amp;#123; System.out.print(&quot;a=b&quot;) &amp;#125; int c = 10; if(a==c)&amp;#123; System.out.println(&quot;a=c&quot;) &amp;#125; if(关系表达式){ ​ 语句体1; }else{ ​ 语句体2; } // 判断一个数 是偶数还是奇数 int a = 100; // 重新给a赋值 a = 99; if(a%2 ==0)&amp;#123; System.out.println(&quot;a为偶数&quot;); &amp;#125;else&amp;#123; System.out.println(&quot;a为奇数&quot;); &amp;#125; if(关系表达式1){ ​ 语句体1; }else if(关系表达式2){ ​ 语句体2; } … else{ ​ 语句体n+1; } // 多个if 表达式 int x = 10; int y; if (x &gt;= 3)&amp;#123; y = 2 * x + 1; &amp;#125; else if (x &gt;= -1 &amp;&amp; x&lt;3)&amp;#123; y = 2 * x; &amp;#125;else if (x &lt;= -1)&amp;#123; y = 2 * x - 1; &amp;#125;else &amp;#123; y = 0; System.out.println(&quot;不存在x&quot;); &amp;#125; System.out.println(&quot;y&quot;+y); 键盘录入案例比较 // 键盘录入判断最大值 Scanner sc = new Scanner(System.in); System.out.println(&quot;1:&quot;); int a = sc.nextInt(); System.out.println(&quot;2: &quot;); int b = sc.nextInt(); // 常规比较 if (a &gt; b) &amp;#123; System.out.println(&quot;最大值是：&quot;+a); &amp;#125;else &amp;#123; System.out.println(&quot;最大值是：&quot;+b); &amp;#125; // 用一个变量值接受 int max; if (a &gt; b) &amp;#123; max = a; System.out.println(&quot;max：&quot;+max); &amp;#125;else &amp;#123; max = b; System.out.println(&quot;max：&quot;+max); &amp;#125; // 对变量max 做操作 max = max + 100; System.out.println(max); 1.2.7、选择结构语句switch package myOperator; import java.util.Scanner; /** * Created by JackFeng on 2020/2/26. */ /* * switch语句格式： * switch (表达式)&amp;#123; * case 值1： * 语句体1; * case 值2： * 语句体2; * ... * default: * 语句体n+1; * break; * * &amp;#125; * * * * */ public class SwitchDemo &amp;#123; public static void main(String[] args) &amp;#123; /* * 格式解释： * 表达式： byte，short，int，char * jdk5 以后 可以是枚举 * jdk7 以后 可以是字符串 * case后边的值：就是用来和表达式的值进行匹配的内容 * break：表示中断的意思 * default： 所有值都不匹配的时候（相当于else） * * */ // 键盘录入 1-7 判断星期几 Scanner sc = new Scanner(System.in); // 接受数据 System.out.println(&quot;请输入数字 1-7:&quot;); int weekday = sc.nextInt(); switch (weekday)&amp;#123; case 1: System.out.println(&quot;星期一&quot;); break; case 2: System.out.println(&quot;星期二&quot;); break; case 3: System.out.println(&quot;星期三&quot;); break; case 4: System.out.println(&quot;星期四&quot;); break; case 5: System.out.println(&quot;星期五&quot;); break; case 6: System.out.println(&quot;星期六&quot;); break; case 7: System.out.println(&quot;星期天&quot;); break; default: System.out.println(&quot;你输入的数据有误&quot;); break; &amp;#125; &amp;#125; &amp;#125; 1.2.8、循环结构语句1.2.8.1、forpackage myOperator; /** * Created by JackFeng on 2020/2/26. */ /* * for循环语句的格式： * for(初始化语句;判断条件语句;控制条件语句）&amp;#123; * 循环体语句： * * &amp;#125; * * */ public class ForDemo &amp;#123; public static void main(String[] args) &amp;#123; // 输出10次 hello for (int i=1;i&lt;=10;i++)&amp;#123; System.out.println(&quot;hello&quot;+i); &amp;#125; // 获取 1-5 for (int x =1 ;x &lt;=5;x++)&amp;#123; System.out.println(&quot;-----&quot;); System.out.println(x); &amp;#125; // 获取 5-1 for (int x = 5; x &gt;= 1; x--) &amp;#123; System.out.println(&quot;======&quot;); System.out.println(x); &amp;#125; // 1-5 求和 //初始化值为0 int sum = 0; for (int x =1;x&lt;=5;x++)&amp;#123; sum = sum + x; // sum += x; System.out.println(&quot;累加值为:&quot;+sum); &amp;#125; System.out.println(&quot;sum&quot;+sum); &amp;#125; &amp;#125; 1-100 偶数和 // 结果：2550 int s = 0; for (int x =1;x&lt;=100;x++)&amp;#123; if (x%2 ==0)&amp;#123; s += x; &amp;#125; &amp;#125; System.out.println(&quot;1-100偶数求和为：&quot;+s); 水仙花 //经典案例 水仙花数 // EG: 153 // 个位： 153%10 // 十位： 153/10%10 // 百位： 153/10/10%10 int count = 0; for (int x=100;x&lt;=999;x++)&amp;#123; int gw =x % 10; int sw =x/10 % 10; int bw =x/10/10 % 10; if ((gw*gw*gw +sw*sw*sw + bw*bw*bw )==x)&amp;#123; System.out.println(x); count++; //统计次数 &amp;#125; &amp;#125; //输出统计值 System.out.println(count); 1.2.8.2、whilepackage myOperator; /** * Created by JackFeng on 2020/2/26. */ public class WhileDemo &amp;#123; public static void main(String[] args) &amp;#123; // 输出10次 你好 // for 实现 for (int i =1;i&lt;=10;i++)&amp;#123; System.out.println(&quot;你好&quot;); &amp;#125; // while 实现 int s = 1; while (s&lt;=10)&amp;#123; System.out.println(&quot;Nihao&quot;); s++; &amp;#125; &amp;#125; &amp;#125; 1.2.8.3、do…whilepackage myOperator; /** * Created by JackFeng on 2020/2/26. */ public class DoWhileDemo &amp;#123; public static void main(String[] args) &amp;#123; // 输出10次 HI for (int i =1;i&lt;=10;i++)&amp;#123; System.out.println(&quot;Hi&quot;); &amp;#125; // do while 改写 int x = 1; do &amp;#123; // 循环体语句 System.out.println(&quot;HI hi&quot;); // 控制条件语句 x++; &amp;#125; // 判断体语句 while (x &lt;= 10); &amp;#125; &amp;#125; 1.2.8.4、 三种循环语句区别 A: do…while 循环至少执行一次循环体 B: for和 while 必须判断条件成立才执行循环体 package myOperator; /** * Created by JackFeng on 2020/2/26. */ public class XunDemo &amp;#123; public static void main(String[] args) &amp;#123; int x = 3; while(x &lt;3)&amp;#123; System.out.println(&quot;while 循环体&quot;); x++; &amp;#125; int y = 3; do &amp;#123; System.out.println(&quot; do while 循环ti &quot;); y++; &amp;#125; while (y &lt; 3); &amp;#125; &amp;#125; for 和 while 区别 for循环结束后，初始化变量不可被使用。 while 循环结束后，初始化变量可以被使用。 推荐使用顺序： for while do…while // for 和 while 的区别 public static void main(String[] args) &amp;#123; //for for (int i = 0; i &lt;5 ; i++) &amp;#123; System.out.println(&quot;这里是for循环&quot;); &amp;#125; // System.out.println(&quot;i:&quot;+i); 这里是调用不了的 //while int x =0; while (x&lt;5)&amp;#123; System.out.println(&quot;while循环&quot;); x++; &amp;#125; System.out.println(&quot;x:&quot;+x); &amp;#125; 1.2.9、跳转控制语句Break（中断） break：中断 使用场景： A：switch语句中 B：循环中 注意： 离开场景，将无意义。 作用： 用于结束循环 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class BreakDemo &amp;#123; public static void main(String[] args) &amp;#123; for (int i = 0; i &lt;4 ; i++) &amp;#123; System.out.println(&quot;这是个正常的循环&quot;); &amp;#125; System.out.println(&quot;============&quot;); for (int i = 0; i &lt;4 ; i++) &amp;#123; if (i==1)&amp;#123; break; &amp;#125; System.out.println(&quot;这是加入break控制的循环&quot;); &amp;#125; &amp;#125; &amp;#125; Continue（继续） continue：继续 使用场景： 循环中 作用： 结束一次循环，进入下一次循环。 package com.data.it; import java.sql.SQLOutput; /** * Created by JackFeng on 2020/3/1. */ public class BreakAndContinueDemo &amp;#123; public static void main(String[] args) &amp;#123; for (int i = 0; i &lt;=10 ; i++) &amp;#123; // break:结束整个循环 if (i == 2)&amp;#123; break; &amp;#125; System.out.println(&quot;B And C&quot;); // continue 结束本次循环，继续下一次循环 if (i==3)&amp;#123; continue; &amp;#125; System.out.println(&quot;C === A&quot;); &amp;#125; &amp;#125; &amp;#125; 1.3、Random Random：用于产生随机数 使用步骤： A：导包 import java.util.Random; B：创建对象 Random r = new Random(); C：获取随机数 int number = r.nextInt(10) 数据范围：[0,10) 包括0，但不包括10 package com.data.it; import java.util.Random; /** * Created by JackFeng on 2020/3/1. */ public class RandomDemo &amp;#123; public static void main(String[] args) &amp;#123; //创建对象 Random r = new Random(); // 获取随机数 int n = r.nextInt(10); System.out.println(&quot;n:&quot;+n); for (int i = 0; i &lt;10 ; i++) &amp;#123; int num = r.nextInt(10); System.out.println(&quot;第&quot;+i+&quot;次随机数结果为：&quot;+num); &amp;#125; // 如何获取100 - 1之间的随机数 int ii = r.nextInt(100);// [0,99] int T = r.nextInt(100)+1;// +1 即可 &amp;#125; &amp;#125; 猜数字游戏 package com.data.it; import java.util.Random; import java.util.Scanner; /** * Created by JackFeng on 2020/3/1. */ /* * 猜数字游戏： * 系统产生一个 1-100 的数字，猜出这个数字是多少 * * 分析： * A：系统产生一个1-100之间的随机数 * Random r = new Random(); * int number = r.nextInt(100)+1; * B: 键盘录入要猜的数据 * C: 比较这两个数据的大小 * 大了：提示大了 * 小了：提示小了 * 相等：猜中了 * D：多次猜数据，而我们不知道猜多少次？ * while(true)&amp;#123;循环体语句&amp;#125;; * * * */ public class RandomNumDemo &amp;#123; public static void main(String[] args) &amp;#123; // 产生1-100随机数 Random r = new Random(); // 获取随机数 int i = r.nextInt(100)+1; // 判断是否猜中 多次猜数据 // 录入的数据 要放在判断里 否则永远也猜不中 while (true) &amp;#123; // 键盘录入 Scanner s = new Scanner(System.in); // 获取输入数据 System.out.println(&quot;请输入你要猜的数据：&quot;); int g = s.nextInt(); if (g&gt;i)&amp;#123; System.out.println(&quot;你猜的&quot;+g+&quot;大了&quot;); &amp;#125;else if (g&lt;i)&amp;#123; System.out.println(&quot;你猜的&quot;+g+&quot;小了&quot;); &amp;#125;else &amp;#123; System.out.println(&quot;恭喜你猜中了&quot;); break; &amp;#125; &amp;#125; &amp;#125; &amp;#125; 1.4、数组 数组：存储同一种数据类型的多个元素的容器 取值： 数组名 【索引】 定义格式： A：数据类型[] 数组名；(推荐方式) B：数据类型 数组名[]; 案例： int[] arr; 定义int类型的数组，名称为 arr int arr[]；定义int类型的变量，变量名为arr数组 数组初始化： A：数组开辟内存空间，为数组中的每个元素赋值 B：数组初始的方式： a：动态初始化 只给出长度，系统给初始化值 b：静态初始化 给出初始值，由系统决定长度 动态初始化： 数据类型[] 数组名 = new 数据类型[数组长度]; 静态初始化： 数据类型[] 数组名 = new 数据类型[]{元素1,元素2….}; 简化格式： 数据类型[] 数组名 ={元素1，元素2,…} 动态初始化 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class MyArrayDemo &amp;#123; public static void main(String[] args) &amp;#123; //数据类型[] 数组名 = new 数据类型[数组长度]; int[] arr = new int[3]; // 释义 /* * 左边： * int：说明数组中的元素类型是 int 类型 * []: 说明是个数组 * arr： 数组名称 * * 右边： * new ： 为数组申请内存分配空间 * int： 数组中的元素是int类型 * []： 数组 * 3： 数组的长度----数组中元素的个数 * */ //输出数组名 System.out.println(&quot;arr&quot;+arr); //[I@4554617c // 获取的是地址值，如何获取数组中的元素值 // 数组中的元素都是有编号的，从0 开始，最大编号是 数组的长度-1 // 索引 arr[0] // 取值： 数组名 配合 元素编号 // 访问格式：数组名[索引] System.out.println(arr[0]); //0 System.out.println(arr[1]); // 0 System.out.println(arr[2]); //0 // 赋值 arr[0] = 100; arr[2] = 200; System.out.println(&quot;=====&quot;); System.out.println(arr); // 001 System.out.println(arr[0]); //100 System.out.println(arr[1]); // 0 System.out.println(arr[2]); //200 // 指向一个数组 // arr1 数组 int[] arr1 = new int[3]; System.out.println(arr1); System.out.println(arr1[0]); System.out.println(arr1[1]); System.out.println(arr1[2]); int[] arr2 = arr1; arr1[0] =111; arr1[1] =222; arr1[2] =123; System.out.println(&quot;=============&quot;); System.out.println(arr1); System.out.println(arr1[0]); System.out.println(arr1[1]); System.out.println(arr1[2]); System.out.println(arr2); System.out.println(arr2[0]); System.out.println(arr2[1]); System.out.println(arr2[2]); &amp;#125; &amp;#125; 静态初始化 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class ArraryDemo &amp;#123; public static void main(String[] args) &amp;#123; int[] arr = new int[]&amp;#123;1,2,3&amp;#125;; int[] arr1 = &amp;#123;1, 2, 3&amp;#125;; System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); // System.out.println(&quot;----------&quot;); System.out.println(arr1); System.out.println(arr1[0]); System.out.println(arr1[1]); System.out.println(arr1[2]); &amp;#125; &amp;#125; 常见小问题 小问题： ArrayIndexOutOfBoundsException: 数组索引越界异常 原因 我们访问了不存在的索引 NullPointerException：空指针异常 原因 数组已经不在指向堆内存的数据了，还使用数组名去访问数组中的数据 数组遍历练习 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class ArrayTest &amp;#123; public static void main(String[] args) &amp;#123; // 定义数组 int[] arr = &amp;#123;1, 2, 3, 4, 5, 6&amp;#125;; // 通过for循环遍历输出 ,调用 数组属性:length // 格式： 数组名.length for (int i = 0; i &lt;arr.length ; i++) &amp;#123; System.out.println(arr[i]); &amp;#125; &amp;#125; &amp;#125; 取最值 思路： A：先拿数组中的一个元素做参照物 B：遍历数组，让后边所有元素依次和参照物进行比较，如果元素比参照物大，就留下 C：整个循环遍历比较，留下的就是最大值 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class ArrayTest1 &amp;#123; public static void main(String[] args) &amp;#123; // 取最大值 int[] arr = &amp;#123;1, 2, 3, 55, 22, 10&amp;#125;; // 定义一个参照值 int max = arr[0]; // 循环遍历整个数组 for (int i = 1; i &lt;arr.length ; i++) &amp;#123; if (arr[i]&gt;max)&amp;#123; max = arr[i]; &amp;#125; &amp;#125; System.out.println(&quot;最大值为：&quot;+max); &amp;#125; &amp;#125; 二维数组 二维数组： 元素为一堆数组的数组 定义格式： - A：数据类型[ ] [ ] 数组名; (推荐的方式) - B：数据类型 数组名[ ] [ ] - C：数据类型[ ] 数组名[ ] 初始化： - A： 动态初始化 - 数据类型[ ] [ ] 数组名 = new 数据类型[m] [n]; - m 表示的是 二维数组中一维数组的个数 - n 表示的是 一维数组中的元素个数 - B： 静态初始化 - 数据类型[ ] [ ] 数组名 = new 数据类型[ ] [ ] &amp;#123;&amp;#123;元素…&amp;#125;,&amp;#123;元素….&amp;#125;&amp;#125; - 简化格式： - 数据类型[ ] [ ] 数组名 = &amp;#123;&amp;#123;1,…&amp;#125;,&amp;#123;2….&amp;#125;,&amp;#123;3….&amp;#125;&amp;#125; 取值： - *二维数组名配合索引可以获取到每一个一维数组* 【**arr[索引]**】 - *一维数组配合索引名可以获取到数组中的元素*【**arr[索引] [索引]**】 二维数组取值 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class Array2Test &amp;#123; public static void main(String[] args) &amp;#123; //数据类型[] [] 数组名 = &amp;#123;&amp;#123;元素..&amp;#125;,&amp;#123;元素...&amp;#125;&amp;#125; int[][] arr = &amp;#123;&amp;#123;1, 2, 3&amp;#125;, &amp;#123;1, 3, 6&amp;#125;, &amp;#123;2, 3, 6&amp;#125;&amp;#125;; // // System.out.println(arr); // System.out.println(arr[0]); // System.out.println(arr[0][0]); // 遍历二维数组 // 第一个数组的元素 for (int i = 0; i &lt;arr[0].length ; i++) &amp;#123; System.out.println(arr[0][i]); &amp;#125; System.out.println(&quot;==========&quot;); // 第二个数组的元素 for (int i = 0; i &lt;arr[2].length ; i++) &amp;#123; System.out.println(arr[0][i]); &amp;#125; // 优化循环二维数组 System.out.println(&quot; -----------&quot;); // 二维数组 arr.length 就是有几个 一维数组 for (int i = 0; i &lt; arr.length ; i++) &amp;#123; for (int j = 0; j &lt;arr[i].length ; j++) &amp;#123; System.out.print(arr[i][j] + &quot; &quot;); &amp;#125; System.out.println(&quot;====&quot;); &amp;#125; &amp;#125; &amp;#125; 1.5、函数方法使用 方法： 特定功能的代码块 方法定义格式： 修饰符 返回值类型 方法名(参数类型 参数名1，参数类型 参数名2 ..){ ​ 方法体; ​ return 返回值; } 格式解释： A：修饰符 public static B：返回值类型 限定返回值的数据类型 C：方法名 方便我们调用方法的名字 D：参数类型 用于限定调用方法时传入数据的类型 E：参数名 用于接收调用方法时传入的数据变量 F： 方法体 完成功能代码 G：return 结束方法，并且把返回值带给调用者 方法明确： A：返回值类型 明确功能结果的数据类型 B：参数列表 明确有几个参数，以及参数的数据类型 方法调用：（有明确返回值的调用） A：单独调用 没有意义 B：输出调用，有意义，但是不够好(因为我想要拿结果进一步操作) C：赋值调用 方法调用：(void修饰的方法) 如果一个方法没有明确的返回值，也不能空开返回值，用void表示该方法无返回值类型 只能输出调用。 求和方法 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class SumTest &amp;#123; public static void main(String[] args) &amp;#123; //调用sum // 单独调用 无意义 // sum(10, 20); // 输出调用，有意义，不完美 // System.out.println(sum(10,20)); // 赋值调用，常用操作。 int i = sum(10, 20); System.out.println(i); System.out.println(i+1); // 对i 进行操作 int j = sum(10,20)+10; System.out.println(j); &amp;#125; /* * 两个明确： * 返回值： int * 参数列表： int a , int b * * * */ public static int sum(int a , int b )&amp;#123; int c = a + b; return c; &amp;#125; &amp;#125; 键盘录入两个数据判断是否相等 package com.data.it; import java.util.Scanner; /** * Created by JackFeng on 2020/3/1. */ public class MethodTest &amp;#123; public static void main(String[] args) &amp;#123; // 创建键盘录入 Scanner sc = new Scanner(System.in); // 接收数据 System.out.println(&quot;请输入第一个数据：&quot;); int x = sc.nextInt(); System.out.println(&quot;请输入第二个数据：&quot;); int y = sc.nextInt(); // 调用方法 boolean b = bijiao(x, y); System.out.println(b); &amp;#125; /* * 求两个值是否相等： * 返回值： boolean * 参数列表： int a,int b * * */ public static boolean bijiao(int a , int b )&amp;#123; if (a==b)&amp;#123; return true; &amp;#125;else &amp;#123; return false; &amp;#125; &amp;#125; &amp;#125; 水仙花数 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class MethodTest1 &amp;#123; public static void main(String[] args) &amp;#123; //调用方法 printFlower(); &amp;#125; /* * 水仙花数打印到控制台方法 * * 两个参数： * 返回值类型：void * 参数列表： 无参数 * * */ public static void printFlower()&amp;#123; for (int i = 100; i &lt;1000 ; i++) &amp;#123; int g = i%10; int s = i/10%10; int b = i/10/10%10; if (g*g*g + s*s*s + b*b*b == i)&amp;#123; System.out.println(i); &amp;#125; &amp;#125; &amp;#125; &amp;#125; 方法重载 方法重载： 在同一个类中，出现了方法名相同 不能出现参数名以及参数条件一致的方法 特点： 方法名相同，参数不同 参数不同 参数数量不同 参数个数不同 注意：在调用方法的时候，java虚拟机会通过参数列表的不同来区分同名的方法。 比较两个数据是否相等 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class MethodTest2 &amp;#123; public static void main(String[] args) &amp;#123; System.out.println(compare(10,10)); System.out.println(compare(10L,10L)); System.out.println(compare((byte) 10,(byte)20)); System.out.println(compare((short) 10,(short) 20)); &amp;#125; //byte public static boolean compare(byte a , byte b)&amp;#123; System.out.println(&quot;byte&quot;); return a == b; &amp;#125; //short public static boolean compare(short a , short b)&amp;#123; System.out.println(&quot;short&quot;); return a == b; &amp;#125; //int public static boolean compare(int a , int b)&amp;#123; System.out.println(&quot;int&quot;); return a == b; &amp;#125; //long public static boolean compare(long a , long b)&amp;#123; System.out.println(&quot;long&quot;); return a == b; &amp;#125; &amp;#125; 形式参数 如果方法的参数是基本数据类型： ​ 形式参数的改变不影响实际参数 如果方法的参数是引用数据类型： ​ 形式参数的改变直接影响实际参数 数组遍历 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class ArrayDo &amp;#123; public static void main(String[] args) &amp;#123; int[] arr = &amp;#123;1, 2, 3, 4, 5&amp;#125;; System.out.println(&quot;第一种方式&quot;); printArray(arr); System.out.println(&quot;第二种方式&quot;); printArray1(arr); &amp;#125; /* * 两个明确： * 返回类型： void * 参数列表： int[] arr * */ public static void printArray(int[] arr)&amp;#123; for (int i = 0; i &lt;arr.length ; i++) &amp;#123; System.out.println(arr[i]); &amp;#125; &amp;#125; public static void printArray1(int[] arr)&amp;#123; // 输出为这样的 [1,2,3,4,5] System.out.print(&quot;[&quot;); for (int i = 0; i &lt;arr.length ; i++) &amp;#123; if (i==arr.length-1)&amp;#123; System.out.println(arr[i]+&quot;]&quot;); &amp;#125;else &amp;#123; System.out.print(arr[i]+&quot;, &quot;); &amp;#125; &amp;#125; &amp;#125; &amp;#125; 1.6、断点调试 断点调试的作用： ​ A： 查看程序的执行流程 ​ B： 调试程序 断点： ​ – 标记 哪里需要点哪里 需加在有效的地方 1.7、基础练习不死神兔计算 package myTest; /** * Created by JackFeng on 2020/3/1. */ public class Test &amp;#123; public static void main(String[] args) &amp;#123; // 20个月 兔子的对数 // 1,1,2,3,5.... // 定义数组 int[] arr = new int[20]; // 给数组赋值 arr[0] = 1; arr[1] = 1; // 找规律赋值 for (int i = 2; i &lt;arr.length ; i++) &amp;#123; arr[i] = arr[i - 1] + arr[i - 2]; &amp;#125; //输出结果 System.out.println(&quot;第20个月兔子的对数是：&quot;+arr[19]); &amp;#125; &amp;#125; 评委评分 需求： ​ 在编程竞赛中，有6个评委为参赛选手打分，分数为0-100的整数分。 ​ 选手最后的得分为，去掉一个最高分与最低分，剩下4个评委的平均值 分析： A：定义一个长度为6的数组 B：键盘录入评委的分数 C：写方法实现最高分、最低分 D：写方法求评委分数和 E：平均分：（和-最高分-最低分）/（arr.length-2） F：输出平均分 package myTest; import java.util.Scanner; /** * Created by JackFeng on 2020/3/2. */ public class Test1 &amp;#123; public static void main(String[] args) &amp;#123; //定义数组 int[] arr = new int[6]; //键盘录入 Scanner sc = new Scanner(System.in); //键盘录入评委分数 for (int i = 0; i &lt;arr.length ; i++) &amp;#123; //接受数据 System.out.println(&quot;请输入第 &quot;+(i+1)+&quot;个评委给出的分数&quot;); int score = sc.nextInt(); arr[i] = score; &amp;#125; //调用方法 int max = getMax(arr); int min = getMin(arr); int sum = sum(arr); // 求平均分 int avg = (sum - max - min) / (arr.length - 2); System.out.println(&quot;该选手的最终得分是：&quot;+avg); &amp;#125; //最高分 /* * 两个明确： * 返回值类型： int * 参数列表： int [] arr * * * */ public static int getMax(int[] arr)&amp;#123; //定义参照物 int max = arr[0]; for (int i = 1; i &lt;arr.length ; i++) &amp;#123; if (arr[i]&gt;max)&amp;#123; max = arr[i]; &amp;#125; &amp;#125; return max; &amp;#125; // 最低分 public static int getMin(int[] arr)&amp;#123; //定义参照物 int min = arr[0]; for (int i = 1; i &lt;arr.length ; i++) &amp;#123; if (arr[i]&lt;min)&amp;#123; min = arr[i]; &amp;#125; &amp;#125; return min; &amp;#125; // 求和 public static int sum(int[] arr)&amp;#123; // 定义求和变量 int sum = 0; for (int i = 0; i &lt;arr.length ; i++) &amp;#123; sum += arr[i]; &amp;#125; return sum; &amp;#125; &amp;#125; 键入数组反转 需求： 1、键盘录入5个int的数据存在arr中 2、定义方法将arr数组中的内容反转 3、定义方法对反转后的数组进行遍历 package myTest; import java.util.Scanner; /** * Created by JackFeng on 2020/3/2. */ public class Test2 &amp;#123; public static void main(String[] args) &amp;#123; int[] arr = new int[5]; Scanner sc = new Scanner(System.in); for (int i = 0; i &lt;arr.length ; i++) &amp;#123; System.out.println(&quot;请输入&quot;+(i+1)+&quot;个元素值：&quot;); int number = sc.nextInt(); arr[i] = number; &amp;#125; printArray(arr); // 反转 arr reverse(arr); System.out.println(&quot;反转后&quot;); printArray(arr); &amp;#125; //遍历数组 public static void printArray(int[] arr)&amp;#123; System.out.print(&quot;[&quot;); for (int i = 0; i &lt;arr.length ; i++) &amp;#123; if (i==arr.length-1)&amp;#123; System.out.println(arr[i]+&quot;]&quot;); &amp;#125;else&amp;#123; System.out.print(arr[i]+&quot;, &quot;); &amp;#125; &amp;#125; &amp;#125; // 反转数组 public static void reverse(int[] arr)&amp;#123; for(int start =0, end= arr.length-1; start&lt;=end;start++,end--)&amp;#123; int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; &amp;#125; &amp;#125; &amp;#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"},{"name":"JavaSE","slug":"Java/JavaSE","permalink":"http://www.a2data.cn/categories/Java/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"http://www.a2data.cn/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"基础语法入门","slug":"基础语法入门","permalink":"http://www.a2data.cn/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/"}]},{"title":"Java环境","slug":"Java/JavaSE/Java环境","date":"2020-05-07T15:53:40.000Z","updated":"2020-08-07T10:25:29.635Z","comments":true,"path":"posts/17415.html","link":"","permalink":"http://www.a2data.cn/posts/17415.html","excerpt":"Java JDK 环境安装","text":"Java JDK 环境安装 Java环境 程序编译和运行需要使用 javaJDK 下的bin目录 环境变量配置： JAVA_HOME —— jdk安装目录 Path环境 —— %JAVA_HOME%\\bin JVM: JAVA虚拟机 JRE: JAVA运行环境 JDK: 开发环境 JDK包含JER包含JVM 1、Win10环境 Win10下 Java环境变量配置 首先，你应该已经安装了 Java 的 JDK 了！！！ 如果没有安装JDK，请跳转到此网址：http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html） 笔者安装的是 jdk-1.8.0_151-windows-x64 接下来主要讲怎么配置 Java 的环境变量，也是为了以后哪天自己忘记了做个备份！！ 注：win10的环境变量配置和其他的windows版本稍有不同 2、环境变量在电脑桌面 右键点击 “此电脑”的“属性”选项 选择“高级系统设置”选项 点击下面的“环境变量”选项 接下来就是具体的配置过程： 点击“系统变量”下面的”新建“选项 在”变量名“处填上”Java_Home“ 变量值“为JDK安装路径，路径自定义: D:\\Program Files\\Java\\jdk1.8.0_151 点击”确定“选项 在”系统变量“中找到”Path“ 选中”Path“点击”编辑“选项 3、添加变量 选择右边的“新建”，将引号里面的分别复制添加“%Java_Home%\\bin;%Java_Home%\\jre\\bin;” 点击“环境变量”最下面的“确定”选项 回到电脑桌面，按快捷键“Win+R”，输入“cmd” 检查Java环境是否配置成功 输入 java -verison 4、环境配置成功 如上图所示，恭喜你，环境变量就配置好了。 为了敏捷开发，小编建议 安装IDEA，并且2020版本支持中文。 有了好的环境，才能更好的学习。小编也会补充上基础得学习教程。 一起加油吧 ！！！","categories":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"},{"name":"JavaSE","slug":"Java/JavaSE","permalink":"http://www.a2data.cn/categories/Java/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"},{"name":"JDK环境","slug":"JDK环境","permalink":"http://www.a2data.cn/tags/JDK%E7%8E%AF%E5%A2%83/"}]},{"title":"最快图床搭建","slug":"Tools/最快图床搭建","date":"2020-05-05T17:09:54.000Z","updated":"2020-08-07T10:29:16.583Z","comments":true,"path":"posts/36204.html","link":"","permalink":"http://www.a2data.cn/posts/36204.html","excerpt":"最快的图床搭建，有坑请联系小编。","text":"最快的图床搭建，有坑请联系小编。 PicGo1、安装PicGoGitHub地址 https://github.com/Molunerfinn/PicGo/releases 访问 PicGo选择 PicGo-Setup-XXX.exe下载软件安装包（GitHub直接下载速度会有些慢甚至无法完成下载，可选择使用迅雷下载，亲测有用） 或者联系小编，小编有 微云+ 百度云高效连接。 2、安装选项 安装软件时选择仅为我安装，另外注意不要安装在C盘 安装node.js：点击 nodejs 下载完安装包后进行安装，除了更改安装位置外，一路默认完成安装即可 更换镜像源：进入命令行执行以下命令 npm config set registry https://registry.npm.taobao.org 3、安装完成 Gitee1、打开PicGo运行软件打开插件设置搜索gitHub，安装github-plus插件 2、创建Gitee图床仓库 https://gitee.com/sqlsq_admin/cdn.git 创建仓库时务必要勾选一个初始化选项初始化仓库，否则后面上传时会失败 3、创建私人令牌私人令牌：https://gitee.com/profile/personal_access_tokens/new 生成成功如下： 4、 设置GithubPlus返回PicGO，点击图床设置-&gt; githubPlus ，填写repo，token和origin三项，token填写为上一步生成的token，origin选择gitee，repo填写为sqlsq_admin/cdn Typora 熟悉的都知道，这个记事本我推荐了好多次了。 并且也自己魔改了一些css样式。目前小编最钟爱的编辑器。 完成以上操作即可正常使用你的PicGo了，如果你还经常使用typora的话可以继续设置你的typora 1、配置图片 2、上传配置 建议开启 优先使用相对路径。 这样可以预览！ 3、体验极速上传吧 推荐图床： 别问小编为什么，因为我穷付费的都用不起。 Github 免费 有时候容易失败 GithubPlus — Gitee 免费 高效 快捷 上传 上传成功 4、完美 至于图床的更多便捷就不一 一诉说了。","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"},{"name":"图床","slug":"图床","permalink":"http://www.a2data.cn/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Typora","slug":"Typora","permalink":"http://www.a2data.cn/tags/Typora/"},{"name":"Gitee","slug":"Gitee","permalink":"http://www.a2data.cn/tags/Gitee/"}]},{"title":"Redis","slug":"DataBase/Redis/Redis","date":"2020-05-05T16:47:18.000Z","updated":"2020-08-07T09:45:17.471Z","comments":true,"path":"posts/bae4ff13.html","link":"","permalink":"http://www.a2data.cn/posts/bae4ff13.html","excerpt":"详细说明Redis的安装。","text":"详细说明Redis的安装。 Redis安装 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 1、下载 windows版本： https://github.com/MSOpenTech/redis/releases Linux版本： 官网下载： http://www.redis.cn/ git下载 https://github.com/antirez/redis/releases 我们现在讨论的是windows下的安装部署，目前windows下最新版本是：3.2.100。 下载地址，提供多种下载内容，Redis-x64-3.2.100.msi是在windows下，最简单的安装文件，方便，直接会将Redis写入windows服务。Redis-x64-3.2.100.zip是需要解压安装的，接下来讨论的是这种。Source code (zip) 源码的zip压缩版Source code (tar.gz) 源码的tar.gz压缩版 2、安装以 Redis-x64-3.2.100.msi 为例，下载之后运行 3、启动 通过cmd指定到该redis目录。使用命令：redis-server.exe 启动服务 或者到对应目录启动即可。 4、使用 参考安装完之后的生成文档 如果您使用MSI包安装了Redis，那么Redis已经作为Windows服务安装了。没有别的事可做。如果您想要更改它的设置，您可以更新Redis .windows-service.conf文件，然后重新启动Redis服务(运行-&gt;服务。msc -&gt; Redis -&gt;重启)。 在安装MSI期间，您可以使用安装程序的用户界面来更新Redis监听的端口和防火墙异常，或者在没有UI的情况下静默运行它。下面的例子展示了如何从命令行安装: default install (port 6379 and firewall exception ON): msiexec /i Redis-Windows-x64.msi set port and turn OFF firewall exception: msiexec /i Redis-Windows-x64.msi PORT=1234 ADD_FIREWALL_RULE=&quot;&quot; set port and turn ON firewall exception: msiexec /i Redis-Windows-x64.msi PORT=1234 ADD_FIREWALL_RULE =1 install with no user interface: msiexec /quiet /i Redis-Windows-x64.msi 如果您没有使用MSI包安装Redis，那么您仍然可以按照以下说明运行Redis作为Windows服务: 为了更好地与Windows服务模型集成，在Redis中引入了新的命令行参数。这些服务参数需要一个提升的用户上下文，以便连接到服务控制管理器。如果这些命令是从非提升的上下文调用的，那么Redis将尝试创建一个提升的上下文来执行这些命令。这将导致一个用户帐户控制对话框显示在窗口，并可能需要Admini #安装服务 这必须是redis-server命令行的第一个参数。参数按服务启动时发生在Redis中的顺序传递。该服务将被配置为自动启动，并将作为“NT AUTHORITY\\NetworkService”启动。安装成功后，将显示一条成功消息，Redis将退出。 此命令不启动服务。 #例如： redis-server --service-install redis.windows-service.conf --loglevel verbose #卸载服务 --service-uninstall 这将从注册表中删除Redis服务配置信息。卸载成功后，将显示一条成功消息，Redis将退出。 这并不命令不停止服务。 #例如 redis-server --service-uninstall Starting the Service --service-start 这将启动Redis服务。成功启动后，将显示一条成功消息并开始运行Redis。 #例如 redis-server --service-start Stopping the Service --service-stop 这将停止Redis服务。成功终止后，将显示一条成功消息，Redis将退出。 #例如 redis-server --service-stop #命令服务 --service-name name 此可选参数可与前面的任何命令一起使用，以设置安装的服务的名称。该参数应该位于service-install、service-start、service-stop或service-uninstall命令之后，并位于通过service-install命令传递给Redis的任何参数之前。 下面将安装并启动三个独立的Redis服务实例: redis-server --service-install --service-name redisService1 --port 10001 redis-server --service-start --service-name redisService1 redis-server --service-install --service-name redisService2 --port 10002 redis-server --service-start --service-name redisService2 redis-server --service-install --service-name redisService3 --port 10003 redis-server --service-start --service-name redisService3 # 测试 启动服务 redis-server --service-start 客户端 命令： 精简模式： redis-cli.exe 指定模式： redis-cli.exe -h 127.0.0.1 -p 6379 -a requirepass (-h 服务器地址 -p 指定端口号 -a 连接数据库的密码[可以在redis.windows.conf中配置]，默认无密码) 5、Redis工具 Redis Desktop Manager https://redisdesktop.com/pricing 注意：Redis支持多个数据库，并且每个数据库的数据是隔离的不能共享，并且基于单机才有，如果是集群就没有数据库的概念。 Redis是一个字典结构的存储服务器，而实际上一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。 每个数据库对外都是一个从0开始的递增数字命名，Redis默认支持16个数据库（可以通过配置文件支持更多，无上限），可以通过配置databases来修改这一数字。客户端与Redis建立连接后会自动选择0号数据库，不过可以随时使用SELECT命令更换数据库。","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.a2data.cn/categories/DataBase/"},{"name":"Mysql","slug":"DataBase/Mysql","permalink":"http://www.a2data.cn/categories/DataBase/Mysql/"},{"name":"数据库","slug":"数据库","permalink":"http://www.a2data.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.a2data.cn/tags/Mysql/"}]},{"title":"DBeaver安装","slug":"DataBase/Mysql/DBeaver安装","date":"2020-05-05T16:46:01.000Z","updated":"2020-08-07T09:44:26.825Z","comments":true,"path":"posts/773d5f8c.html","link":"","permalink":"http://www.a2data.cn/posts/773d5f8c.html","excerpt":"DBeaver安装步骤","text":"DBeaver安装步骤 DBeaver1、下载 官方链接：https://dbeaver.io/ 2、安装 双击打开应用程序。只需要更改存储位置即可。 3、新建 4、下载驱动文件 5、 链接数据库 6、测试链接 7、更改主题 根据自己爱好设定。 8、查询数据","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.a2data.cn/categories/DataBase/"},{"name":"Mysql","slug":"DataBase/Mysql","permalink":"http://www.a2data.cn/categories/DataBase/Mysql/"},{"name":"数据库","slug":"数据库","permalink":"http://www.a2data.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据库工具","slug":"数据库工具","permalink":"http://www.a2data.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.a2data.cn/tags/Mysql/"}]},{"title":"大数据集群","slug":"Hadoop/大数据集群","date":"2020-05-05T16:41:07.000Z","updated":"2020-08-07T09:56:46.087Z","comments":true,"path":"posts/9e565f9f.html","link":"","permalink":"http://www.a2data.cn/posts/9e565f9f.html","excerpt":"快速搭建Hadoop集群","text":"快速搭建Hadoop集群 VM安装0、下载 VMware Workstation Pro 确立了在单台 Linux 或 Windows PC 上运行多个操作系统的行业标准。 Workstation 15.5 Pro 通过提供全新的用户界面控件，支持巨型帧以及最新的 Windows 和 Linux 操作系统等，进一步完善了领先的桌面… 链接直达： https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html 1、以管理员身份运行找到下载的程序，右击 2、下一步 3、接收协议 4、更改安装目录 5、安装 点击下一步，点击安装 6、完成 许可证激活密钥 UY758-0RXEQ-M81WP-8ZM7Z-Y3HDA VM使用0、启动 1、更改存储位置 2、更改共享位置 3、虚拟网络 虚拟机网络相关配置 详细设置 cloudera cloudera-quickstart-vm-5.13.0-0-vmware （目前已经不可下载） https://www.cloudera.com/products/open-source/apache-hadoop/key-cdh-components.html VM快速学习 目前最高版本是 5.16 https://docs.cloudera.com/documentation/enterprise/5-16-x/topics/cloudera_quickstart_vm.html 1、导入虚拟机 2、编辑虚拟机设置 最低配置： **4G，4G ，4G **—- 4G 1cores 64GB 小编配置： 8G 2cores 64GB 3、开启虚拟机 4、成功启动 等候片刻，根据机器配置来讲，成功创建。如下图 5、更改IPcentos ip更改 默认值： DEVICE=&quot;eth0&quot; BOOTPROTO=&quot;dhcp&quot; DHCP_HOSTNAME=&quot;quickstart.cloudera&quot; HOSTNAME=&quot;quickstart.cloudera&quot; HWADDR=&quot;00:0C:29:D3:4D:5C&quot; IPV6INIT=&quot;no&quot; MTU=&quot;1500&quot; NM_CONTROLLED=&quot;yes&quot; ONBOOT=&quot;yes&quot; TYPE=&quot;Ethernet&quot; UUID=&quot;f127faf3-7a1f-4bca-a404-0119665a8459&quot; 注意：使用sudo sudo vim /etc/sysconfig/network-scripts/ifcfg-eth0 修改为: DEVICE=&quot;eth0&quot; BOOTPROTO=&quot;static&quot; DHCP_HOSTNAME=&quot;quickstart.cloudera&quot; HOSTNAME=&quot;quickstart.cloudera&quot; HWADDR=&quot;00:0C:29:D3:4D:5C&quot; IPV6INIT=&quot;no&quot; MTU=&quot;1500&quot; NM_CONTROLLED=&quot;yes&quot; ONBOOT=&quot;yes&quot; TYPE=&quot;Ethernet&quot; UUID=&quot;f127faf3-7a1f-4bca-a404-0119665a8459&quot; IPADDR=192.168.6.6 NETMASK=255.255.255.0 重新启动即可: sudo service network restart 6、启动异常解决方案异常解决 重新添加网卡 复制MAC地址： 更改： DEVICE = eth2 HWADDR —- 为你的地址值 再次重新启动 1.重启服务 sudo service network restart 2.查看ip ip addr/ifconfig MobaXterm1、安装MobaXterm https://mobaxterm.mobatek.net/download-home-edition.html 2、启动 3、配置 4、登录 输入密码，保存。 5、查看 相关安装包，请联系小编获取。 欢迎访问 小编博客 ： www.a2data.cn全力打造 SQL社区： www.sqlsq.cn","categories":[],"tags":[{"name":"VMware","slug":"VMware","permalink":"http://www.a2data.cn/tags/VMware/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://www.a2data.cn/tags/Hadoop/"},{"name":"Cloudera","slug":"Cloudera","permalink":"http://www.a2data.cn/tags/Cloudera/"},{"name":"MobaXterm","slug":"MobaXterm","permalink":"http://www.a2data.cn/tags/MobaXterm/"}]},{"title":"Linux 正则表达式","slug":"Linux/Linux-正则表达式","date":"2020-04-25T11:14:43.000Z","updated":"2020-08-07T10:04:06.257Z","comments":true,"path":"posts/47985.html","link":"","permalink":"http://www.a2data.cn/posts/47985.html","excerpt":"正则表达式相关","text":"正则表达式相关 正则表达式 是指用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。就是用某种模式去匹配一类字符串的一个公式。 touch bb.txt grep “m*” bb.txt 基本元字符集grep -E = egrep · 匹配任意单个字符。 如：rat、r、t。 ^ 匹配一行的开始 $ 匹配一行的结尾 匹配0个或多个前面的字符 + 匹配1个或者多个+前面的字符（需要\\号，如grep -E “11+” /root/2） ? 匹配0个或1个？之前的字符 \\ 转义 []匹配括号中的任何一个字符。如：[abc] [^] 匹配不在括号中的，表示排除 如[^abc]或者 grep -v [abc] &lt; 匹配词的开始 &gt; 匹配词的结束。 如 &lt;the&gt;\\。 | 或。 例如 （him|her） {m} 前面的表达式重复m次。如：“\\w{2}”相当于“\\w\\w”。 {m,n} 表达式至少重复m次，做多重复n次。如：“ba{1,3}”匹配“ba”或“baa”“baaa” “d{2,3}” {m，} 表达式至少重复m次 \\w 任意一个字母或数字或下划线 \\d 任意一个数字 grep [0-9] bb.txt \\s 空格、制表符、换页符、空白符中的任意的一个。 \\b 匹配一个单词的边界。如：“.\\b.” 以什么开头放后边 以什么结尾放前边 环境支持 命令或环境 · [] ^ $ ( ) { } ? + | ( ) vi × × × × × awk × × × × × × × × sed × × × × × × grep × × × × × × egrep × × × × × × × × × perl × × × × × × × × ×","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://www.a2data.cn/tags/Shell/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://www.a2data.cn/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}]},{"title":"Linux Shell语法","slug":"Linux/Linux-Shell语法","date":"2020-04-25T11:14:22.000Z","updated":"2020-08-07T10:26:30.422Z","comments":true,"path":"posts/64423.html","link":"","permalink":"http://www.a2data.cn/posts/64423.html","excerpt":"Linux Shell 语言得一些基本语法。","text":"Linux Shell 语言得一些基本语法。 Shell语法If语句格式 (number=num) read -p &quot;请输入一个数字&quot; num if [ $num -eq 3 ] （如果） then echo &quot;wo xiang ni&quot; elif [ $num -le 5 ] then （然后） echo &quot;zhen xiang le &quot; else [ $num -ge 6 ] （否则） echo &quot;miss 531&quot; fi （结束） 闰年第一版 year=`date +%Y` if [ $[ $year % 400 ] -eq 0 ] then echo &quot;$year is a leap year.&quot; elif [ $[ $year % 4 ] -eq 0 ] then if [ $[ $year % 100 ] -ne 0 ] then echo &quot;$year is a leap year.&quot; else echo &quot;$year is not a leap year.&quot; fi else echo &quot;$year is not a leap year.&quot; fi 第二版（原版） year=$(date +%Y) if [ $[ $year % 400 ] -eq 0 ] then echo &quot;$year is a leap year.&quot; elif [ $[ $year % 4 ] -eq 0 ] then if [ $[ $year % 100 ] -ne 0 ] then echo &quot;$year is a leap year.&quot; else echo &quot;$year is not a leap year.&quot; fi else echo &quot;$year is not a leap year.&quot; fi 第三版（查询哪一年是闰年） read -p &quot;shu ru nian fen&quot; year if [ $[ $year % 400 ] -eq 0 ] then echo &quot;$year is a leap year.&quot; elif [ $[ $year % 4 ] -eq 0 ] then if [ $[ $year % 100 ] -ne 0 ] then echo &quot;$year is a leap year.&quot; else echo &quot;$year is not a leap year.&quot; fi else echo &quot;$year is not a leap year.&quot; fi FOR 循环 格式语法：for NAME in [ LIST ];do COMMANDS; done ​ 列表 执行命令 结束 LIST用法 直接写 1 2 3 大括号 {1..5} 文件名 /etc/*.conf 命令结果 find /etc/ -name “*.conf” C语言风格 for ((i=0;i&lt;5 i=i+2)) i++ ping网段案例ping.sh for p in &amp;#123;1..10&amp;#125; p---变量名称 do do----执行内容 host=(192.168.18.$p) ping -c2 192.168.18.$p &gt;&gt; /root/Desktop/2.txt c2---频率 if [ $? == 0 ] then echo &quot;$host is online.&quot; 在线 else echo &quot;$host is offline.&quot; 不在线 fi done while循环aa=1 while [ $aa -le 10 ] do echo &quot;wo xiang ni le&quot; aa=$[$aa+1] done case 判断aa=3 ( 3 变量值） case &quot;$aa&quot; in 1) echo &quot;haha&quot;;; （1,2,4常量值） 2) echo &quot;heihei&quot;;; 3) echo &quot;nimei&quot;;; （有内容两；没有一个；） esac break 终止当前for循环 for n in &amp;#123;1..10&amp;#125; do if [ $n -eq 3 ] then break fi echo $n done continue 跳出本次循环 for n in &amp;#123;1..10&amp;#125; do if [ $n -eq 3 ] then continue fi echo $n done","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://www.a2data.cn/tags/Shell/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://www.a2data.cn/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}]},{"title":"Linux Shell脚本","slug":"Linux/Linux-Shell脚本","date":"2020-04-25T11:14:07.000Z","updated":"2020-08-07T10:26:27.431Z","comments":true,"path":"posts/43857.html","link":"","permalink":"http://www.a2data.cn/posts/43857.html","excerpt":"Linux Shell脚本相关学习。","text":"Linux Shell脚本相关学习。 Shell:操作系统与用户进行交互操作的界面，提供脚本语言编程环境，方便用户自动批量处理大量的工作任务。 红帽企业版linux一般默认的Shell是bash shell。 shell脚本 Shell:操作系统与用户进行交互操作的界面，提供脚本语言编程环境，方便用户自动批量处理大量的工作任务。 红帽企业版linux一般默认的Shell是bash shell。 vim aa.sh #编辑aa脚本 cd /root/Desktop #切换到root下的桌面 mkdir aa #创建aa目录 touch aa/aa.txt #在aa目录下创建aa.txt sh aa.sh #运行aa.sh脚本 echo $$ 查看当前进程号 bash 进入另一个shell exit 退出 history 历史 语法 替换 ！！ 前一个命令 ！n 命令号n ！-n 倒数第n个命令 ！cmd 最后用来启动cmd的命令 多命令运行#！/bin/sh 注释信息，可写可不写 echo $? 返回值：通过$?变量进行查看，返回0成功，不成功则返回非0值！ 有条件的链接命令 &amp;&amp; 把两个命令链接在一起，只有第一个命令成功执行时，才会执行第二个命令。 || 把两个命令链接在一起，只有第一个命令失败时，才会执行第二个命令。 Bash变量例如：aa=DataScience echo $aa 则会显示DataScience Shell变量A和B A=123 B=234 echo a:$A b:$B 显示AB变量内容 a：123 b：234 export A 将A变量提升为环境变量 bash ps echo a:$A b:$B---- 启动一个bash ，通过ps运行，确定有俩个shell在运行；父shell（B），子shell（A）由于被提升为一个环境变量，A shell从B shell中继承了它，相反，A shell对B shell的变量B一无所知。Bshell 属于sleep状态。结果如下 a：123 ：b： exit echo a:$A b:$B 退出再次查看 a：123 b：234 unset A B----- 取消环境变量A和shell变量 B 命令替换 替换 语法 含义 历史（history） ！ 前一个命令行 大括号（Brace） {} 指定的文本 代字号（Tilde） ~username 用户的主目录 变量 $,${…} Shell和环境变量 算数（Arithmetic） $((…)) 算数运算 命令替换 ‘…’，$(…) 运行在字shell中的命令的输出 路径名（Pathname） [^…*]?,[…] 文件系统中匹配的文件名 mkdir chap&amp;#123;a1,a2,a3,a4,&amp;#125;/&amp;#123;bb,cc&amp;#125; 需要先创建&amp;#123;a1,a2,a3,a4&amp;#125; mkdir -p &amp;#123;a1,a2,a3,a4,&amp;#125;/&amp;#123;bb,cc&amp;#125; 算法a=123 b=234 echo $(($a+$b)) ----- a+b 357 ---------- 结果 2、计算器 Scale=2 保留几位小数, %取余。 Quit 退出计算器 \\;反斜杠 转义字符 创建时间文档 date +%Y%m%d 语法 作用 \\ 避免下一个字符被shell解释 “” 避免双引号内除了S、！和（反引号）字符以外的其它字符被shell解释 ‘’ 避免单引号内的字符被shell解释 alias 命令 Shell别名可创建扩展（替换）为任意文本的命令 alias NAME=a unalias 取消 unalias a 取消a替换NAME的命令 标准输入 标准输出echo “aaa”&gt; aa.txt 创建aa.txt文档 cat aa.txt 查看aa.txt文档 设置密码（可批量设置用户密码） useradd u1 创建u1用户 passwd u1 设置u1 密码 useradd u2 创建u2用户 vim bb.txt 新建立一个bb.txt文档 123456 将密码输入 bb.txt文档中 passwd u2 --stdin &lt; bb.txt 将输入定向到文档中 su - u1 切换到u1 su - u2 切换到u2 输入密码 123456 标准输出和错误输出echo “aaabbccc”&gt;aa.txt &gt;&gt;文件续写 echo “aaabbbcc”&gt;&gt;aa.txt 意思是用&gt;把内容输入到文档中。 head -1 /etc/rc.d/\\* &gt; aa.txt 2&gt;bb.txt 将标准输出和错误输出分别传到aa.txt和bb.txt head -1 /etc/re.d/\\* &gt;aa.txt 2&gt;&amp;1 head -1 /etc/rc.d/\\* &gt;&amp; aa.txt 将标准输出和错误输出合并到aa.txt Shell scripts scripts脚本返回值 echo $? 返回值 退出状态 0（Zero） Success Non-zero Failure 2 Incorrect usage 126 Not an executable 127 Command not found vim aa.sh 编辑aa.sh脚本 read -p &quot;qing shu ru yong hu ming cheng &quot; name echo $name sh aa.sh 运行aa，name脚本 只读变量 变量 含义 ？ 最新执行的命令的退出状态 - 当前启用中的shell选项标记 $ 当前shell的进程id（PID） ！ 最新后台命令的进程ID（pid） _ 前一个命令的最后标记 PPID shell父进程的ID（PID） SHELLOPTS 被冒号隔开的当前启用中的shell选项列表，和set -o命令结果一样 UID 当前用户的用户id 路径替换 ~ */? []/[^] &amp; 比较–针对文件 关于文件类型的判断，如：test -e filename -e 是否存在 -f 是否为文件 -d 是否为目录 -b 是否为block device -c 是否为character device -S 是否为socket -p 是否为pipe文件 -L 是否为链接 比较–权限 关于文件权限的判断，如：test -r filename -r 文件是否可读 -w 文件是否可写 -x 文件是否可执行 -u 文件是否有SUID -g 文件是否有SGID -k 文件是否有Sticky bit -s 文件是否非空 比较–新旧与大小 比较两个文件大小，命令 例如： test A -nt B -nt A是否比B新 -ot A是否比B旧 -ef A是否和B是用一个文件，两个整数之间的判断。 -eq 两个数相等 -ne 两个数不等 -gt A大于B -lt A小于B -ge A大于等于B -le A小于等于B","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://www.a2data.cn/tags/Shell/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://www.a2data.cn/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}]},{"title":"Linux系统监控","slug":"Linux/Linux系统监控","date":"2020-04-25T11:13:45.000Z","updated":"2020-08-07T10:27:06.597Z","comments":true,"path":"posts/10537.html","link":"","permalink":"http://www.a2data.cn/posts/10537.html","excerpt":"Linux 系统监控篇。","text":"Linux 系统监控篇。 系统监控PS 进程监控 ps工具标识进程的5种状态码 D 不可中断 uninterruptible sleep(usually IO) R 运行 runnable (on run queue) S 中断 sleeping T 停止 traced or stopped Z 僵死 a defunct (“zombie”) process 使用方法 ps [options] [–help] ps 的参数 -A 列出所有的行程 -w 显示加宽可以显示较多的资讯 -au 显示较详细的资讯 -aux 显示所有包含其他使用者的行程 总述 标识 释义 USER 行程所拥有者 PID pid %CPU 占用cpu使用率 %MEM 占用的记忆体使用率 VSZ 占用的虚拟机体大小 RSS 占用的记忆体大小 TTY 终端的次要装置号码 COMMAND 所执行的指令 top动态监控系统进程 TOP动态 第一行任务队列信息 - 01:06:08 当前时间 1 user 当前登录用户数 第二、三行 进程和cpu Tasks：158total 进程总数 最后两行为内存信息 Mem：191272k total 物理内存总数 COMMAND 命令名/命令行 SAR 系统活动情况报告 指令软件包：sysstat-7.0.3-3.el5.i386mp sar 命令常用格式 sar [options][-A][-o file]t[n] 其中：t：采样间隔 n 采样次数 默认值为1. options未明朗行选项，sar常用选项如下： -o file 表示将命令结果以二进制格式存放在文件中 -A 所有报告的总和 -u 输出cpu使用情况的统计 -v 输出inode、文件和其他内核表的统计信息 -d 输出每一个块设备的活动信息 -r 输出内存和交换空间的统计信息 -b 显示l/O和传送速率的统计信息 -a 文件读写情况 -c 输出进程统计信息，每秒创建的进程数 -R 输出内存页面的统计信息 -y 终端设备活动情况 -w 输出系统交换活动信息 vmstat监控工具 vmstat 2 10 每隔两秒采集10次 r—表示运行队列 b—表示阻塞的进程 swap—-虚拟内存已经使用的大小 si—-每秒从磁盘读入虚拟内存的大小 sp—每秒虚拟内存写入磁盘的大小 in—-每秒cpu的中断次数 sy—-系统cpu时间 id—-空闲cpu时间 wt—–等等lO cpu 时间 iostat 主要可以显示cpu和1/O系统的负载情况及分区状态信息 直接执行iostat lsof 主要查看端口 lsof -i 22 查看端口为22 的服务 losf -g gid 显示归属gid的进程情况 lsof -i 用以显示符合条件的进程情况 echo $$ 当前进程号 kill -9 5641 杀死（结束）5641进程 strace 跟踪进程执行时的系统调用和所接受的信号。 Find 详解 常见用法 -name filenname #查找名为filename的文档 -perm #按执行权限来查找 -user username #按文档属主来查找 -group groupname #按组来查找 -mtime -n +n #按文档更改时间来查找文档 -n指n天以内，+n指n天以前 -group groupname #按组来查找 -type b/d/c/p/l/f #查是块设备、目录、字符设备、管道、符号链接、普通文档 -size n[C] #查长度为n块[或n字节]的文档 -prune #忽略某个目录","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://www.a2data.cn/tags/Shell/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://www.a2data.cn/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}]},{"title":"Linux NFS网络文件","slug":"Linux/Linux-NFS网络文件","date":"2020-04-25T11:13:31.000Z","updated":"2020-08-07T10:26:24.023Z","comments":true,"path":"posts/10415.html","link":"","permalink":"http://www.a2data.cn/posts/10415.html","excerpt":"Linux 手把手教你搭建NFS网络文件系统。","text":"Linux 手把手教你搭建NFS网络文件系统。 NFS网络文件系统 1.功能：文件共享 2.协议与端口： 需要RPC进行控制 NFS安装yum install nfs-utils protmap（端口分放） 服务机 ip 221vim /etc/exports （配置文件） /aa 192.168.18.220/255.255.255.0(rw) 根下aa 共享（客户机）ip/子掩网码 rw 读写 ro 只读 cd / 切换到根下 mkdir aa 创建aa目录 touch aa/abc.txt 创建aa下abc文档 service nfs restart 重启nfs服务 客户机 ip 220showmount -e 192.168.18.221 cd / mkdir pub 创建pub 文件 mount 192.168.18.220:/aa pub 挂载到aa/pub 切换到服务机 更改权属 ll -d aa 查看aa权限 chmod o+w aa 修改aa权限（o 其他人） service nfs restart 重启服务 切换到客户机 cd pub/ vim abc.txt 修改 touch aa.txt 创建一个文件 切换到服务机 cd aa ls aa 查看是否有文件 配置Sambasamba 软件包 samba.i386 : The Samba SMB server. samba-client.i386 : Samba (SMB) client programs. samba-common.i386 : Files used by both Samba servers and clients. 安装samba mount /dev/cdrom /mnt 挂载 切换到挂载目录进行配置 cd /mnt/Server/ vim /etc/yum.repos.d/qq.repo r /etc/yum.repos.d/rhel-debuginfo.repo yum -y install samba 编辑文件cd /etc/samba/ 切换 vim smb.conf 配置文件 vim /etc/samba/smb.conf security=share ---共享 找见[public] 7yy 复制7行 p 粘贴 修改[aa] --- 这是昵称 comment = nidaye ---注释信息 path = /aa ---要共享的目录 public = yes ---公共的匿名用户可以访问的 writeable = yes ---可被写 browseable = yes ---可被浏览 查看cd / ls mdkir qq 返回根下查看 创建qq文件 cd qq touch aa.txt 切换到qq下创建aa文档 service smb restart 重启smb服务 修改文件权限1、 chmod o+w /aa 2、 cd /aa chmod 777\\* Linux客户端 smbclient -L //192.168.18.221—查看共享信息 smbclient //192.168.18.221/share-进入共享目录 ? 查看有哪些命令可以使用 ls 查看共享目录下有哪些内容 windows客户端 \\192.168.18.221 —可以看到共享目录","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://www.a2data.cn/tags/Shell/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://www.a2data.cn/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}]},{"title":"Linux Apache论坛","slug":"Linux/Linux-Apache论坛","date":"2020-04-25T11:13:14.000Z","updated":"2020-08-07T10:05:10.880Z","comments":true,"path":"posts/41055.html","link":"","permalink":"http://www.a2data.cn/posts/41055.html","excerpt":"Linux 手把手教你搭建Apahce论坛","text":"Linux 手把手教你搭建Apahce论坛 搭建一个Apache论坛该论坛是再虚拟机环境下运行，实机一样得操作。 恢复快照，检测是否有 阿帕奇 service httpd restart 源代码安装的 进入apache目录 删除即可 yum源安装的 使用 rmp卸载 一、挂载mount /dev/cdrom /mnt 挂载镜像文件到/mnt ls /mnt/Server/ 查看是否有文件 vim /etc/yum.repos.d/aa.repo 配置yum文件 二、安装*【注：\\* 为安装http 下所有包】 1.yum -y install http\\* （先装阿帕奇服务） 2.yum -y install mysq\\* （数据库） 3.yum -y install php\\* （php开发语言） 三、启动service httpd restart 启动阿帕奇 service mysqld restart 启动mysq 再去启动论坛包（Discuz_X2_SC_UTF8）copy到虚拟机 四、解压（zip压缩包）cd /root/Desktop 切换到桌面 unzip Discuz_X2_SC_UTF8 解压Discuz到桌面 cp -r upload /uar/www/html/ 复制upload文件到html cd /dav/www/html ls 切换到html 查看是否有upload文件 （恢复快照）重新配置ip vim /etc/sysconfig/network-scripts/ifcfg-eth0 ifdown eth0 &amp;&amp; ifup etho ping通（192.168.18.222）--本机 使用本机或者虚拟机浏览器进行访问 192.168.18.221 Red Hat 192.168.18.221 upload 五、安装192.168.18.221/upload进入Dis 安装向导 修改阿帕奇权属权限 chown apache upload html -R （-R递归修改所有权属） 六、创建数据库mysql 进入数据库 show databases； 显示当前数据库 create database hehe; 创建 hehe grant all on hehe.\\* to ‘hh’@‘localhost’ identified by ‘123456’; (密码 ，授权） 数据库名：hehe 数据库用户名：hh 密码：123456 错误情况方案整理：1、数据库模版错误 yum -y install php-\\* 2、安装http中过程中途停止 yum -y install httpd-devel 3、安装mysql时出错 yum -y install mysql-connector-odbc 4、想卸载已安装http（apache）时，需在挂载镜像。 yum -y remove http\\* 5、配置yum（配置服务器中文包） yum install fonts-chinese.noarch yum install m17n-db-common-cjk yum install m17n-db-chinese","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://www.a2data.cn/tags/Shell/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://www.a2data.cn/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}]},{"title":"Linux 计划任务","slug":"Linux/Linux-计划任务","date":"2020-04-25T11:12:39.000Z","updated":"2020-08-07T10:03:30.255Z","comments":true,"path":"posts/39704.html","link":"","permalink":"http://www.a2data.cn/posts/39704.html","excerpt":"计划任务","text":"计划任务 计划任务date----当前时间 ctrl+D 保存 Atq 查看任务列表 Atrm 删除任务 At 一次性计划任务 命令：at + 时间 Crontab 周期性计划任务 服务脚本名称： /etc/init.d/crond crontab -e [-u 用户名] 编辑计划任务 crontab -l [-u 用户名] 查看计划任务 crontab -r [-u 用户名] 删除计划任务 周期条件 分 时 日 月 周 执行内容 0-59（整数） 0-23（整数） 1-31(整数） 1-12（整数） * run_command 50 3 2 1 * 执行命令或脚本 例如： 30 18 */3 * 1,3，5 /bin/rm-rf /var/ftp/pub/* 30 18 */3 * 1,3,5 /bin/rm -rf /var/ftp/pub/* 每隔3天在周1,3,5来清除FTP服务公共目录. * ， - / 表示该范围内的任意时间 表示间隔的多个不连续时间点 表示一个连续的时间范围 指定间隔的时间频率","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://www.a2data.cn/tags/Shell/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://www.a2data.cn/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}]},{"title":"Linux SSH协议","slug":"Linux/Linux-SSH协议","date":"2020-04-25T11:12:22.000Z","updated":"2020-08-07T10:26:33.756Z","comments":true,"path":"posts/630.html","link":"","permalink":"http://www.a2data.cn/posts/630.html","excerpt":"Linux SSH协议。","text":"Linux SSH协议。 SSH 协议默认端口 ：TCP：22 FTP:21 SSH:22 Apache（阿帕奇）：80 步骤1： ping 192.168.18.221 （ping得通） 步骤2：ssh [root@192.168.18.221](mailto:root@192.168.18.221) 输入密码 进入服务端 步骤3： exit 退出服务端 ssh-keygen -t rsa(或者dsa) 客户机生成密钥 步骤4：ssh-copy-id -i .ssh/id_rsa.pub [root@192.168.18.221](mailto:root@192.168.18.221) 将密钥上传输到服务端。 步骤5：输入服务端密码 exit 再次输入 ssh [root@192.168.18.221](mailto:root@192.168.18.221) 便可直接进入！","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://www.a2data.cn/tags/Shell/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://www.a2data.cn/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}]},{"title":"Linux Mdadm案例","slug":"Linux/Linux-Mdadm案例","date":"2020-04-25T11:12:05.000Z","updated":"2020-08-07T10:26:20.550Z","comments":true,"path":"posts/61794.html","link":"","permalink":"http://www.a2data.cn/posts/61794.html","excerpt":"Linux Mdadm 案例 raid5。","text":"Linux Mdadm 案例 raid5。 Mdadm 案例 raid5一、添加RAID5mdadm -C /dev/md5 -l 5 -n 3 /dev/sd[b,c,d] 二、创建文件系统 格式化：mkfs.ext3 /dev/md5 makir /raid5 三、挂载文件系统 mount /dev/md5 /raid5 挂载文件系统 df -hT 查看 RAID容错mdadm /dev/md5 -f /dev/sdb 损坏磁盘b mdadm -D /dev/md5 查看 mdadm /dev/md5 -a /dev/sdf 增加一块磁盘 mdadm /dev/md5 -r /dev/sdb 移除坏磁盘 echo &quot;DEVICE /dev/sdc /dev/sdd /dev/sde /dev/sdf&quot; &gt;&gt;（写入到哪） /etc/mdadm.conf 把UUID 写入 /etc/.......文件中 mdadm -Ds &gt;&gt; /etc/mdadm.conf 把UUID 读写出来 cat /etc/mdadm.conf mdadm -S --scan /dev/md5 关闭RAID（需要卸载md5） mdadm -A --scan /dev/md5 开启RAID 恢复快照！","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://www.a2data.cn/tags/Shell/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://www.a2data.cn/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}]},{"title":"Linux逻辑卷","slug":"Linux/Linux逻辑卷","date":"2020-04-25T11:11:47.000Z","updated":"2020-08-07T10:26:49.196Z","comments":true,"path":"posts/40711.html","link":"","permalink":"http://www.a2data.cn/posts/40711.html","excerpt":"Linux 逻辑卷得操作指南。","text":"Linux 逻辑卷得操作指南。 LVM逻辑卷 创建lvm 创建物理卷__PV pvcreate /dev/sdb,c,d,e (创建pv） pvdisplay(显示pv） 创建卷组 vgcreate /dev/feng_vg /dev/sdb,c,d,e(创建vg） vgdisplay (显示vg） 拓展vg pvcreate /dev/sdf(创建一个新的pv） vgextend feng_vg /dev/sdf (扩展vg) 减少vg vgreduce feng_vg /dev/sdc,d,e 移除vg vgremove feng_vg 创建LV lvcreate -L 30G -n feng_lv feng_vg 格式化 mkfs.ext3 /dev/feng_vg/feng_lv 挂载 mount /dev/feng_vg/feng_lv /aa 增加 先卸载 umount /aa lvextend -L +10G /dev/feng_vg/feng_lv（检测硬件） resize2fs /dev/feng_vg/feng_lv （重设文件系统大小） 减少LV先卸载 （输入卸载名称或者目录） umount /dev/feng_vg/feng_lv 缩小lv先缩小文件系统再缩小lv e2fsck -f /dev/feng_vg/feng_lv （检测硬件） resize2fs /dev/feng_vg/feng_lv 9g （将文件系统缩小到9G） 缩小lv lveduce -L 9G /dev/feng_vg/feng_lv 移除lv lvremove /dev/feng_vg/feng_lv 移除pv pvremove /dev/sdb1 /dev/sdb2 lv 使用pe（默认4M） 的块 lvcreat -l (小写） 个数 lvcreat -L (大写） 指定容量","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://www.a2data.cn/tags/Shell/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://www.a2data.cn/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}]},{"title":"Linux磁盘管理","slug":"Linux/Linux磁盘管理","date":"2020-04-25T11:11:29.000Z","updated":"2020-08-07T10:26:42.696Z","comments":true,"path":"posts/37426.html","link":"","permalink":"http://www.a2data.cn/posts/37426.html","excerpt":"Linux 磁盘管理。","text":"Linux 磁盘管理。 磁盘管理查看磁盘fdisk -l fdisk /dev/sdb 磁盘分区 指令 m l list known partition 列出所有的分区 n add a new partition 创建一个新的分区 p print the partition table 打印分区内容 t change a partition&#39;s system id 改变分区系统id w write table to disk an exit 保存并退出分区 d delete a partition 删除一个分区 查看分区fdisk -l fdisk /dev/sdb 磁盘分区 n----创建 d----删除 交换分区fdisk /dev/sdb格式化为 swap 命令 mkswp /dev/sdb1 设置分区mkswap /dev/sdb1 (做成交换文件系统） free 查看一下内存 swapon /dev/sdb1 开启交换内存 free 查看内存 swapoff /dev/sdb1 关闭交换内存 free 最后查看 是否存在 文件系统umount 卸载 mount 挂载 1、创建 mkfs - t ext3 /dev/sdb1 mkfs ext3/dev/sdb1 挂载 mount /dev/sdb /mnt 查看 df -hT","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://www.a2data.cn/tags/Shell/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://www.a2data.cn/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}]},{"title":"Linux系统程序","slug":"Linux/Linux系统程序","date":"2020-04-25T11:11:14.000Z","updated":"2020-08-07T10:27:01.836Z","comments":true,"path":"posts/60364.html","link":"","permalink":"http://www.a2data.cn/posts/60364.html","excerpt":"Linux 系统程序篇。","text":"Linux 系统程序篇。 系统程序 系统程序管理RPM包 （Red Hat） 命名格式 ： bash-3.1-16.1.i386.rpm 软件包名-版本号-发布次数-硬件平台-后缀名 rpm管理命令 rpm -q [子选项] 【软件名】 rpm -qa 查看系统中已安装的所有rpm软件包列表 rpm -qpi 通过.rpm 包文件查看该软件的详细信息 rpm -qpl 查看.rpm安装包内所包含的目录.文件列表 安装 rpm -i rpm包文件 安装一个新的rpm软件包 rpm - U 升级某个rpm软件包，若原本未安装，则进行安装 rpm -F 更新某个rpm 软件，若原本未安装，则放弃安装 安装 步骤1： tar 解包 步骤2： ./configure 配置 步骤3： make 编译 步骤4： make instal 步骤5: service httpd restart service network restart 步骤6: cd /var/www/ Yum本地：Yum(file本地） 命令： cd /etc/yum.repos.d/xd 挂载： 1. 挂载光盘镜像到/mnt mount /dev/cdrom /mnt 2. 配置yum源 vim /etc/yum.repos.d/xxx.repo [xxx] baseurl=file:///mnt/Server(flie本地) enabled=1(是否启动文件 0否 1是） gpgcheck=0 3. 安装 yum -y install 软件名称 （vsftpd） 4. 重启 yum service vsftpd start 服务器Yum ------服务器yum 0、命令： cd /etc/yum.repos.d/ 1、服务器端提供共享 -- 服务器安装一个ftp -- 把光盘镜像挂载ftp的共享目录 挂载： mount /dev/cdrom /var/ftp/pub 必须保证两台机器能够正常通信（能够ping通） 2、配置客户端 vim /etc/yum.repos.d/xxx.repo [xxx] baseurl=[ftp://192.168.18.221/dev/cdrom](ftp://192.168.18.221/dev/cdrom) /var/ftp/pub 【服务器ip地址及共享目录】 enabled=1(是否启动文件 0否 1是） gpgcheck=0 开启 service vsftpd start 卸载 rpm -e 软件名 源代码（灵活定制） tarball 封包 tar.gz 或者 tar.bz2 效验工具 md5 sum","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://www.a2data.cn/tags/Shell/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://www.a2data.cn/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}]},{"title":"Linux网络设置","slug":"Linux/Linux网络设置","date":"2020-04-25T11:10:58.000Z","updated":"2020-08-07T10:26:57.943Z","comments":true,"path":"posts/37390.html","link":"","permalink":"http://www.a2data.cn/posts/37390.html","excerpt":"Linux 网络设置配置。","text":"Linux 网络设置配置。 网络设置 存放位置 —- 以RedHat为例 /etc/sysconfig/network-scripts/ifcfg-etc0 修改ipsetup 交互式图形化工具 vim /etc/sysconfig/network-scripts/ifcfg-eth0 修改 DNS/etc/resolv.conf 修改主机名vim /etc/sysconfig/network 网卡控制1.ifdown 关闭网卡 丨 ifup 开启网卡 2.service network stop 丨 start 丨restart 停止 开启 重启 开机自启动chkconfig httpd on 开机自动挂载 设置开机自动挂载的路径这个是当时学习在虚拟机上使用的多。 /etc/fstab 网络配置IP：是一个逻辑地址，是由32位二进制构成 ------------------------------------------------------- setup vim /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=eth0 网卡 BOOTPROTO=none 是否自动获取IP ---&gt; dhcp HWADDR=00:0c:29:d6:96:fb MAC地址 ONBOOT=yes 是否随网络服务启动，eth0生效 NETMASK=255.255.255.0 子网掩码 IPADDR=192.168.18.76 IP地址 TYPE=Ethernet 类型为以太网 ------------------------------------------------------ 修改DNS vim /etc/resolv.conf search localdomain nameserver 192.168.40.2 nameserver 202.106.0.20 联通 nameserver 114.114.114.114 nameserver 8.8.8.8 谷歌 nameserver 4.4.4.4 谷歌","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://www.a2data.cn/tags/Shell/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://www.a2data.cn/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}]},{"title":"Linux权限控制","slug":"Linux/Linux权限控制","date":"2020-04-25T11:10:30.000Z","updated":"2020-08-07T10:26:53.842Z","comments":true,"path":"posts/16586.html","link":"","permalink":"http://www.a2data.cn/posts/16586.html","excerpt":"Linux 权限控制详解。","text":"Linux 权限控制详解。 权限控制属组权限 字符制表示八进制 000 - 777 字符表示法 八进制表示法 含义 r 4 读 w 2 写 x 1 执行 修改权限的命令 【 su - u2 切换用户】 1、 chmod 修改文件权限 2、 chown，chgrp 修改文件权属 U----所有者 O----其他人 a-----所有人 g-----所属组 chomd a=rwx root 所有都拥有读写执行权限 cat /etc/passwd|grep -v nologin|grep -v halt|grep -v shutdown|awk -F&quot;:&quot; &#39;&amp;#123; print $1&quot;|&quot;$3&quot;|&quot;$4 &amp;#125;&#39;|more 用户控制命令 useradd 添加用户 useradd -g 指定用户所属用户组 useradd -G 用户组 指定用户所属的附加组 useradd -u 用户号 指定用户的用户号 命令：指定用户所属组 useradd -g 组名 -u 用户号 用户名 例如 useradd -g g3 -u 510 u5 指定用户附属组 useradd -g 组名 -G 所在组 用户名 例如: useradd -g g4 -G g1 u7 修改账户信息 usermod 修改账户信息 usermod -g 用户组指定用户所属的用户组 usermod -l 锁定账号 usermod -u 解锁账号 userdel 删除账户 userdel -r 删除宿主目录 设置密码 passwd 设置密码 passwd -l 锁定账号 passwd -u 解锁账号 passwd -s 查看账号状态 usermod -L u1 u1账号被锁定 usermod -U u1 u1账号被解锁 passwd u1 设置u1 账号密码 linux 组账户 groupadd 添加组成员 groupdel 删除组成员 gpasswd 设置组成员 -a 添加成员 -d 删除成员 -M 定义成员列表 gpasswd -a u1 g1 将u1加入到g1组中 gpasswd -M u1,u2,u3,u4,u5 g2 将u1到u5添加g2组里","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://www.a2data.cn/tags/Shell/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://www.a2data.cn/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}]},{"title":"Linux基本操作","slug":"Linux/Linux基本操作","date":"2020-04-25T11:10:17.000Z","updated":"2020-08-07T10:26:45.999Z","comments":true,"path":"posts/46411.html","link":"","permalink":"http://www.a2data.cn/posts/46411.html","excerpt":"Linux 基本操作。","text":"Linux 基本操作。 本文精心整理，如需转载，请联系小编。谢谢。相关安装包可以加小编获取。 服务器路径 命令符号 释义 / 根目录 /bin 二进制可执行命令 /dev 设备特殊文件 /etc 系统管理和配置文件 /etc/rc.d 启动的配置文件和脚本 /home 用户主目录的基点 /lib 标准程序设计库 /sbin 超级管理命令 /mnt 系统提供这个目录是让用户临时挂载其他的文件系统 /root 系统管理员的主目录 /Lost+found 这个目录平时是空的， 系统非正常关机而留下“无家可归”的文件 /proc 虚拟的目录，是系统内存的映射 /usr 应用程序和文件几乎都在这个目录. /var 某些大文件的溢出区 boot 内核文件 Linux 系统文件（100MB-200MB） 服务器500MB opt 临时文件 常用快捷键图形界面 到 字符界面Ctrl Alt Fn （F1-----F6） init 3 字符界面 到 图形界面 Alt F7 init 5 Tab键 ：自动补齐 反斜杠\\ ：强制换行 ctrl+u 清空至行首 ctrl+k 清空至行尾 ctrl+L 清屏 ctrl+c 取消本次命令编辑 touch 创建文件 mkdir 创建目录 mkdir -p 创建嵌套的多层目录结构 cd 切换工作目录 cd - 切换两个目录 cd .. 返回上个目录 du 统计目录及文件 du -s 只统计大小 du -a 统计所有文件 du -h 人性化显示 du -sh \\* 查看所有文件及大小 pwd ------- 查看当前所在位置 vim ------查看日志（编辑器） Ls ------ 打印（当前目录下所包含的内容）ls 显示目录内容（ls=ll） ./ ------直接运行脚本 查看帮助help， -help man info （man ls） 常用命令 uname 查看系统信息及内核版本（-a 显示主机；-r 显示内核版本） hostname 查看主机名 vim /etc/sysconfig/network 更改主机名 ifconfig 查看网络信息 shutdown -h now | poweroff | init 0 关闭计算机 shutdown -r now | reboot | init 6 重启计算机 Ln软链Ln链接文件 Ln 要链接的文件 链接到什么地方 ln 创建链接文件 ln -s 软链接 ln 硬链 CP 复制cp -r 递归复制整个目录树 cp=cp-i cp -r 递归复制 cp -p 保持源文件的属性不变 cp -f 强制覆盖目标同名文件或目录 cp -i 需要覆盖文件或目录时进行提醒 RM 删除rm -rf 递归强行删除文件或者目录 不进行提醒 rm -f 强行删除文件或者目录，不进行提醒 rm -r 递归删除整个目录树 rm - i 删除文件或者目录时提醒用户确认 MV 移动（改名）Cat 查看文件 More 分页查看文件 （不可返回） Less 分页查看文件 （可返回） Head 查看文件头（前10行） Tail 查看文件尾 （后10行） WC 统计wc -l 统计行数 wc -w 统计单词个数 wc -c 统计字节数 压缩指令 压缩 （仅限文件） gzip bzip2 表示高压缩比： gzip -9 bzip2 -9 解开已经压缩的文件 gzip -d bzip2 -d Tar 归档 口令打包压缩： Tar 要打包压缩到什么地方 要打包压缩的文件 单个解释用法： tar -c 创建 . tar格式的包文件 tar -x 解开. tar格式的包文件 tar -v 查看详情信息 tar -f 表示使用归档文件 tar -p 打包时保留原始文件及目录的权限 tar -t 列表查看包内文件 tar -C 解包时指定释放的目标文件夹 tar -z 调用gzip程序进行压缩或者解压 tar -j 调用bzip2 程序进行压缩或者解压 组合命令： tar -cvf 打包 tar -zcvf 打包压缩 tar -zcvf XXX.tar.gz XX tar -xvf 解压 tar -xvf xxxx.tar.gz -C aaa 解压到指定目录 打包压缩---- tar -zcvf 解压 ----- tar -zxvf 指定位置解压--- tar -zxcf -C xx.bz2用bzip2 -d解压 xx.gz用gzip -d解压 xx.tar.gz 用-zxvf解压 xx.tar.bz2用-jxvf解压 常用 打包： 1、tar -zcvf a2data.tar.gz ./a2data.cn/* 2、tar -zcvf a2data.tar.bz2 ./a2data.cn/* ---- 将a2data.cn文件夹下统一打包 ------ 解压(万能)： tar -xf a2data.tar.bz2 ./ ---- 解压到当前路径下---- VI 编辑器命令模式: vim/vi ESC 输出模式: a、i、o等键 末行模式： (大写)A键 工作模式：命令模式 输入模式 末行模式 a #光标后面写 i #光标前面写 o #下一行写 dd #删一行 n+dd #删几行 d$ #删除光标后面的同一行 （删光标） d^ #删除光标前面的同一行 （不删光标） x #删光标 X #删光标前面的 yy #复制 p #黏黏到下一行 P #黏黏到上一行 u #撤销上一步 U #撤销这一行的所有修改 :q! #不保存退出 :w #保存 :wq #保存退出 :/ #搜索的东西 搜索什么 从上到下搜索 % #搜索的东西 搜索什么 从下到上搜索 行号 :set nu #设置行号 :set nonu #不要行号了 跳转到首行gg 跳转到尾行G \\#G跳转到到第几行 ：e/etc/passwd 打开新的编辑文件 ：r/etc/passwd 读入其他文件内容 文件内个替换 s/old/new 替换行里的一个old换成new s/old/new/g 整行替换 old换成new #，#s/old/new/g #到#行替换 old换成new %s/old/new/g 整篇替换 old换成new c 末尾加入c 对每个替换提示用户进行确定","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://www.a2data.cn/tags/Shell/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://www.a2data.cn/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}]},{"title":"Hexo博客疑难杂症","slug":"Hexo/Hexo博客疑难杂症","date":"2020-04-19T10:57:28.000Z","updated":"2020-08-07T10:23:55.188Z","comments":true,"path":"posts/f92cb63f.html","link":"","permalink":"http://www.a2data.cn/posts/f92cb63f.html","excerpt":"Hexo 疑难杂症","text":"Hexo 疑难杂症 墙裂推荐Hexo博客前言 www.a2data.cn —– 小编小站 Q: 为什么要搭建一个属于自己的个人博客呢？ 个性化 用自己喜欢的域名，选择自己喜欢的主题，布局，特效等都可以自己编写代码完成，不会的也可以进入对应开源主题交流群, 你会发现这些人更加随和、热心,例如闪烁之狐主题的创作者 — blinkfox 成就感 当网站被搜索引擎收录，输入相应关键字即可，可以小小的炫耀一番 拓展交流圈 如果你对某类感兴趣的话，可以通过个人博客找到一些志同道合的朋友。例如：sitoi 学会坚持 刚开始搭建好属于自己的博客，那真的是三分钟热度，但是真的坚持下来的人很少.很多人就跑个主页,就像很多公众号一样,注册了没创作。小编虽然是体育僧，不论是跨行，还是博客,公众号，都坚持(没发表可能是忙,或者持续充电中)。 简历加分项 当我们苦于该如何写一份个人简历时，当你拿出一个你坚持 3 年、5 年的个人博客时，或许你的机会就比别人大一点。更直观，更好的了解你得技术栈。更有信服力。 个人空间 在这个地方，你可以写一些自己的东西(不管有没有人看)，你可以自己快速定位自己查找过的东西，不用每次都去百度同样的问题，也不用担心每次找不到最优解 以至于很多朋友直接去我的网站找资料 写作水平的提高 坚持写作，你的写作水平会得到很到的提高，对你今后的人生会有很大的帮助。包括语言，架构，排版 。。 总之短期是看不出效果的，只有长期坚持。 好比： 你去学习一个月跆拳道，你说你会，一个练了十年的人，同样是一拳一腿 跟你有可比性吗？ 赚取一点钱 当你的博客足够好，公众号粉丝足够多，内容足够丰富，你可以开始尝试赚钱，当然啦，和坚持是离不开的。 折腾中学会知识，互访中找到友情，写作中读懂人生，坚持中找到方向。 比如 像小编的目标一直没变，用大数据人工智能推动传统行业的发展而奋斗！！！ 心动，为何不动？ 相信大家刚开始都是这么想的,搭建博客？ 需要具备： 网站,域名,备案 服务器 自己写代码(前端+后端+服务器部署) … …… 啊，我太南了 —– 臣妾做不到啊 不要慌，问题不大！没关系,小编一步步带你飞。教你如何从零开始拥有属于自己的博客网站。(仅面向Windows用户,就会有人问Mac 不香吗？ 香，但是太贵，买不起,也不太会用!) 小编推荐： windows神器： utools 生成力工具集:https://www.u.tools/ 环境准备: Node.js Hexo Git GitHub SSH key Coding Typora (Md格式书写工具) idea(就是编辑工具,推荐webstorm) 拓展： 服务器部署 域名配置 PWA离线访问 SEO优化 加速访问 ……… 安装Node.js 中文网：https://nodejs.org/zh-cn/download/ 官方网站：https://nodejs.org/en/ 直接下载对应的安装包，之后一顿操作,跟安装QQ一样。 安装步骤如下： 选择安装 安装完成 查看是否安装成功 启动： win键(就是windows图标得那个按键) + R 输入： cmd 清空： cls 安装hexo npm install hexo-cli -g 输入npm install hexo -g，开始安装Hexo 输入 hexo -v 查看是否安装成功 创建博客方式1： # 方式1 一定要是一个空的文件夹 mkdir sqlsq.github.io cd sqlsq.github.io hexo init 方式2： hexo init sqlsq.github.io cd sqlsq.github.io 本地访问 到此，你已经可以搭建hexo 博客了，恭喜一波。 hexo 命令问题命令找不到解决方案 *首先可以安装一波 配置环境变量 找到这东西就好说了。配置一下环境变量即可。soeazy 设置之后再次查看 安装Git 官网：https://git-scm.com/downloads 下载直接默认下一步即可： 配置自己的ssh 桌面鼠标右键，点击Git Base Here。 # 设置 git 相关信息 git config --global user.name &quot;你得昵称&quot; git config --global user.email &quot;your.email&quot; # 生成密钥 ssh-keygen -t rsa -C &quot;youemail&quot; # a2data@vip@qq.com `连续回车 3连击` 即可完成密钥的生成创建。 查看密钥 cd ~/.ssh 输入cd ~/.ssh，检查是否由.ssh的文件夹 ls 查看 备份 单独一个 可以不用这样做 直接看下边快捷操作输入 eval “$(ssh-agent -s)”，添加密钥到ssh-agent 其实就是对ssh做了复制添加 eval &quot;$(ssh-agent -s)&quot; ssh-add ~/.ssh/id_rsa #添加生成的SSH key到ssh-agent 快捷操作 # 本部分需要在 github上使用，别着急请往下看。 cat id_rsa.pub Git拓展 此部分针对多个博客，多个key的，单独的跟着上边走即可。 参考博文配置：https://www.cnblogs.com/a2data/p/12597940.html 多个账号建议使用局部的。 # 取消全局 用户名/邮箱 配置 git config –global –unset user.name git config –global –unset user.email # 单独设置每个repo 用户名/邮箱 git config user.name &quot;用户名&quot; //在config后加上--global即全局 git config user.email &quot;邮箱&quot; 如下图： ssh-keygen -t rsa -f ~/.ssh/xxx_id_rsa -C &quot;yourmail@xxx.com&quot; 或者 ssh-keygen -t rsa -C &quot;yourmail@xxx.com&quot; #第一次时输入名字 注册Github 如果你有Github想体验一波删除，重新创建小编也不介意的。毕竟写教程，我也是操作了一波。 删除github登录github账号 *找到自己的邮件 重新注册 打开github官网：https://github.com 选择你得职业相关信息： 创建并且会给你发邮件激活： 登录邮箱激活： 配置Github 配置key 完成配置 测试配置是否成功输入ssh -T git@github.com，测试添加ssh是否成功。 输入yes， 如果看到Hi后面是你的用户名，就说明成功了 执行git port22 异常解决方案 应该是小编特殊情况导致。解决顺便做个记录。 新手忽略即可。 配置博客到Github 再你博客的根目录中(sqlsq.github.io) 配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） 大概在 98行。 打开推荐方式： sublime text(未破解有广告) webstrom vscode ( 免费) deploy: type: git repository: git@github.com:nianshaofeng/nianshaofeng.github.io.git branch: master 回到你的项目 复制你得repo值 创建文章 如果使用GitBash 请到博客根目录执行。 Hexo命令# 全部命令 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server） hexo deploy #部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 # 缩写： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy # 组合命令： hexo s -g #生成并本地预览 hexo d -g #生成并上传 发布部署# 在生成以及部署文章之前，需要安装一个扩展： 如下图 # mac 用户 需要加 `sudo` npm install hexo-deployer-git --save npm报错# 主要是镜像源的问题 npm config set registry http://registry.npmjs.org/ 查看部署首先先设置一下你得配置： 之后便会有你的域名： 打开结果一看 卧槽，无情。 这是什么鬼。 怎么跟我想要看的不一样（与本地不一样啊） 不要慌，问题不大。小编告诉你为什么。 重新创建项目，如下图。 我们看看问题在哪 1、https://minesql.github.io/sqlsq.github.io/ 2、https://minesql.github.io/ 我们将config.yml 地址换成第二次创建的项目地址。 再次提交。 我们再次访问看一下效果吧 目前小编博客： https://a2data.github.io/ https://www.a2data.cn/ 应朋友有要求，写了一篇炒鸡详细的，以及遇到的各种坑。 如果有帮助就收藏吧。 拓展内容下期见： 个性化主题 图床(为什么要有图床呢 自己研究) seo 等等","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/categories/Hexo/"},{"name":"Blog","slug":"Hexo/Blog","permalink":"http://www.a2data.cn/categories/Hexo/Blog/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/tags/Hexo/"}]},{"title":"资料分享","slug":"Tools/资料分享","date":"2020-04-14T02:55:49.000Z","updated":"2020-08-07T10:29:13.027Z","comments":true,"path":"posts/45997.html","link":"","permalink":"http://www.a2data.cn/posts/45997.html","excerpt":"这里是分享资源整理学习资源，分享。","text":"这里是分享资源整理学习资源，分享。 示例 不断更新 本站链接已隐藏，关注公众号获取密码提取 链接: https://pan.baidu.com/s/1bLYT-nJf7UwT2Y_6xzS_5Q 提取码: g4ej 本站下载绝不收费，输入验证码后查看（防止机器采集被和谐）验证码：请关注本站微信公众号，回复“我要学习”，获取验证码。在微信里搜索“DataScience”或者“A2Data”微信扫描右侧二维码 function lock(){ var code =document.getElementById(\"verifycode\"); if(code.value !== '666888'){ alert(\"密码错误，请关注本站公众号获取\"); } else{ $('#link').html($('#link .code').html()); alert(\"密码输入正确，成功获取到链接\"); } } Document .user{ display: flex; background: bisque; padding: 10px; margin-bottom:10px; } .user ul { list-style: none; } document.getElementById(\"btn\").addEventListener(\"click\",Gethubdata); function Gethubdata(){ let her = new XMLHttpRequest(); her.open(\"GET\",'https://api.github.com/users',true);//第三个参数表示是否以异步的方式打开 her.onreadystatechange = function(){ if(this.readyState===4) { let data = JSON.parse(this.responseText); let output = \"\"; for (const key in data) { //下面用的了模板字符串，不了解的参见文末的文章推荐 output+=` id:${data[key].id} login:${data[key].login} type:${data[key].type} ` }; document.getElementById(\"users\").innerHTML = output; } }; her.send(); }; 表格 Document 课程表 星期一 星期二 星期四 星期五 语文 数学 英语 生物 ​","categories":[{"name":"职场","slug":"职场","permalink":"http://www.a2data.cn/categories/%E8%81%8C%E5%9C%BA/"}],"tags":[{"name":"资料分享","slug":"资料分享","permalink":"http://www.a2data.cn/tags/%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB/"},{"name":"学习资源","slug":"学习资源","permalink":"http://www.a2data.cn/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"}]},{"title":"Hexo部署到码云","slug":"Hexo/Hexo部署服务器","date":"2020-04-07T08:15:10.000Z","updated":"2020-08-07T10:23:55.191Z","comments":true,"path":"posts/8f004046.html","link":"","permalink":"http://www.a2data.cn/posts/8f004046.html","excerpt":"Hexo 部署到Gitte","text":"Hexo 部署到Gitte Hexo 部署到码云 其实使用码云和使用github没有太大的区别，最近开始使用码云，为了避免忘记，还是做一下记录吧。 1、注册账号 码云网址：https://gitee.com/。 如果想以http://a2data.gitee.io这种一级域名的形式访问bolg，那么我们需要建立一个与自己个性地址同名的项目，如 https://gitee.com/a2data 这个用户，在创建项目时项目名称应该为A2Data。 2、创建仓库 3、复制项目 4、配置仓库 5、部署到码云# 这块会输入账号密码 ，稍后配置以下ssh 以后就不用输入账号密码了 hexo d 6、Page服务 启动服务 7、配置SSH 8、成功访问 https://sqlsq_admin.gitee.io/","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/categories/Hexo/"},{"name":"Gitee","slug":"Hexo/Gitee","permalink":"http://www.a2data.cn/categories/Hexo/Gitee/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/tags/Hexo/"}]},{"title":"手把手教你玩git","slug":"Tools/手把手教你玩git","date":"2020-03-31T14:51:33.000Z","updated":"2020-08-07T10:29:00.204Z","comments":true,"path":"posts/47936.html","link":"","permalink":"http://www.a2data.cn/posts/47936.html","excerpt":"Git 深入浅出，史无前例的详细教程。","text":"Git 深入浅出，史无前例的详细教程。 0、查看本机公钥 步骤： 1、进入.ssh目录 cd ~/.ssh 2、找到id_rsa.pub文件 ls / ll 3、查看文件 cat id_rsa.pub JackFeng@JackFeng MINGW64 ~/Desktop $ cd ~/.ssh JackFeng@JackFeng MINGW64 ~/.ssh $ ls config id_rsa id_rsa.pub id_rsa_sql id_rsa_sql.pub known_hosts JackFeng@JackFeng MINGW64 ~/.ssh $ cat id_rsa.pub 1、配置多个git仓库多仓库之间 &#39;ssh-key切换&#39; #1、生成客户端自己的密钥对 ssh-keygen ---- 一顿回车即可 # 实际操作 换成你的邮箱即可 ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 可以在客户端的家目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥。 生成新的ssh-key #second@mail.com 工作邮箱地址 ssh-keygen -t rsa -C &#39;second@mail.com&#39; -f id_rsa_second 配置多个仓库 在.ssh目录创建config文本文件并完成相关配置(最核心的地方)每个账号单独配置一个Host，每个Host要取一个别名，每个Host主要配置HostName和IdentityFile两个属性即可 Host的名字可以取为自己喜欢的名字，不过这个会影响git相关命令，例如： HostName 这个是真实的域名地址IdentityFile 这里是id_rsa的地址PreferredAuthentications 配置登录时用什么权限认证–可设为publickey,password publickey,keyboard-interactive等User 配置使用用户名 config # 配置github.com Host github.com HostName github.com IdentityFile ~\\.ssh\\id_rsa PreferredAuthentications publickey User yinjie.feng # 配置SQLSQ Host SQL HostName github.com IdentityFile ~\\.ssh\\id_rsa_sql PreferredAuthentications publickey User yinjie.feng 测试是否调通 JackFeng@JackFeng MINGW64 ~/.ssh $ vim config JackFeng@JackFeng MINGW64 ~/.ssh $ ssh -T git@github.com Hi A2Data! You&#39;ve successfully authenticated, but GitHub does not provide shell access. JackFeng@JackFeng MINGW64 ~/.ssh $ vim config JackFeng@JackFeng MINGW64 ~/.ssh $ ssh -T git@SQL Hi MineData-SQL! You&#39;ve successfully authenticated, but GitHub does not provide shell access. git add、git commit、git remote add、git push需要说明的一点，在git commit 时需要一次身份验证，正确输入你的用户名和邮箱就可以了。 另外注意：github根据配置文件的user.email来获取github帐号显示author信息，所以对于多帐号用户一定要记得将user.email改为相应的email(monster@mail.com)。 总结一下:其实建立第二个密钥对的区别就在于对第二密钥对的声明，因此需要在.ssh目录下添加config文件，添加语句dentityFile ~/.ssh/id_rsa_sql声明这是第二个密钥对。这条连接命令就体现出来了。 查看用户名git config user.name git config user.email 修改用户名git config --global user.name &quot;xxx&quot; git config --global user.email &quot;xxx&quot; 2、从远程项目拉取git clone 项目地址 3、提交代码到远程仓库常规操作 ##添加 git add . . #查看状态 git status # 提交 git commit -m &quot;代码描述&quot; # 再次查看状态 git status # 拉取最新代码 git pull # 提交 git push 4、git分支操作Git初始化 解决 fatal: Not a git repository (or any of the parent directories): .git 问题 git init git clone --- 克隆项目 JackFeng@JackFeng MINGW64 /d/Practice $ git clone git@github.com:MineData-SQL/SQL.git Cloning into &#39;SQL&#39;... remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 Receiving objects: 100% (3/3), done. 创建分支git branch &lt;branch_name&gt; #指定分支名称 git checkout -b [&quot;分支名&quot;] 查看分支git branch # 查看所有分支,* 号所属代表当前分支 git branch # 查看分支详情，包括分支指向得commitid及提交信息 切换分支git checkout &lt;branch_name&gt; #切换到指定分支 git checkout -b &lt;branch_name&gt; #创建并切换到指定分支 删除分支git branch -d &lt;branch_name&gt; .#删除一个干净的分支(即相对当前分支而言该分支没有新的提交记录) git branch -D &lt;branch_name&gt; .#强制删除一个分支，该分支有没有合并到当前分支的提交记录 注意：删除分支前都需要先切换到其他分支才能进行删除操作 分支恢复 思路：对于已经有提交记录的分支删除后，实际上只是删除指针，commit记录还保留，如果想恢复，需要使用git reflog查找该分支指向的 commitId，然后根据commitId创建新的分支 HEAD@&#123;1&#125; git reflog git branch &lt;branch_name&gt; &lt;hash_val&gt; #根据指定commit创建新分支 分支改名git branch -m &lt;branch_name&gt; newname JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two) $ git branch -m master-one master-O JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two) $ git branch master master-O * master-two 分支合并 git merge #将指定分支合并到当前分支如果两个分支没有产生分叉情况，那么会进行快速合并，即fast-forward方式，它并不会产生新的commitId，只是改变了指针的指向，产生分叉合并可能会有冲突情况。 示例： 合并master-O分支到master分支，此时合并为fast-forward方式 分支合并细节 git merge -ff -m &quot;msg&quot; #合并分支时禁用Fast forward模式 如果使用fast-forward方式进行分支合并，只是简单改变了分支指针，而不会产生新的commit记录。 为了保证合并数据的完整性，我们也可以在合并时指定不使用fast-forward方式，使用 --ff 选项。这样，在merge时就会生成一个新的commit，从日志上就可以看到分支合并记录了。 示例：我们在master-two分支上新增一次提交，然后合并到master分支上，git log查看最新一次的提交记录，显示的正是我们合并分支时的记录 git log --pretty=oneline -1 JackFeng@JackFeng MINGW64 /d/Practice/SQL (master) $ git checkout master-two Switched to branch &#39;master-two&#39; JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two) $ echo &quot; thank you for attention DataScience &quot; &gt;&gt; a2data.txt JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two) $ git add a2data.txt warning: LF will be replaced by CRLF in a2data.txt. The file will have its original line endings in your working directory JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two) $ git commit -m &quot; add file&quot; [master-two 59a8816] add file 1 file changed, 1 insertion(+) create mode 100644 a2data.txt JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two) $ git checkout master Switched to branch &#39;master&#39; Your branch is up to date with &#39;origin/master&#39;. JackFeng@JackFeng MINGW64 /d/Practice/SQL (master) $ git merge --ff -m &quot;meger master-two branch&quot; master-two Updating ab83ffb..59a8816 Fast-forward (no commit created; -m option ignored) a2data.txt | 1 + 1 file changed, 1 insertion(+) create mode 100644 a2data.txt JackFeng@JackFeng MINGW64 /d/Practice/SQL (master) $ git log --pretty=oneline -1 59a88161e630f0853b852946fddb6c7e787906fe (HEAD -&gt; master, master-two) add file 冲突解决 当对分叉分支进行合并时，如果两个分支都对同一文件进行了修改，那么合并时就有可能会产生冲突情况。 如果两个分支对同一文件的修改是有规律的，比如对不同地方的修改，那么git工具可以实现自动合并. 如果无法自动合并，则需要对冲突文件进行手动修改，修改完成后使用git add表示冲突已经解决，然后使用git commit进行提交 示例：在master分支上对两个文件进行修改提交. a2data.txt和*DataScience。 然后切换到master-O分支上对两个文件进行修改提交. 文件由于修改的是不同地方，所以自动合并。 我们查看DataScience文件的内容，==上面和下面的内容分别代表了不同分支的修改内容，将冲突标记去掉，然后内容根据需求进行恰当的修改，然后进行一次提交即完成了冲突的解决。 修改文件相同则会产生合并冲突 (merge conflict) master master-O 合并分支 分支同步 主要是 自己的分支与主分支保持同步。 步骤： 1、git remote add master &#103;&#105;&#116;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#x63;&#111;&#x6d;:A2Data/A2Data.github.io.git // 主分支master 2、 git branch -v 查看是否添加 3、git fetch master // 获取主分支的最新修改到本地 4、git merge master/master-O // 将master分支修改内容merge到本地个人分支； // 该步骤或者可以分成2步： 1） # git checkout master-O； // checkout到master-O分支 2） # git merge master； //合并主分支修改到本地master分支； 5、git push //本地分支提交到github上的个人分支 分支暂存 git stash #将工作暂存git stash list #列出所有的暂存状态 从暂存区之中进行恢复，有两种处理方式：1.先恢复，而后再删除暂存git stash applygit stash drop2.恢复的同时也将stash内容删除git stash pop 当我们在分支上进行代码开发时，有可能会接到突发需求，而当前的代码尚未完成，所以还**不能直接提交。** 为了解决这样的问题，git就提供了分支暂存的机制，可以将开发一半的分支进行保存，在适当的时候进行代码恢复。 示例：在master-two分支上新建文件，然后添加到暂存区表示尚未完成的任务，对当前分支进行暂存，git status显示工作空间是干净的。 欢迎关注","categories":[{"name":"Git","slug":"Git","permalink":"http://www.a2data.cn/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.a2data.cn/tags/Git/"}]},{"title":"带你玩转idea","slug":"Tools/带你玩转idea","date":"2020-03-31T14:51:10.000Z","updated":"2020-08-07T10:28:28.715Z","comments":true,"path":"posts/64846.html","link":"","permalink":"http://www.a2data.cn/posts/64846.html","excerpt":"IDEA 玩转详细教程","text":"IDEA 玩转详细教程 IDEA快捷键操作 颜色主题插件： **Material Theme UI Plugin ** 快捷键提醒： **Key Promoter X ** 查找Bug： QAPlig-FindBugs 热部署: JRebel 代码规范： Alibaba Java Coding Guidelines 字体推荐： Droid Sans Mono 代码检测：SonarLint(Sonarqube) 主题网站： http://www.riaway.com/index.php idea结合sonarLint进行的代码分析 idea结合sonar的话，可以下载sonarLint插件，操作步骤如下： 进入idea ，进入插件安装，在插件市场中搜索sonarLint，点击进行安装后重启idea； 配置sonarLint插件，设置settings中，查找到other settings,然后选择sonarLint General Setting ,在右侧的输入 接下来输入要连接的服务器的登录信息，如输入token或者是使用账号和密码的方式 配置当前的项目和sonar的关系,点击进入设置settings-&gt;other settings-&gt;SonarLint Project Settings Bind to Server 选择刚才配置的服务器信息。SonarQube project的选择可以点击Search in list查看sonar仓库中配置的项目信息，完成选择以后点击ok即可 代码分析，可以查看到当前的窗口中多了一个SonarLint的窗口（如无此窗口，可以点击analysis菜单进行查找），在其中选择report，点击文件夹图标，会弹窗提示，点击process之后即可进行项目分析。 JRebel 激活 GUIDS： https://www.guidgen.com/ 步骤： 步骤1:生成一个GUID：在线生成GUID地址 步骤2: 根据反向代理服务器地址拼接激活地址 服务器地址： https://jrebel.qekang.com/{GUID} Top1 循环.打印,Mainfori/sout/psvm+Tab 即可生成循环、System.out、main方法等boilerplate样板代码例如要输入for(User user : users)只需输入user.for+Tab 比如，要输入Date birthday = user.getBirthday(); 只需输入user.getBirthday().var+Tab即可。代码标签输入完成后，按Tab，生成代码。 Top2 类和包操作 Alt+Insert 生成代码(如get,set方法等) (右键 Generate） Ctrl+Alt+T 生成 try catch 或者 Alt+enter CTRL+ALT+T 把选中的代码放在 TRY{} IF{} ELSE{} 里 Ctrl + O 重写方法 Ctrl + I 实现方法 Ctr+shift+U 大小写转化 ALT+回车 导入包,自动修正 ALT+/ 代码提示 CTRL+空格 代码提示 CTRL+J 自动代码 Ctrl+Shift+J 整合两行为一行 CTRL+SHIFT+SPACE 自动补全代码 CTRL+ALT+L 格式化代码 CTRL+ALT+I 自动缩进 CTRL+ALT+O 优化导入的类和包 CTRL+E 最近更改的代码 CTRL+ALT+SPACE 类名或接口名提示 CTRL+P 方法参数提示 CTRL+Q 可以看到当前方法的声明 Shift+F6 重构-重命名 (包、类、方法、变量、甚至注释等) Ctrl+Alt+V 提取变量 Top3 查询快捷键 Ctrl＋Shift＋Backspace 可以跳转到上次编辑的地方 CTRL+ALT+ left/right 前后导航编辑过的地方 ALT+7 靠左窗口显示当前文件的结构 Ctrl+F12 浮动显示当前文件的结构 ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 CTRL+ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 Ctrl+Shift+Alt+N 查找类中的方法或变量 双击SHIFT 在项目的所有目录查找文件 Ctrl+N 查找类 Ctrl+Shift+N 查找文件 CTRL+G 定位行 CTRL+F 在当前窗口查找文本 CTRL+SHIFT+F 在指定窗口查找文本 CTRL+R 在 当前窗口替换文本 CTRL+SHIFT+R 在指定窗口替换文本 ALT+SHIFT+C 查找修改的文件 CTRL+E 最近打开的文件 F3 向下查找关键字出现位置 SHIFT+F3 向上一个关键字出现位置 选中文本，按Alt+F3 高亮相同文本，F3逐个往下查找相同文本 F4 查找变量来源 CTRL+SHIFT+O 弹出显示查找内容 Ctrl+W 选中代码 连续按会有其他效果 F2 或Shift+F2 高亮错误或警告快速定位 Ctrl+Up/Down 光标跳转到第一行或最后一行下 Ctrl+B 快速打开光标处的类或方法 CTRL+ALT+B 找所有的子类 CTRL+SHIFT+B 找变量的类 Ctrl+Shift+上下键 上下移动代码 Ctrl+Alt+ left/right 返回至上次浏览的位置 Ctrl+X 删除行 Ctrl+D 复制行 Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/…/） Ctrl+H 显示类结构图 Ctrl+Q 显示注释文档 Alt+F1 查找代码所在位置 Alt+1 快速打开或隐藏工程面板 Alt+ left/right 切换代码视图 ALT+ ↑/↓ 在方法间快速移动定位 CTRL+ALT+ left/right 前后导航编辑过的地方 Ctrl＋Shift＋Backspace 可以跳转到上次编辑的地 Alt+6 查找TODO Top4 其它快捷键 SHIFT+ENTER 另起一行 CTRL+Z 倒退(撤销) CTRL+SHIFT+Z 向前(取消撤销) CTRL+ALT+F12 资源管理器打开文件夹 ALT+F1 查找文件所在目录位置 SHIFT+ALT+INSERT 竖编辑模式 CTRL+F4 关闭当前窗口 Ctrl+Alt+V 可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+~ 快速切换方案（界面外观、代码风格、快捷键映射等菜单） Top5 svn快捷键 ctrl+k 提交代码到SVNctrl+t 更新代码 Top6 调试快捷键 常用的 F8 F7 F9 最值得一提的 就是 Drop Frame 可以让运行过的代码从头再来 alt+F8 debug时选中查看值 Alt+Shift+F9，选择 Debug Alt+Shift+F10，选择 Run Ctrl+Shift+F9，编译 Ctrl+Shift+F8，查看断点 F7，步入 Shift+F7，智能步入 Alt+Shift+F7，强制步入 F8，步过 Shift+F8，步出 Alt+Shift+F8，强制步过 Alt+F9，运行至光标处 Ctrl+Alt+F9，强制运行至光标处 F9，恢复程序 Alt+F10，定位到断点 Top7 重构 Ctrl+Alt+Shift+T，弹出重构菜单Shift+F6，重命名F6，移动F5，复制Alt+Delete，安全删除 Top8 Ctrl+Alt+N，内联Ø 命令： Ctrl+Shift+A 可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。 Ø 新建： Alt+Insert可以新建类、方法等任何东西。 Ø 格式化代码： 格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。 Ø 切换窗口： Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。 Ø 单元测试： Ctrl+Alt+T创建单元测试用例。 Ø 运行： Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。 Ø 调试： F7/F8/F9分别对应Step into，Step over，Continue。 Top9 自定义Ø 水平分屏 Ctrl+| 小功能Ctrl+Shift+V粘贴很早以前拷贝过的， Alt+Shift+Insert进入到列模式进行按列选中。 Ø切来切去： Ctrl+Tab Ø选你所想： Ctrl+W Ø代码生成： Template/Postfix +Tab Ø发号施令： Ctrl+Shift+A Ø无处藏身： Shift+Shift Ø自动完成： Ctrl+Shift+Enter Ø创造万物： Alt+Insert Top10 舍我其谁Ø智能补全： Ctrl+Shift+Space Ø自我修复： Alt+Enter Ø重构一切： Ctrl+Shift+Alt+T CTRL+ALT+ left/right 前后导航编辑过的地方Ctrl＋Shift＋Backspace可以跳转到上次编辑的地","categories":[{"name":"IDEA","slug":"IDEA","permalink":"http://www.a2data.cn/categories/IDEA/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://www.a2data.cn/tags/IDEA/"},{"name":"编码工具","slug":"编码工具","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A0%81%E5%B7%A5%E5%85%B7/"}]},{"title":"GitBook","slug":"Tools/GitBook","date":"2019-12-30T07:44:58.000Z","updated":"2020-08-07T10:29:19.186Z","comments":true,"path":"posts/44947.html","link":"","permalink":"http://www.a2data.cn/posts/44947.html","excerpt":"‘GitBook文档，安装使用’","text":"‘GitBook文档，安装使用’ GitBook1、安装 安装和使用GitBook 完成GitBook的安装只需要几分钟。 GitBook.com GitBook.com为您提供简单高效的图书在线撰写、发布和托管方案， 你可以通过 进行在线编辑、或者使用GitBook 本地编辑器在本地电脑上编辑。 本地安装 要求 GitBook的安装非常简单。 您的系统只需满足这两个要求： NodeJS（推荐使用v4.0.0及以上版本） Windows，Linux，Unix或Mac OS X 使用NPM安装 安装GitBook的最好方法是通过 NPM 安装。 在已经安装好NodeJS和NPM的电脑上，通过命令行窗口，输入以下命令安装GitBook： npm install gitbook-cli -g gitbook-cli 2、使用 创建一本书 gitbook init 如果你想用现有的目录来创建一本书，你可以通过运行 gitbook init ./directory来实现 使用下面的命令预览您创建的图书： gitbook serve 或者使用以下命令构建静态网站： gitbook build 安装其他版本gitbook命令可以方便地下载和安装不同版本的GitBook来测试你的书：$ gitbook fetch 4.0.0-alpha.1 使用gitbook ls-remote列出可用于安装的远程版本。 $ gitbook ls-remote Available GitBook Versions: 4.0.0-alpha.5, …部分省略…, 4.0.0-alpha.1, 3.2.2, 3.2.1, …部分省略…, 2.0.0-alpha.1 Tags: latest : 3.2.2 pre : 4.0.0-alpha.5 调试 您可以使用–log=debug和–debug来获得更详细的错误消息（堆栈跟踪）。例如： $ gitbook build ./ –log=debug –debug or $ gitbook serve ./ –log=debug –debug","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"GitBook","slug":"GitBook","permalink":"http://www.a2data.cn/tags/GitBook/"},{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"}]},{"title":"Python强化练习","slug":"Python/Python强化练习","date":"2019-12-30T07:43:39.000Z","updated":"2020-08-07T10:28:09.819Z","comments":true,"path":"posts/47220.html","link":"","permalink":"http://www.a2data.cn/posts/47220.html","excerpt":"Python学习阶段钱","text":"Python学习阶段钱 Python强化练习1、给程序传参数import sys print(sys.argv) 2、列表推导式 所谓的列表推导式，就是指的轻量级循环创建列表 2.1、基本的方式 请忽略手残的错误。。。 2.2、在循环的过程中使用if 2.3、2个for循环 2.4、3个for循环 2.5、练习 请写出一段 Python 代码实现分组一个 list 里面的元素,比如 [1,2,3,…100]变成 [[1,2,3],[4,5,6]….] 参考答案 3、set、list、tuple set是集合类型 set、list、tuple之间可以相互转换使用set，可以快速的完成对list中的元素去重复的功能","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"从零搭建ubuntu","slug":"Tools/从零搭建ubuntu","date":"2019-12-30T02:09:23.000Z","updated":"2020-08-07T10:28:22.881Z","comments":true,"path":"posts/48061.html","link":"","permalink":"http://www.a2data.cn/posts/48061.html","excerpt":"安装ubuntu、sublime骚操作","text":"安装ubuntu、sublime骚操作 Ubuntu系统1、虚拟机操作系统VMware Virtualbox 1、https://www.vmware.com/cn.html 2、https://www.virtualbox.org/ 2、小编哪个都玩得很溜此处采用 Virtualbox 原因是不用破解。 支持一下官方。 3、 下载ubuntu镜像 这里说明一下，官方下载贼慢。 https://ubuntu.com/download/desktop # 所以小编收集了一个镜像网站 比官网快NNN倍不止 http://mirrors.aliyun.com/ubuntu-releases/ #以及上传到自己的微云网盘，供大家使用。如有需要，请加小编微信。 4、万事具备开始安装 每一步都是截图，这样更加直观明了。 走你！！！ 5、ubuntu安装5.1、启动 5.2、选择语言 5.3、根据自己需求安装 5.4、选择地区 5.5、创建用户信息 6、安装完成重启 7、安装扩展组件 支持全屏，自定义大小。 双向拖动等。 Vmware 中安装的是 Tools 需要sudo ./ 执行解压的文件即可 Vbox 直接根据菜单操作安装即可。 8、Python 安装pip 9、安装sublime 对于Ubuntu 18.04及更高版本，只需打开Ubuntu软件搜索并安装sublime-text即可 对于Ubuntu 16.04，打开终端（Ctrl + Alt + T）并运行snap命令来安装： sudo apt install snapd &amp;&amp; sudo snap install sublime-text 1.通过Ctrl + Alt + T键盘快捷键或从应用程序启动器打开终端。 打开时，运行命令添加密钥环： wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add - 在提示时键入用户密码（无星号反馈），然后按Enter键。 2.然后运行命令添加apt存储库： echo “deb https://download.sublimetext.com/ apt/stable/“ | sudo tee /etc/apt/sources.list.d/sublime-text.list 3.最后通过Synaptic包管理器或运行命令安装sublime-text包： sudo apt update &amp;&amp; sudo apt install sublime-text 卸载：要删除编辑器，请运行命令：sudo apt remove –autoremove sublime-text要删除apt存储库，请转到“软件和更新” - &gt;“其他软件”。 10、玩转sublime 选择类Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 此功能很好。当你想同时修改多个相同代码的时候，比如，将echo 统一改成print，可以双击选中echo，然后Ctrl+D，会向下连选echo，重复，直到你满意的位置，然后就可以统一编辑了。 有人说了，这不就是查找替换呀，是的，查找替换是可以实现，但这种方式更直观一些，而且不易出错。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个例子：快速选中并更改所有相同的变量名、函数名等。Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。Ctrl+M 光标移动至括号内结束或开始的位置。Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。Ctrl+Shift+] 选中代码，按下快捷键，展开代码。Ctrl+K+0 展开所有折叠代码。Ctrl+← 向左单位性地移动光标，快速移动光标。Ctrl+→ 向右单位性地移动光标，快速移动光标。shift+↑ 向上选中多行。shift+↓ 向下选中多行。Shift+← 向左选中文本。Shift+→ 向右选中文本。Ctrl+Shift+← 向左单位性地选中文本。Ctrl+Shift+→ 向右单位性地选中文本。Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 编辑类Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。Ctrl+Shift+D 复制光标所在整行，插入到下一行。Tab 向右缩进。Shift+Tab 向左缩进。Ctrl+K+K 从光标处开始删除代码至行尾。Ctrl+Shift+K 删除整行。Ctrl+/ 注释单行。Ctrl+Shift+/ 注释多行。Ctrl+K+U 转换大写。Ctrl+K+L 转换小写。Ctrl+Z 撤销。Ctrl+Y 恢复撤销。Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。Ctrl+F2 设置书签Ctrl+T 左右字母互换。F6 单词检测拼写 搜索类Ctrl+F 打开底部搜索框，查找关键字。Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 显示类Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。Ctrl+PageDown 向左切换当前窗口的标签页。Ctrl+PageUp 向右切换当前窗口的标签页。Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字）Alt+Shift+2 左右分屏-2列Alt+Shift+3 左右分屏-3列Alt+Shift+4 左右分屏-4列Alt+Shift+5 等分4屏Alt+Shift+8 垂直分屏-2屏Alt+Shift+9 垂直分屏-3屏Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式Shift+F11 免打扰模式","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://www.a2data.cn/tags/Ubuntu/"}]},{"title":"MapReduce深入解析","slug":"Hadoop/MapReduce深入解析","date":"2019-12-27T03:04:21.000Z","updated":"2020-08-07T09:59:01.075Z","comments":true,"path":"posts/39508.html","link":"","permalink":"http://www.a2data.cn/posts/39508.html","excerpt":"MapReduce必备原理解析","text":"MapReduce必备原理解析 分布式计算框架MapReduce 1、概念 MapReduce是一个基于集群的计算平台，是一个简化分布式编程的计算框架，是一个将分布式计算抽象为Map和Reduce两个阶段的编程模型。（这句话记住了是可以用来装逼的） 2、执行流程 MapReduce程序执行图。 1. JobClient：运行于client node，负责将MapReduce程序打成Jar包存储到HDFS，并把Jar包的路径提交到Jobtracker，由Jobtracker进行任务的分配和监控。 2. JobTracker：运行于name node，负责接收JobClient提交的Job，调度Job的每一个子task运行于TaskTracker上，并监控它们，如果发现有失败的task就重新运行它。 3. TaskTracker：运行于data node，负责主动与JobTracker通信，接收作业，并直接执行每一个任务。 4. HDFS：用来与其它实体间共享作业文件。 MapReduce作业流程 1、JobClient通过RPC协议向JobTracker请求一个新应用的ID，用于MapReduce作业的ID 2、JobTracker检查作业的输出说明。例如，如果没有指定输出目录或目录已存在，作业就不提交，错误抛回给JobClient，否则，返回新的作业ID给JobClient 3、JobClient将作业所需的资源（包括作业JAR文件、配置文件和计算所得得输入分片）复制到以作业ID命名的HDFS文件夹中 4、JobClient通过submitApplication()提交作业 5、JobTracker收到调用它的submitApplication()消息后，进行任务初始化 6、JobTracker读取HDFS上的要处理的文件，开始计算输入分片，每一个分片对应一个TaskTracker 7、TaskTracker通过心跳机制领取任务（任务的描述信息） 8、TaskTracker读取HDFS上的作业资源（JAR包、配置文件等） 9、TaskTracker启动一个java child子进程，用来执行具体的任务（MapperTask或ReducerTask） 10、TaskTracker将Reduce结果写入到HDFS当中 3、工作原理 4、Map任务处理 1、读取HDFS中的文件。每一行解析成一个&lt;k,v&gt;。每一个键值对调用一次map函数 2、重写map()，对第一步产生的&lt;k,v&gt;进行处理，转换为新的&lt;k,v&gt;输出 3、对输出的key、value进行分区 4、对不同分区的数据，按照key进行排序、分组。相同key的value放到一个集合中 5、(可选) 对分组后的数据进行归约 5、Reduce任务处理 1、多个map任务的输出，按照不同的分区，通过网络复制到不同的reduce节点上 2、对多个map的输出进行合并、排序。 3、重写reduce函数实现自己的逻辑，对输入的key、value处理，转换成新的key、value输出 4、把reduce的输出保存到文件中","categories":[{"name":"大数据","slug":"大数据","permalink":"http://www.a2data.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"MapReduce","slug":"MapReduce","permalink":"http://www.a2data.cn/tags/MapReduce/"},{"name":"ApaHive","slug":"ApaHive","permalink":"http://www.a2data.cn/tags/ApaHive/"}],"author":"JackFeng"},{"title":"Python面向对象(4)","slug":"Python/Python面向对象-4","date":"2019-12-25T15:22:13.000Z","updated":"2020-08-07T10:28:00.474Z","comments":true,"path":"posts/55248.html","link":"","permalink":"http://www.a2data.cn/posts/55248.html","excerpt":"Python面向对象异常、模块","text":"Python面向对象异常、模块 Python面向对象(4)1、异常的传递1.1、try嵌套 首先从 test.txt 文件中读取到信息 ^c 关闭文件 没有这个文件 最后的finally 1.2、函数嵌套调用中 如果try嵌套，那么如果里面的try没有捕获到这个异常，那么外面的try会接收到这个异常，然后进行处理，如果外边的try依然没有捕获到，那么再进行传递。。。 如果一个异常是在一个函数中产生的，例如函数A—-&gt;函数B—-&gt;函数C,而异常是在函数C中产生的，那么如果函数C中没有对这个异常进行处理，那么这个异常会传递到函数B中，如果函数B有异常处理那么就会按照函数B的处理方式进行执行；如果函数B也没有异常处理，那么这个异常会继续传递，以此类推。。。如果所有的函数都没有处理，那么此时就会进行异常的默认处理，即通常见到的那样 注意观察上图中，当调用test3函数时，在test1函数内部产生了异常，此异常被传递到test3函数中完成了异常处理，而当异常处理完后，并没有返回到函数test1中进行执行，而是在函数test3中继续执行 2、抛出自定义的异常 可以用``raise`语句来引发一个异常。异常/错误对象必须有一个名字，且它们应是Error或Exception类的子类 以上程序中，关于代码#super().__init__()的说明 这一行代码，可以调用也可以不调用，建议调用，因为__init__方法往往是用来对创建完的对象进行初始化工作，如果在子类中重写了父类的__init__方法，即意味着父类中的很多初始化工作没有做，这样就不保证程序的稳定了，所以在以后的开发中，如果重写了父类的__init__方法，最好是先调用父类的这个方法，然后再添加自己的功能 3、异常处理中抛出异常 4、模块介绍4.1、模块 说的通俗点：模块就好比是工具包，要想使用这个工具包中的工具(就好比函数)，就需要导入这个模块 4.2、import 在python中主要是 用关键字，import 来引入某个模块， 在调用math模块中的函数时，必须这样引用： 模块名.函数名 import math #这样会报错 print sqrt(2) #这样才能正确输出结果 print math.sqrt(2) 4.3、from…import Python的from语句让你从模块中导入一个指定的部分到当前命名空间中 语法如下： from modname import name1[, name2[, ... nameN]] 例如，要导入模块fib的fibonacci函数，使用如下语句： from fib import fibonacci 注意 不会把整个fib模块导入到当前的命名空间中，它只会将fib里的fibonacci单个引入 4.4、from … import * 把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明： from modname import * 注意 这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。 4.5、 as 4.6、定位模块 当你导入一个模块，Python解析器对模块位置的搜索顺序是： 当前目录 如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。 如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/ 模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。 5、模块制作5.1、定义自己的模块 在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。比如有这样一个文件test.py，在test.py中定义了函数add #test.py def add(a,b): return a+b 5.2、调用自己定义的模块 那么在其他文件中就可以先import test，然后通过test.add(a,b)来调用了，当然也可以通过from test import add来引入 #test1.py import test result = test.add(66,22) print(result) 5.3、测试模块 在实际开中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在py文件中添加一些测试信息，例如： #test.py def add(a,b): return a+b # 用来进行测试 ret = add(123,543) print(&#39;int test.py file,,,,123+543=%d&#39;%ret) 如果此时，在其他py文件中引入了此文件的话，想想看，测试的那段代码是否也会执行呢！ #test1.py import test result = test.add(66,22) print(result) 6、模块中的_all_6.1、没有 6.2、有 7、使用Pip安装模块 pip 是 python 自带的一个软件，相当于手机里的应用市场，可以用来安装、卸载、搜索 python 的常见模块。 直接输入 pip 后回车，可以查看 pip 命令的所有可用参数。 7.1、安装模块在命令行执行 pip install 模块名 7.2、卸载模块在命令行执行 pip uninstall 模块名 7.3、搜索模块在命令行执行 pip search 模块名","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"Python面向对象(3)","slug":"Python/Python面向对象-3","date":"2019-12-25T13:08:42.000Z","updated":"2020-08-07T10:27:57.866Z","comments":true,"path":"posts/59346.html","link":"","permalink":"http://www.a2data.cn/posts/59346.html","excerpt":"Python面向对象单例模式","text":"Python面向对象单例模式 Python面向对象(3)1、_new_方法 __new__和__init__的作用 __new__至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供 __new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以return父类__new__出来的实例，或者直接是object的__new__出来的实例 __init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值 我们可以将类比作制造商，__new__方法就是前期的原材料购买环节，__init__方法就是在有原材料的基础上，加工，初始化商品环节 注意点 2、单例模式 单例模式： ​ 确保某一个类，只有一个实例，并且自行实例化向整个系统提供这个实例，这个类称为 单例类，单例模式 是一种对象创建型模式。 创建单例，保证只有1个对象 创建单例模式，只执行1次__init__方法 3、异常介绍异常简介 如下 说明: 打开一个不存在的文件123.txt，当找不到123.txt 文件时，就会抛出给我们一个IOError类型的错误，No such file or directory：123.txt （没有123.txt这样的文件或目录） 异常: 当Python检测到一个错误时，解释器就无法继续执行了，反而出现了一些错误的提示，这就是所谓的”异常” 4、捕获异常4.1、捕获异常(try..except…) 把可能出现问题的代码，放在try中 把处理异常的代码，放在except中 说明: 此程序看不到任何错误，因为用except 捕获到了IOError异常，并添加了处理的方法 pass 表示实现了相应的实现，但什么也不做；如果把pass改为print语句，那么就会输出其他信息 4.2、except捕获多个异常 想一想: 上例程序，已经使用except来捕获异常了，为什么还会看到错误的信息提示？ 答: except捕获的错误类型是IOError，而此时程序产生的异常为 NameError ，所以except没有生效 4.3、获取异常的信息描述 4.5、else 咱们应该对else并不陌生，在if中，它的作用是当条件不满足时执行的实行；同样在try…except…中也是如此，即如果没有捕获到异常，那么就执行else中的事情 4.6、try…finally… try…finally…语句用来表达这样的情况： 在程序中，如果一个段代码必须要执行，即无论异常是否产生都要执行，那么此时就需要使用finally。 比如文件关闭，释放锁，把数据库连接返还给连接池等 test.txt文件中每一行数据打印，但是我有意在每打印一行之前用time.sleep方法暂停2秒钟。这样做的原因是让程序运行得慢一些。在程序运行的时候，按Ctrl+c中断（取消）程序。 我们可以观察到KeyboardInterrupt异常被触发，程序退出。但是在程序退出之前，finally从句仍然被执行，把文件关闭。","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"Python面向对象(2)","slug":"Python/Python面向对象-2","date":"2019-12-23T14:59:23.000Z","updated":"2020-08-07T10:27:54.973Z","comments":true,"path":"posts/30675.html","link":"","permalink":"http://www.a2data.cn/posts/30675.html","excerpt":"Python面向对象介绍中篇","text":"Python面向对象介绍中篇 Python面向对象(2)1、保护对象的属性 如果有一个对象，当需要对其进行修改属性时，有两种方法 对象名.属性名 = 数据 —-&gt;直接修改 对象名.方法名() —-&gt;间接修改 为了更好的保存属性安全，即不能随意修改，一般的处理方式为 将属性定义为私有属性 添加一个可以调用的方法，供调用 私有共有属性区分 它是以属性命名方式来区分，如果在属性名前面加了2个下划线’__’，则表明该属性是私有属性，否则为公有属性（方法也是一样，方法名前面加了2个下划线的话表示该方法是私有的，否则为公有的）。 2、_del_()方法 当有1个变量保存了对象的引用时，此对象的引用计数就会加1 当使用del删除变量指向的对象时，如果对象的引用计数不会1，比如3，那么此时只会让这个引用计数减1，即变为2，当再次调用del时，变为1，如果再调用1次del，此时会真的把对象进行删除 3、单继承3.1、继承的概念 在程序中，继承描述的是事物之间的所属关系，例如猫和狗都属于动物，程序中便可以描述为猫和狗继承自动物；同理，波斯猫和巴厘猫都继承自猫，而沙皮狗和斑点狗都继承自狗，如下如所示： 3.2、继承示例 说明： 虽然子类没有定义__init__方法，但是父类有，所以在子类继承父类的时候这个方法就被继承了，所以只要创建Bosi的对象，就默认执行了那个继承过来的__init__方法 总结 子类在继承的时候，在定义类时，小括号()中为父类的名字 父类的属性、方法，会被继承给子类 3.3、注意点 私有的属性，不能通过对象直接访问，但是可以通过方法访问 私有的方法，不能通过对象直接访问 私有的属性、方法，不会被子类继承，也不能被访问 一般情况下，私有的属性、方法都是不对外公布的，往往用来做内部的事情，起到安全的作用 4、多继承 所谓多继承，即子类有多个父类，并且具有他们的特征 注意点 想一想: 如果在上面的多继承例子中，如果父类A和父类B中，有一个同名的方法，那么通过子类去调用的时候，调用哪个？ 5、重写与调用父类方法5.1、重写父类方法 所谓重写，就是子类中，有一个和父类相同名字的方法，在子类中的方法会覆盖掉父类中同名的方法 5.2、调用父类方法 6、多态 其实多态的概念，一般应用于Java这类强类型语言中， 而Python崇尚“鸭子类型” 所谓多态：定义时的类型和运行时的类型不一样，此时就成为多态 Python伪代码实现Java或C#的多态 鸭子类型 7、类、实例 | 属性7.1、类属性class People(object): name = &#39;A2Data&#39; #公有的类属性 __age = 22 #私有的类属性 p = People() print(p.name) #正确 print(People.name) #正确 print(p.__age) #错误，不能在类外通过实例对象访问私有的类属性 print(People.__age) #错误，不能在类外通过类对象访问私有的类属性 7.2、实例属性(对象属性)class People(object): address = &#39;北京&#39; #类属性 def __init__(self): self.name = &#39;A2Data&#39; #实例属性 self.age = 22 #实例属性 p = People() p.age =18 #实例属性 print(p.address) #正确 print(p.name) #正确 print(p.age) #正确 print(People.address) #正确 print(People.name) #错误 print(People.age) #错误 通过实例(对象)去修改类属性 class People(object): country = &#39;china&#39; #类属性 print(People.country) p = People() print(p.country) p.country = &#39;japan&#39; print(p.country) #实例属性会屏蔽掉同名的类属性 print(People.country) del p.country #删除实例属性 print(p.country) 归纳 如果需要在类外修改类属性，必须通过类对象去引用然后进行修改。如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，不会影响到类属性，并且之后如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性。 8、静态和类 | 方法8.1、类方法 类对象所拥有的方法，需要用修饰器@classmethod来标识其为类方法，对于类方法，第一个参数必须是类对象，一般以cls作为第一个参数（当然可以用其他名称的变量作为其第一个参数，但是大部分人都习惯以’cls’作为第一个参数的名字，就最好用’cls’了），能够通过实例对象和类对象去访问。 用类方法对类属性修改之后，通过类对象和实例对象访问都发生了改变 8.2、静态方法 需要通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"Python烤地瓜案例","slug":"Python/Python烤地瓜案例","date":"2019-12-23T04:26:20.000Z","updated":"2020-08-07T10:27:49.265Z","comments":true,"path":"posts/16550.html","link":"","permalink":"http://www.a2data.cn/posts/16550.html","excerpt":"Python烤地瓜实例解析","text":"Python烤地瓜实例解析 Python烤地瓜实例建议跟着操作，所以小编多数以截图的方式 为了更好的理解面向对象编程，下面以“烤地瓜”为案例，进行分析 定义地瓜类，存储烤熟的程度和添加的佐料，同时要提供烤地瓜和添加佐料的功能 1、分析属性事例方法 cook() : 把地瓜烤一段时间 addCondiments() : 给地瓜添加配料 __init__() : 设置默认的属性 __str__() : 让print的结果看起来更好一些 2、定义类并且测试 3、测试cook方法 4、自定义方法 5、完整代码 6、测试输出效果","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"Python面向对象(1)","slug":"Python/Python面向对象(1)","date":"2019-12-23T02:31:34.000Z","updated":"2020-08-07T10:28:03.622Z","comments":true,"path":"posts/34771.html","link":"","permalink":"http://www.a2data.cn/posts/34771.html","excerpt":"Python面向对象介绍上篇","text":"Python面向对象介绍上篇 Python面向对象1、面向对象介绍 思考 例如：你有一个想法，你要做一个项目。然后呢，你聚集了n个人，说明你要做啥，然后大家开始干。 根据小编的经验，这个项目肯定是失败的。 因为每个人做的事情很多，分工不明确，有些肯定到最后都是没人做的，所以问题来了，必须要进行分工， 哪些人搭架子，做什么。哪些负责哪一块。 例如：数一下如下字符串有多少个字符 a2datahelloworldwwwa2datacn a2data,helloworld,www,a2data,cn 显然，被分组后的字符更容易计数 总结： 大型的项目，必须要进行分工，将函数分为几个不同的类型，每个人负责一个或多个类型，比如一个人负责网站首页，一个人负责订单界面，一个人负责用户设置页面。 面向对象与面向过程 面向过程：根据业务逻辑从上到下写代码 面向对象：将数据与函数绑定到一起，分类进行封装，每个程序员只要负责分配给自己的分类，这样能够更快速的开发程序，减少了重复代码 对于小编而已，跟大家一样，刚开始都喜欢面向过程开发。其往往用一长段代码来实现指定功能，开发过程的思路是将数据与函数按照执行的逻辑顺序组织在一起，数据与函数分开考虑。 面向对象编程（Object Oriented Programming，OOP，面向对象程序设计） 解决吃啤酒鸭的问题 第一种方式（面向过程）: 1、养鸭子 2、鸭子长成 3、杀 4、作料 5、烹饪 6、吃 7、卒 第二种方式（面向对象）: 1、找个卖啤酒鸭的人 2、给钱 交易 3、吃 需要了解的定义性文字: 面向对象(object-oriented ;简称: OO) 至今还没有统一的概念 我这里把它定义为: 按人们 认识客观世界的系统思维方式,采用基于对象(实体)的概念建立模型,模拟客观世界分析、设 计、实现软件的办法。 面向对象编程(Object Oriented Programming-OOP) 是一种解决软件复用的设计和编程方法。 这种方法把软件系统中相近相似的操作逻辑和操作 应用数据、状态,以类的型式描述出来,以对象实例的形式在软件系统中复用,以达到提高软件开发效率的作用。 2、类和对象2.1、类 人以类聚 物以群分 具有相似内部状态和运动规律的实体的集合（抽象） 具有相同属性和行为事物的统称 类是抽象的，使用的时候，通常一个类可以找到多个对象。 例如：轮胎，汽车，飞机，推车..等等 2.2、对象 某一个具体事物的存在，现实中就是看得见摸得着的。 code: 可以直接使用的 2.3、类与对象的关系 类就是创建对象的模板 2.4、类的构成 类(Class) 由3个部分构成 类的名称:类名 类的属性:一组数据 类的方法:允许对进行操作的方法 (行为) 狗类的设计 类名:狗(Dog) 属性:品种 、毛色、性别、名字、 腿儿的数量 方法(行为/功能):叫 、跑、咬人、吃、摇尾巴 2.5、类的抽象 拥有相同(或者类似)属性和行为的对象都可以抽像出一个类 方法:一般名词都是类(名词提炼法) 3、定义类 定义一个类，格式如下： class 类名: 方法列表 说明： 定义类时有2种：新式类和经典类，如下的Car为经典类，如果是Car(object)则为新式类 类名 的命名规则按照”大驼峰” 4、创建对象python中，可以根据已经定义的类去创建出一个个对象 创建对象的格式为: 对象名 = 类名() 创建对象demo: # 定义类 class Car: # 移动 def move(self): print(&#39;车在奔跑...&#39;) # 鸣笛 def toot(self): print(&quot;车在鸣笛.....&quot;) # 创建一个对象，并用变量BMW来保存它的引用 BM = Car() BM.color = &#39;黑色&#39; BM.wheelNum = 4 #轮子数量 BM.move() BM.toot() print(BM.color) print(BM.wheelNum) 5、Self理解Self 所谓的self，可以理解为自己 某个对象调用其方法时，python解释器会把这个对象作为第一个参数传递给self，所以开发者只需要传递后面的参数即可 6、init6.1、使用方式def 类名: #初始化函数，用来完成一些默认的设定 def __init__(): pass 6.2、init()方法调用# 定义汽车类 class Car: def __init__(self): self.wheelNum = 4 self.color = &#39;蓝色&#39; def move(self): print(&#39;车在跑，目标:北京&#39;) # 创建对象 BM = Car() print(&#39;车的颜色为:%s&#39;%BM.color) print(&#39;车轮胎数量为:%d&#39;%BM.wheelNum) __init__()方法，在创建一个对象时默认被调用，不需要手动调用 __init__(self)中，默认有1个参数名字为self，如果在创建对象时传递了2个实参，那么__init__(self)中出了self作为第一个形参外还需要2个形参，例如__init__(self,x,y) __init__(self)中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递进去 7、“魔法”方法 定义 __str__() 方法 在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法 当使用print输出对象的时候，只要自己定义了__str__(self)方法，那么就会打印从在这个方法中return的数据","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"面试拆招详解","slug":"Tools/面试拆招详解","date":"2019-12-22T01:43:28.000Z","updated":"2020-08-07T10:28:41.533Z","comments":true,"path":"posts/9812.html","link":"","permalink":"http://www.a2data.cn/posts/9812.html","excerpt":"面试精选！！！","text":"面试精选！！！ 面试拆招1、请你自我介绍一下自己好吗? 回答提示:一般人回答这个问题过于平常,只说姓名、年龄、爰好、工作经验,这些在简历上都有。其实,企业最希望知道的是求职者能否胜任工作,包括:*最强的技能、最深研究的知识领域、个性中最积极的部分、做过的最成功的事、可以和学习无关,也可以和学习有关,但要突出积极的个性和做事的能力,说得合情合理企业才会相信。企业很重视一个人的礼貌,求职者要尊重考官,在回答每个问题之后都说一句“谢谢”,企业喜欢有礼貌的求职者。 2、你觉得你个性上最大的优点是什么? 回答提示: 沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱。我在xxxx经过一到两年的培训及项目实战,加上实习工作，使我适合这份工作。(此处根据自己情况而改) 3、说说你最大的缺点? 回答提示: 这个问题企业问的概率很大,通常不希望听到直回答的缺点是什么等,如果求职者说自己小心眼、爱忌妒非常懒、脾气大、工作效率低,企业肯定不会录用你绝对不要自作聪明地回答“我最大的缺点是过于追求完美”,有的人以为这样回答会显得自己比较出色,但事实上,他已经岌岌可危了。企业喜欢求职者从自己的优点说起,中间加一些小缺点,最后再把问题转回到优点上,突出优点的部分,企业喜欢聪明的求职者。 4、你对薪资的要求? 回答提示: 如果你对薪酬的要求太低,那显然贬低自己的能力;如果你对薪酣的要求太高,那又会显得你分量过重,公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算,因而他们第一次提出的价钱往往是他们所能给予的最高价钱,他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。 回答样本一: 我对工资没有硬性要求,我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会,所以只要条件公平,我则不会计较太多 回答祥本二: 我受过系统的软件编程的训练,不需要进行大量的培训,而且我本人也对编程特别感兴趣。因此,我希望公司能根据我的情况和市场标准的水平,给我合理的薪水 回答样本三: 如果你必须自己说出具体数目,请不要说一个宽泛的范围,那样你将只能得到最低限庋的数字。最好给出一个具体的数字,这样表明你已经对当今的人才市场作了调查,知道像自己这样学历的雇员有什么样的价值 5、你对加班的看法? 回答提示: 实际上好多公司问这个问题,并不证明一定要加班,只是想测试你是否愿意为公司奉献。 回答样本: 如果工作需要我会义不容辞加班,我现在单身没有任何家庭负担,可以全身心的投入工作。但同时我也会提高工作效率,减少不必要的加班。 6、如果通过这次面试我们录用了你,但工作一段时间却发现你根本不适合这个职位,你怎么办? 回答提示: 一段时间发现工作不适合我,有两种情况: ①如果你确实热爱这个职业,那你就要不断学习,虚心向领导和同事学习业务知识和处事经验,了解这个职业的精神内涵和职业要求,力争减少差距; ②你觉得这个职业可有可无,那还是趁早换个职业,去发现适合你的,你热爱的职业,那样你的发展前途也会大点,对单位和个人都有好处。 7、谈谈你对跳槽的看法? 回答提示: ①正常的“跳槽”能促进人才合理流动,应该支持。 ②频繁的跳槽对单位和个人双方都不利,应该反对。 8、工作中难以和同事、上司相处,你该怎么办? 回答提示: ①我会服从领导的指挥,配合同事的工作。 ②我会从自身找原因,仔鈿分析是不是自己工作做得不好让领导不满意,同事看不惯。还要看看是不是为人处世方面做得不好,如果是这样的话我会努力改正。 ③如果我找不到原因,我会找机会跟他们沟通,请他们指出我的不足,有问题就及时改正。 ④作为优秀的员工,应该时刻以大局为重,即使在段时间内,领导和同事对我不理解,我也会做好本职工作,虚心向他们学习,我相信,他们会看见我在努力,总有天会对我微笑的。 9、你对于我们公司了解多少? 回答提示: 在去公司面试前上网查一下该公司主营业务。如回答:贵公司有意改变策略,加强与国外大厂的QFM合作,自有品牌的部分则透过海外经销商. 10、最能慨括你自己的三个词是什么? 回答提示: 我经常用的三个词是:适应能力强,有责任心和做事有始终,结合具体例子向主考官解释。 11、你的业余爱好是什么? 回答提示: 找一些富于团体合作精神的,这里有一个真实的故事:有人被否决掉,因为他的爰好是深海潜水。主考官说:因为这是一项单人活动,我不敢肯定他能否适应团体工作 12、作为被面试者给我打一下分? 回答提示: 试着列出四个优点和一个非常非常非常小的缺点可以抱怨一下设施,没有明确责任人的缺点是不会有人介意的) 13、你为什么要离开原来的公司? 回答提示: ①回答这个问题时一定要小心,就算在前一个工作受到再大的委屈,对公司有多少的怨言,都千万不要表现出来,尤其要避免对公司本身主管的批评,避免面试官的负面情绪及印象。 建议此时最好的回答方式是将问题归咎在自己身上,例如觉得工作没有学习发展的空间,自己想在面试工作的相关产业中多加学习,或是前一份工作与自己的生涯规划不合等等,回答的答案最好是积极正面的。 ②我希望能获得一份更好的工作,如果机会来临,我会抓住。我觉得目前的工作,已经达到顶峰,即沒有升迁机会。 14、你欣赏哪种性格的人? 回答提示: 诚实、不死板而且容易相处的人、有“实际行动”的人。 15、你通常如何对待别人的批评? 回答提示: ①沈默是金,不必说什么,否则情况更糟,不过我会接受建设性的批评。 ②我会等大家冷靜下来再讨论。 16、怎样对待自己的失败? 回答提示: 我们大家生来都不是十全十美的,我相信我有第二个机会改正我的错误。 17、你为什么原意到我们公司来工作? 回答提示: 对于这个问题,你要格外小心,如果你已经对该单位作了研究,你可以回答一些详细的原因,像“公司本身的高技术开发环境很吸引我”,“我同公司出生在同样的时代,我希望能够进入一家与我共同成长的公司。”、“你们公司一直都稳定发展,在近几年来在市场上很有竞争力。”、“我认为贵公司能够给我禔供一个与众不同的发展道路。”这都显示出你已经做了一些调查,也说明你对自己的未来有了较为具体的远景规划。 18、对这项工作,你有哪些可预见的困难? 回答提示: ①不宜直接说出具体的困难,否则可能令对方怀疑应聘者不行。 ②可以尝试迂回战术,说出应聘者对困难所持有的态度一一工作中出现一些困难是正常的,也是难免的,但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备,任何困难都是可以克服。 19、如果录用了你,你将怎样开展工作? 回答提示: ①如果应聘者对于应聘的职位缺乏足够的了解,最好不要直接说出自己开展工作的具体办法。 ②可以尝试采迂回战术来回答,如“首先听取领导的指示和要求,然后就有关情况进行了解和熟悉,接下来制定一份近期的工作计划并报领导批准,最后根据计划开展工作。” 分析 这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性,而且重点想要知道细节。如果向思路中所讲灼迂回战术,面试官会认为回避问题,如果引导了几次仍是回避的话,此人绝对不会录用了。 20、你希望与什么样的上级共事? 回答提示: ①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识,这既是一个陷阱,又是一次机会。 ②最好回避对上级具体的希望,多谈对自己的要求。 ③如“做为刚步入社会的新人,我应该多要求自己尽快熟悉环境、适应环境,而不应该对环境提出什么要求,只要能发挥我的专长就可以了。 分析: 这个问题比较好的回答是,希望我的上级能够在工作中对我多指导,对我工作中的错误能够立即指出。总之，从上级指导这个方面谈,不会有大的纰漏 21、与上级意见不一时,你将怎么办? 回答提示: ①一般可以这样回答“我会给上级以必要的解释和提醒,在这种情况下,我会服从上级的意见。” ②如果面试你的是总经理,而你所应聘的职位另有一位经理,且这位理当时不在场,可以这样回答:“对于非原则性问题,我服从上级的意见,对于涉及公司利益的重大问题,我希望能向更高层领导反映” 分析: 这个问题的标准答案是思路①,如果用②的回答,必死无疑。你没有摸清楚改公司的内部情况,先想打小报告,这样的人没有人敢要。 22、为什么选择我们公司? 回答提示: 曾经在报章杂志看过关于贵公司的报道,与自己所追求的理念有志一同。而贵公司在业界的成绩也是有目共睹的,而且对员工的教育训练、升迁等世都很有制度。 分析: 去面试前先做功课,了解一下该公司的背景,让对方觉得你真的很有心想得到这份工作,而不只是探探路。 23、谈谈如何话应办公室工作的新环境? 回答提示: ①办公室里每个人有各自的岗位与职责,不得擅离岗位。 ②根据领导指示和工作安排,制定工作计划,提前预备,并按计划完成。 ③多请示并及时汇报,遇到不明白的要虚心请教。 ④抓间隙时间,多学习,努力提高自己的政治素质和业务水平 24、除了本公司外,还应聘了哪些公司 回答提示: 很奇怪,这是相当多公司会问的问题,其用意是要概略知道应徵者的求职志向,所以这并非绝对是负面答案,就算不便说出公司名称,也应回答“销售同种产品的公司”,如果应聘的其他公司是不同业界,容易让人产生无法信任的感觉。 25、你还有什么问题要问吗? 回答提示: 企业的这个问题看上去可有可无,其实很关键,企业不喜欢说“没问题”的人,因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题,如果有人这样问:贵公司对新入公司的员工有没有什么培训项目,我可以参加吗?或者说贵公司的晋升机制是什么样的?企业将很欢迎,因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。 26、如果你被录用,何时可以到职? 回答提示: 大多数企业会关心就职时间,最好是回答“如果被录用的话,到职日可按公司规定上班”,但如果还未辞去上一个工作、上班时间又太近,似乎有些强人所难,因为交接至少要一个月的时间,应进一步说明原因,录取公司应该会通融的。","categories":[{"name":"职场","slug":"职场","permalink":"http://www.a2data.cn/categories/%E8%81%8C%E5%9C%BA/"}],"tags":[{"name":"面经","slug":"面经","permalink":"http://www.a2data.cn/tags/%E9%9D%A2%E7%BB%8F/"}]},{"title":"Python文件操作及应用","slug":"Python/Python文件操作及应用","date":"2019-12-19T14:21:43.000Z","updated":"2020-08-07T10:28:12.634Z","comments":true,"path":"posts/8573.html","link":"","permalink":"http://www.a2data.cn/posts/8573.html","excerpt":"Python的基础语法","text":"Python的基础语法 Python文件操作、应用1、文件操作介绍 文件是什么呢？ 文件的作用呢？ 大家应该听说过一句话：“好记性不如烂笔头”。 不仅人的大脑会遗忘事情，计算机也会如此，比如一个程序在运行过程中用了九牛二虎之力终于计算出了结果，试想一下如果不把这些数据存放起来，相比重启电脑之后，“哭都没地方哭了” 相信很多做ps的朋友，深有体会 可见，在把数据存储起来有做么大的价值 使用文件的目的： 就是把一些存储存放起来，可以让程序下一次执行的时候直接使用，而不必重新制作一份，省时省力 2、文件的打开与关闭2.1、打开文件 在python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件 open(文件名，访问模式)示例如下： f = open(&#39;test.txt&#39;, &#39;w&#39;) 说明: 访问模式 说明 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 2.2、关闭文件 close( ) 示例如下： # 新建一个文件，文件名为:test.txt f = open(&#39;test.txt&#39;, &#39;w&#39;) # 关闭这个文件 f.close() 3、文件读写3.1、写文件(write) 注意： 如果文件不存在那么创建，如果存在那么就先清空，然后写入数据 3.2、读数据(read) 使用read(num)可以从文件中读取数据，num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据 3.3、读数据(readlines) 3.4、读数据(readline) 注意： 如果open是打开一个文件，那么可以不用写打开的模式，即只写 open(&#39;text.txt&#39;) 如果使用读了多次，那么后面读取的数据是从上次读完后的位置开始的 3.5、文件定位读写3.5.1、获取当前读写的位置 在读写文件的过程中，如果想知道当前的位置，可以使用tell()来获取 # 打开一个已经存在的文件 f = open(&quot;test.txt&quot;, &quot;r&quot;) str = f.read(3) print &quot;读取的数据是 : &quot;, str # 查找当前位置 position = f.tell() print &quot;当前文件位置 : &quot;, position str = f.read(3) print &quot;读取的数据是 : &quot;, str # 查找当前位置 position = f.tell() print &quot;当前文件位置 : &quot;, position f.close() 3.5.2、定位到某个位置 如果在读写文件的过程中，需要从另外一个位置进行操作的话，可以使用seek() seek(offset, from)有2个参数 offset:偏移量 from:方向 0:表示文件开头 1:表示当前位置 2:表示文件末尾 demo:把位置设置为：从文件开头，偏移5个字节 # 打开一个已经存在的文件 f = open(&quot;test.txt&quot;, &quot;r&quot;) str = f.read(30) print &quot;读取的数据是 : &quot;, str # 查找当前位置 position = f.tell() print &quot;当前文件位置 : &quot;, position # 重新设置位置 f.seek(5,0) # 查找当前位置 position = f.tell() print &quot;当前文件位置 : &quot;, position f.close() demo:把位置设置为：离文件末尾，3字节处 # 打开一个已经存在的文件 f = open(&quot;test.txt&quot;, &quot;r&quot;) # 查找当前位置 position = f.tell() print &quot;当前文件位置 : &quot;, position # 重新设置位置 f.seek(-3,2) # 读取到的数据为：文件最后3个字节数据 str = f.read() print &quot;读取的数据是 : &quot;, str f.close() 4、制作文件备份 输入文件的名字，然后程序自动完成对文件的备份操作 5、文件、文件夹相关操作 有些时候，需要对文件进行重命名、删除等一些操作，python的os模块中都有这么功能 5.1、文件重命名 os模块中的rename()可以完成对文件的重命名操作 rename(需要修改的文件名, 新的文件名) import os os.rename(&quot;text.txt&quot;, &quot;test.txt&quot;) # 需要注意以下 5.2、删除文件 os模块中的remove()可以完成对文件的删除操作 remove(待删除的文件名) import os os.remove(&quot;text.txt&quot;) 5.3、创建文件夹import os os.mkdir(&quot;小风&quot;) 5.4、获取当前目录import os os.getcwd() 5.5、改变默认目录import os os.chdir(&quot;../&quot;) 5.6、获取目录列表import os os.listdir(&quot;./&quot;) 5.7、删除文件夹import os os.rmdir(&quot;小风&quot;) 6、批量修改文件名 例如，我们有很多文件，想批量修改，该怎么办呢？ # 批量在文件名前加前缀 import os funFlag = 1 # 1表示添加标志 2表示删除标志 folderName = &#39;./小风/&#39; # 获取指定路径的所有文件名字 dirList = os.listdir(folderName) # 遍历输出所有文件名字 for name in dirList: if funFlag == 1: newName = &#39;[A2Data出品-]&#39; + name elif funFlag == 2: num = len(&#39;[A2Data出品]-&#39;) newName = name[num:] print (newName) os.rename(folderName+name,folderName+newName)","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"Python函数(下)","slug":"Python/Python函数-下","date":"2019-12-19T00:29:40.000Z","updated":"2020-08-07T10:14:55.620Z","comments":true,"path":"posts/6275.html","link":"","permalink":"http://www.a2data.cn/posts/6275.html","excerpt":"Python函数介绍下篇","text":"Python函数介绍下篇 Python函数(下) 1、引用 在python中，值是靠引用来传递来的。 我们可以用id()来判断两个变量是否为同一个值的引用。 我们可以将id值理解为那块内存的地址标示。 &gt;&gt;&gt; a = 1 &gt;&gt;&gt; b = a &gt;&gt;&gt; id(a) 13033816 &gt;&gt;&gt; id(b) # 注意两个变量的id值相同 13033816 &gt;&gt;&gt; a = 2 &gt;&gt;&gt; id(a) # 注意a的id值已经变了 13033792 &gt;&gt;&gt; id(b) # b的id值依旧 13033816 &gt;&gt;&gt; a = [1, 2] &gt;&gt;&gt; b = a &gt;&gt;&gt; id(a) 139935018544808 &gt;&gt;&gt; id(b) 139935018544808 &gt;&gt;&gt; a.append(3) &gt;&gt;&gt; a [1, 2, 3] &gt;&gt;&gt; id(a) 139935018544808 &gt;&gt;&gt; id(b) # 注意a与b始终指向同一个地址 139935018544808 2、递归函数2.1、什么是递归函数 通过前面的学习知道一个函数可以调用其他函数。 如果一个函数在内部不调用其它的函数，而是自己本身的话，这个函数就是递归函数。 2.2、递归函数的作用 举个例子，我们来计算阶乘 n! = 1*2 * 3 * … * n 方案1： 阶乘的规律 1! = 1 2! = 2 × 1 = 2 × 1! 3! = 3 × 2 × 1 = 3 × 2! 4! = 4 × 3 × 2 × 1 = 4 × 3! ... n! = n × (n-1)! 方案2： 递归原理 3、匿名函数 用lambda关键词能创建小型匿名函数。这种函数得名于省略了用def声明函数的标准步骤。 lambda函数的语法只包含一个语句，如下： lambda [arg1 [,arg2,.....argn]]:expression 如下实例： sum = lambda arg1, arg2: arg1 + arg2 #调用sum函数 print &quot;Value of total : &quot;, sum( 10, 20 ) print &quot;Value of total : &quot;, sum( 20, 20 ) 以上实例输出结果： Value of total : 30 Value of total : 40 Lambda函数能接收任何数量的参数但只能返回一个表达式的值 匿名函数不能直接调用print，因为lambda需要一个表达式 应用场合 3.1函数作为参数传递 自己定义函数 &gt;&gt;&gt; def fun(a, b, opt): ... print &quot;a =&quot;, a ... print &quot;b =&quot;, b ... print &quot;result =&quot;, opt(a, b) ... &gt;&gt;&gt; fun(1, 2, lambda x,y:x+y) a = 1 b = 2 result = 3 作为内置函数的参数 3.2想一想，下面的数据如何指定按age或name排序？# A2Data制作 stus = [ &amp;#123;&quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:18&amp;#125;, &amp;#123;&quot;name&quot;:&quot;lisi&quot;, &quot;age&quot;:19&amp;#125;, &amp;#123;&quot;name&quot;:&quot;wangwu&quot;, &quot;age&quot;:17&amp;#125; ] 3.3 按name排序：&gt;&gt;&gt; stus.sort(key = lambda x:x[&#39;name&#39;]) &gt;&gt;&gt; stus [&amp;#123;&#39;age&#39;: 19, &#39;name&#39;: &#39;lisi&#39;&amp;#125;, &amp;#123;&#39;age&#39;: 17, &#39;name&#39;: &#39;wangwu&#39;&amp;#125;, &amp;#123;&#39;age&#39;: 18, &#39;name&#39;: &#39;zhangsan&#39;&amp;#125;] 3.4按age排序：&gt;&gt;&gt; stus.sort(key = lambda x:x[&#39;age&#39;]) &gt;&gt;&gt; stus [&amp;#123;&#39;age&#39;: 17, &#39;name&#39;: &#39;wangwu&#39;&amp;#125;, &amp;#123;&#39;age&#39;: 18, &#39;name&#39;: &#39;zhangsan&#39;&amp;#125;, &amp;#123;&#39;age&#39;: 19, &#39;name&#39;: &#39;lisi&#39;&amp;#125;] 4、函数使用注意事项4.1、自定义函数 1、无参数、无返回值 def 函数名(): 语句 2、无参数、有返回值 def 函数名(): 语句 return 需要返回的数值 注意: 一个函数到底有没有返回值，就看有没有return，因为只有return才可以返回数据 在开发中往往根据需求来设计函数需不需要返回值 函数中，可以有多个return语句，但是只要执行到一个return语句，那么就意味着这个函数的调用完成 3、有参数、无返回值 def 函数名(形参列表): 语句 注意： 在调用函数时，如果需要把一些数据一起传递过去，被调用函数就需要用参数来接收 参数列表中变量的个数根据实际传递的数据的多少来确定 4、有参数、有返回值 def 函数名(形参列表): 语句 return 需要返回的数值 5、函数名不能重复（如下所示） 4.2、调用函数 1、调用的方式为： 函数名([实参列表]) 2、调用时，到底写不写 实参 如果调用的函数 在定义时有形参，那么在调用的时候就应该传递参数 3、调用时，实参的个数和先后顺序应该和定义函数中要求的一致 4、如果调用的函数有返回值，那么就可以用一个变量来进行保存这个值 4.3、作用域 1、在一个函数中定义的变量，只能在本函数中用(局部变量) 2、在函数外定义的变量，可以在所有的函数中使用(全局变量)","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"author":"Jack风"},{"title":"Python函数(中)","slug":"Python/Python函数(中)","date":"2019-12-18T00:15:35.000Z","updated":"2020-08-07T10:27:43.026Z","comments":true,"path":"posts/30873.html","link":"","permalink":"http://www.a2data.cn/posts/30873.html","excerpt":"Python函数介绍中篇","text":"Python函数介绍中篇 Python函数(中)1、回顾函数应用 函数的嵌套应用 程序设计的思路，复杂问题分解为简单问题 Demo # 1.写一个函数打印一条直线 # 2.打印自定义行数的横线 # 打印一条 def printOneLine(): print(&quot;-&quot;*30) # 打印多条 def printNumLine(num): i = 0 # printOneLine 函数已经完成了打印横线的功能 # 只需要多次调用此函数即可 while i &lt; num: printOneLine() i+=1 # 调用 printNumLine(3) Demo1 1.写一个函数求三个数的和 2.写一个函数求三个数的平均值 # 求三个数的和 def sum3Number(a,b,c): return a+b+c #return的后面可以是数值，也可以是表达式 # 完成三个数的平均值 def average3Number(a,b,c): # 因为sum3Number函数已经完成3个数的求和 # 将接收到的3个数，当做实参传递即可 sumResult = sum3Number(a,b,c) aveResult = sumResult/3.0 return aveResult # 调用函数，完成对3个数求平均值 result = average3Number(11,2,55) print(&quot;average is %d&quot;%result) 2、局部变量 归纳分析 局部变量，就是在函数内部定义的变量 不同的函数，可以定义相同的名字的局部变量，但是各用个的不会产生影响 局部变量的作用，为了临时保存数据需要在函数中定义变量来进行存储，这就是它的作用 3、全局变量3.1、全局变量是什么？ 如果一个变量，既能在一个函数中使用，也能在其他的函数中使用，这样的变量就是全局变量 Demo # 定义全局变量 a = 100 def test1(): print(a) def test2(): print(a) # 调用函数 test1() test2() # 结果显而易见 100 100 3.2、全局和局部变量名一致的情况 3.3、修改全局变量 3.4、可变类型的全局变量&gt;&gt;&gt; a = 1 &gt;&gt;&gt; def f(): ... a += 1 ... print a ... &gt;&gt;&gt; f() Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 2, in f UnboundLocalError: local variable &#39;a&#39; referenced before assignment &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; li = [1,] &gt;&gt;&gt; def f2(): ... li.append(1) ... print li ... &gt;&gt;&gt; f2() [1, 1] &gt;&gt;&gt; li [1, 1] 3.5、 归纳总结 在函数外边定义的变量叫做全局变量 全局变量能够在所有的函数中进行访问 如果在函数中修改全局变量，那么就需要使用global进行声明，否则出错 如果全局变量的名字和局部变量的名字相同，那么使用的是局部变量的，小技巧强龙不压地头蛇 在函数中不使用global声明全局变量时不能修改全局变量的本质是不能修改全局变量的指向，即不能将全局变量指向新的数据。 对于不可变类型的全局变量来说，因其指向的数据不能修改，所以不使用global时无法修改全局变量。 对于可变类型的全局变量来说，因其指向的数据可以修改，所以不使用global时也可修改全局变量。 4、函数返回值 在python中我们可不可以返回多个值？ 本质是利用了元组 &gt;&gt;&gt; def divid(a, b): ... shang = a//b ... yushu = a%b ... return shang, yushu ... &gt;&gt;&gt; sh, yu = divid(5, 2) &gt;&gt;&gt; sh 5 &gt;&gt;&gt; yu 1 5、函数参数5.1、 缺省参数 调用函数时，缺省参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入： def printinfo( name, age = 35 ): # 打印任何传入的字符串 print &quot;Name: &quot;, name print &quot;Age &quot;, age # 调用printinfo函数 printinfo(name=&quot;miki&quot; ) printinfo( age=9,name=&quot;miki&quot; ) 以上实例输出结果： Name: miki Age 35 Name: miki Age 9 注意：带有默认值的参数一定要位于参数列表的最后面。&gt;&gt;&gt; def printinfo(name, age=35, sex): ... print name ... File &quot;&lt;stdin&gt;&quot;, line 1 SyntaxError: non-default argument follows default argument 5.2、不定长参数 有时可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，声明时不会命名。 基本语法如下： def functionname([formal_args,] *args, **kwargs): &quot;函数_文档字符串&quot; function_suite return [expression] 加了星号（*）的变量args会存放所有未命名的变量参数，args为元组；而加**的变量kwargs会存放命名参数，即形如key=value的参数， kwargs为字典。 &gt;&gt;&gt; def fun(a, b, *args, **kwargs): ... &quot;&quot;&quot;可变参数演示示例&quot;&quot;&quot; ... print &quot;a =&quot;, a ... print &quot;b =&quot;, b ... print &quot;args =&quot;, args ... print &quot;kwargs: &quot; ... for key, value in kwargs.items(): ... print key, &quot;=&quot;, value ... &gt;&gt;&gt; fun(1, 2, 3, 4, 5, m=6, n=7, p=8) # 注意传递的参数对应 a = 1 b = 2 args = (3, 4, 5) kwargs: p = 8 m = 6 n = 7 &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; c = (3, 4, 5) &gt;&gt;&gt; d = &amp;#123;&quot;m&quot;:6, &quot;n&quot;:7, &quot;p&quot;:8&amp;#125; &gt;&gt;&gt; fun(1, 2, *c, **d) # 注意元组与字典的传参方式 a = 1 b = 2 args = (3, 4, 5) kwargs: p = 8 m = 6 n = 7 &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; fun(1, 2, c, d) # 注意不加星号与上面的区别 a = 1 b = 2 args = ((3, 4, 5), &amp;#123;&#39;p&#39;: 8, &#39;m&#39;: 6, &#39;n&#39;: 7&amp;#125;) kwargs: &gt;&gt;&gt; &gt;&gt;&gt; 5.3、引用传参 可变类型与不可变类型的变量分别作为函数参数时，会有什么不同吗？ Python有没有类似C语言中的指针传参呢？ &gt;&gt;&gt; def selfAdd(a): ... &quot;&quot;&quot;自增&quot;&quot;&quot; ... a += a ... &gt;&gt;&gt; a_int = 1 &gt;&gt;&gt; a_int 1 &gt;&gt;&gt; selfAdd(a_int) &gt;&gt;&gt; a_int 1 &gt;&gt;&gt; a_list = [1, 2] &gt;&gt;&gt; a_list [1, 2] &gt;&gt;&gt; selfAdd(a_list) &gt;&gt;&gt; a_list [1, 2, 1, 2] Python中函数参数是引用传递（注意不是值传递）。对于不可变类型，因变量不能修改，所以运算不会影响到变量自身；而对于可变类型来说，函数体中的运算有可能会更改传入的参数变量。 想一想为什么&gt;&gt;&gt; def selfAdd(a): ... &quot;&quot;&quot;自增&quot;&quot;&quot; ... a = a + a # 我们更改了函数体的这句话 ... &gt;&gt;&gt; a_int = 1 &gt;&gt;&gt; a_int 1 &gt;&gt;&gt; selfAdd(a_int) &gt;&gt;&gt; a_int 1 &gt;&gt;&gt; a_list = [1, 2] &gt;&gt;&gt; a_list [1, 2] &gt;&gt;&gt; selfAdd(a_list) &gt;&gt;&gt; a_list [1, 2] # 想一想为什么没有变呢？","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"Python函数(上)","slug":"Python/Python函数(上)","date":"2019-12-14T03:40:19.000Z","updated":"2020-08-07T10:27:40.258Z","comments":true,"path":"posts/34946.html","link":"","permalink":"http://www.a2data.cn/posts/34946.html","excerpt":"Python函数介绍上篇","text":"Python函数介绍上篇 Python函数(上)1、什么是函数 如过在开发程序时，需要某块代码使用多次，但是为了提高编写的效率以及代码的复用。 将具有独立功能的代码块组织为一个小模块—-&gt;函数 2、函数的定义和调用2.1、定义函数 格式如下： def 函数名(): 代码 定义一个函数打印信息 def printinfo(): print (&#39;-&#39;*21) print(&#39;--人生苦短，我用Python--&#39;) print(&#39;-&#39;*21) 2.2、调用函数 定义函数之后，就相当于具备一些功能的代码块，想要这些代码执行，就需要调用函数。 （定义函数后，函数不会自动执行的）如何调用呢？ 函数名（） 2.3、动动手 定义一个函数，能够输出自己的姓名和年龄，并且调用这个函数让它执行！ 使用def 定义函数 编写函数完成之后，通过 函数名（）调用 2.4、函数的文档说明&gt;&gt;&gt; def test(a,b): ... &quot;用来完成对2个数求和&quot; ... print(&quot;%d&quot;%(a+b)) ... &gt;&gt;&gt; &gt;&gt;&gt; test(11,22) 33 如果执行，以下代码 &gt;&gt;&gt; help(test) 能够看到test函数的相关说明 Help on function test in module __main__: test(a, b) 用来完成对2个数求和 (END) 3、函数参数3.1、定义带有参数的函数def addnum(a,b): c =a+b print (c) 3.2、调用带参函数# 调用带有参数的函数时，需要在小括号中，传递数据 addnum(12,28) 3.3、参数练习题 要求：定义一个函数，完成前2个数完成加法运算，然后对第3个数，进行减法；然后调用这个函数 使用def定义函数，要注意有3个参数 调用的时候，这个函数定义时有几个参数，那么就需要传递几个参数 3.4、调用函数时参数的顺序&gt;&gt;&gt; def test(a,b): ... print(a,b) ... &gt;&gt;&gt; test(1,2) 1 2 &gt;&gt;&gt; test(b=1,a=2) 2 1 &gt;&gt;&gt; &gt;&gt;&gt; test(b=1,2) File &quot;&lt;stdin&gt;&quot;, line 1 SyntaxError: positional argument follows keyword argument &gt;&gt;&gt; 3.5、总结 定义时小括号中的参数，用来接收参数用的，称为 “形参” 调用时小括号中的参数，用来传递给函数用的，称为 “实参” 4、返回值 所谓“返回值”，就是程序中函数完成一件事情后，最后给调用者的结果 4.1、返回值的函数 想要在函数中把结果返回给调用者，需要在函数中使用return 如下示例 def add2num(a, b): c = a+b return c 或者 def add2num(a, b): return a+b 4.2、保存函数的返回值 #定义函数 def add2num(a, b): return a+b #调用函数，顺便保存函数的返回值 result = add2num(100,98) #因为result已经保存了add2num的返回值，所以接下来就可以使用了 print result 结果 198 5、函数的类型 根据有没有参数，有没有返回值，可以互相结合，一共有4种 无参数，无返回值 无参数，有返回值 有参数，无返回值 有参数，有返回值 5.1、无参数，无返回值 此类函数，不能接收参数，也没有返回值，一般情况下，打印提示灯类似的功能，使用这类的函数 def printMenu(): print(&#39;-----------&#39;) print(&quot;欢迎关注A2Data&quot;) 5.2、无参数，有返回值 此类函数，不能接收参数，但是可以返回某个数据，一般情况下，像采集数据，用此类函数 # 获取温度 def getTemperature(): #这里是获取温度的一些处理过程 #为了简单起见，先模拟返回一个数据 return 24 temperature = getTemperature() print(&#39;当前的温度为:%d&#39;%temperature) 5.3、有参数，无返回值 此类函数，能接收参数，但不可以返回数据，一般情况下，对某些变量设置数据而不需结果时，用此类函数 5.4、有参数，又返回值 此类函数，不仅能接收参数，还可以返回某个数据，一般情况下，像数据处理并需要结果的应用，用此类函数 # 计算1~num的累积和 def calculateNum(num): result = 0 i = 1 while i&lt;=num: result = result + i i+=1 return result result = calculateNum(100) print(&#39;1~100的累积和为:%d&#39;%result) 结果 1~100的累积和为: 5050 5.5、小归纳 函数根据有没有参数，有没有返回值可以相互组合 定义函数时，是根据实际的功能需求来设计的，所以不同开发人员编写的函数类型各不相同 6、函数的嵌套调用","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"python元组与字典","slug":"Python/python元组与字典","date":"2019-12-13T00:48:16.000Z","updated":"2020-08-07T10:28:18.493Z","comments":true,"path":"posts/520.html","link":"","permalink":"http://www.a2data.cn/posts/520.html","excerpt":"Python的元组与字典","text":"Python的元组与字典 元组 Python的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。 &gt;&gt;&gt; aTuple = (&#39;a2data&#39;,66,99.9) &gt;&gt;&gt; aTuple (&#39;a2data&#39;,66,99.9) 1、访问元组 2、修改元组 说明： python中不允许修改元组的数据，包括不能删除其中的元素。 3、元组的内置函数count, index index和count与字符串和列表中的用法相同 &gt;&gt;&gt; a = (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;) &gt;&gt;&gt; a.index(&#39;a&#39;, 1, 3) # 注意是左闭右开区间 Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; ValueError: tuple.index(x): x not in tuple &gt;&gt;&gt; a.index(&#39;a&#39;, 1, 4) 3 &gt;&gt;&gt; a.count(&#39;b&#39;) 2 &gt;&gt;&gt; a.count(&#39;d&#39;) 0 字典 字典介绍 定义字典 获取字典数据(键、get) 想一想： 如果有列表 nameList = [&#39;a2data&#39;, &#39;a2data1&#39;, &#39;a2data2&#39;]; 需要对”xiaoWang”这个名字写错了，通过代码修改： nameList[1] = &#39;a2data112&#39; 如果列表的顺序发生了变化，如下 nameList = [&#39;a2data&#39;, &#39;a2data2&#39;, &#39;a2data112&#39;]; 此时就需要修改下标，才能完成名字的修改 nameList[2] = &#39;a2data112&#39; 有没有方法，既能存储多个数据，还能在访问元素的很方便就能够定位到需要的那个元素呢？ 答： 字典 另一个场景： 学生信息列表，每个学生信息包括学号、姓名、年龄等，如何从中找到某个学生的信息？ &gt;&gt;&gt; studens = [[1001, &quot;王宝强&quot;, 24], [1002, &quot;马蓉&quot;, 23], [1005, &quot;宋喆&quot;，24], ...] 循环遍历？ No！ 0、根据键访问值 info = &amp;#123;&#39;name&#39;:&#39;班长&#39;, &#39;id&#39;:100, &#39;sex&#39;:&#39;f&#39;, &#39;address&#39;:&#39;地球亚洲中国北京&#39;&amp;#125; print(info[&#39;name&#39;]) print(info[&#39;address&#39;]) 结果: 班长 地球亚洲中国北京 若访问不存在的键，则会报错： &gt;&gt;&gt; info[&#39;age&#39;] Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; KeyError: &#39;age&#39; 在我们不确定字典中是否存在某个键而又想获取其值时，可以使用get方法，还可以设置默认值： &gt;&gt;&gt; age = info.get(&#39;age&#39;) &gt;&gt;&gt; age #&#39;age&#39;键不存在，所以age为None &gt;&gt;&gt; type(age) &lt;type &#39;NoneType&#39;&gt; &gt;&gt;&gt; age = info.get(&#39;age&#39;, 18) # 若info中不存在&#39;age&#39;这个键，就返回默认值18 &gt;&gt;&gt; age 18 1、常见操作11.1、查看元素除了使用key查找数据，还可以使用get来获取数据 1.2、修改元素字典的每个元素中的数据是可以修改的，只要通过key找到，即可修改 1.3、添加元素访问不存在的元素 如果在使用 变量名[‘键’] = 数据 时，这个“键”在字典中，不存在，那么就会新增这个元素 添加新的元素 1.4、删除元素对字典进行删除操作，有一下几种： del clear() del 删除指定的元素 del 删除整个字典 clear 清空整个字典 info = &amp;#123;&#39;name&#39;:&#39;a2data&#39;, &#39;sex&#39;:&#39;f&#39;, &#39;address&#39;:&#39;China&#39;&amp;#125; print(&#39;清空前,%s&#39;%info) info.clear() print(&#39;清空后,%s&#39;%info) 2、常见操作22.1、len() 测量字典中，键值对的个数 2.2、keys 返回一个包含字典所有KEY的列表 2.3、values 返回一个包含字典所有value的列表 2.4、items 返回一个包含所有（键，值）元祖的列表 2.5、has_key dict.has_key(key)如果key在字典中，返回True，否则返回False 在python3之后删除了这个方法。 contains(key) 3、字典遍历 通过for … in …:的语法结构，我们可以遍历字符串、列表、元组、字典等数据结构。 注意python语法的缩进 3.1、字符串遍历&gt;&gt;&gt; a_str = &quot;hello itcast&quot; &gt;&gt;&gt; for char in a_str: ... print(char,end=&#39; &#39;) ... h e l l o i t c a s t 3.2、列表遍历&gt;&gt;&gt; a_list = [1, 2, 3, 4, 5] &gt;&gt;&gt; for num in a_list: ... print(num,end=&#39; &#39;) ... 1 2 3 4 5 3.3、元组遍历&gt;&gt;&gt; a_turple = (1, 2, 3, 4, 5) &gt;&gt;&gt; for num in a_turple: ... print(num,end=&quot; &quot;) 1 2 3 4 5 3.4字典遍历3.4.1、key（键） 3.4.2、value（值） 3.4.3、项（元素） 3.4.4、 key-value（键值对） 想一想，如何实现带下标索引的遍历 &gt;&gt;&gt; chars = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] &gt;&gt;&gt; i = 0 &gt;&gt;&gt; for chr in chars: ... print(&quot;%d %s&quot;%(i, chr)) ... i += 1 ... 0 a 1 b 2 c 3 d enumerate() &gt;&gt;&gt; chars = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] &gt;&gt;&gt; for i, chr in enumerate(chars): ... print i, chr ... 0 a 1 b 2 c 3 d 4、公共方法4.1、运算符 运算符 Python 表达式 结果 描述 支持的数据类型 + [1, 2] + [3, 4] [1, 2, 3, 4] 合并 字符串、列表、元组 * ‘Hi!’ * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 复制 字符串、列表、元组 in 3 in (1, 2, 3) True 元素是否存在 字符串、列表、元组、字典 not in 4 not in (1, 2, 3) True 元素是否不存在 字符串、列表、元组、字典 +&gt;&gt;&gt; &quot;hello &quot; + &quot;a2data&quot; &#39;hello a2data&#39; &gt;&gt;&gt; [1, 2] + [3, 4] [1, 2, 3, 4] &gt;&gt;&gt; (&#39;a&#39;, &#39;b&#39;) + (&#39;c&#39;, &#39;d&#39;) (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;) *&gt;&gt;&gt; &#39;ab&#39;*4 &#39;ababab&#39; &gt;&gt;&gt; [1, 2]*4 [1, 2, 1, 2, 1, 2, 1, 2] &gt;&gt;&gt; (&#39;a&#39;, &#39;b&#39;)*4 (&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;) in&gt;&gt;&gt; &#39;a2&#39; in &#39;hello a2data&#39; True &gt;&gt;&gt; 3 in [1, 2] False &gt;&gt;&gt; 4 in (1, 2, 3, 4) True &gt;&gt;&gt; &quot;name&quot; in &amp;#123;&quot;name&quot;:&quot;小风&quot;, &quot;age&quot;:24&amp;#125; True 注意，in在对字典操作时，判断的是字典的键 4.2、python内置函数 Python包含了以下内置函数 Python3 使用 import operator 序号 方法 描述 1 cmp(item1, item2) 比较两个值 2 len(item) 计算容器中元素个数 3 max(item) 返回容器中元素最大值 4 min(item) 返回容器中元素最小值 5 del(item) 删除变量 cmp&gt;&gt;&gt; cmp(&quot;hello&quot;, &quot;a2data&quot;) -1 &gt;&gt;&gt; cmp(&quot;a2data&quot;, &quot;hello&quot;) 1 &gt;&gt;&gt; cmp(&quot;a2data&quot;, &quot;a2data&quot;) 0 &gt;&gt;&gt; cmp([1, 2], [3, 4]) -1 &gt;&gt;&gt; cmp([1, 2], [1, 1]) 1 &gt;&gt;&gt; cmp([1, 2], [1, 2, 3]) -1 &gt;&gt;&gt; cmp(&amp;#123;&quot;a&quot;:1&amp;#125;, &amp;#123;&quot;b&quot;:1&amp;#125;) -1 &gt;&gt;&gt; cmp(&amp;#123;&quot;a&quot;:2&amp;#125;, &amp;#123;&quot;a&quot;:1&amp;#125;) 1 &gt;&gt;&gt; cmp(&amp;#123;&quot;a&quot;:2&amp;#125;, &amp;#123;&quot;a&quot;:2, &quot;b&quot;:1&amp;#125;) -1 注意：cmp在比较字典数据时，先比较键，再比较值。 len&gt;&gt;&gt; len(&quot;hello a2data&quot;) 12 &gt;&gt;&gt; len([1, 2, 3, 4]) 4 &gt;&gt;&gt; len((3,4)) 2 &gt;&gt;&gt; len(&amp;#123;&quot;a&quot;:1, &quot;b&quot;:2&amp;#125;) 2 注意：len在操作字典数据时，返回的是键值对个数。 max&gt;&gt;&gt; max(&quot;hello a2data&quot;) &#39;t&#39; &gt;&gt;&gt; max([1,4,522,3,4]) 522 &gt;&gt;&gt; max(&amp;#123;&quot;a&quot;:1, &quot;b&quot;:2&amp;#125;) &#39;b&#39; &gt;&gt;&gt; max(&amp;#123;&quot;a&quot;:10, &quot;b&quot;:2&amp;#125;) &#39;b&#39; &gt;&gt;&gt; max(&amp;#123;&quot;c&quot;:10, &quot;b&quot;:2&amp;#125;) &#39;c&#39; del del有两种用法，一种是del加空格，另一种是del() &gt;&gt;&gt; a = 1 &gt;&gt;&gt; a 1 &gt;&gt;&gt; del a &gt;&gt;&gt; a Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; NameError: name &#39;a&#39; is not defined &gt;&gt;&gt; a = [&#39;a&#39;, &#39;b&#39;] &gt;&gt;&gt; del a[0] &gt;&gt;&gt; a [&#39;b&#39;] &gt;&gt;&gt; del(a) &gt;&gt;&gt; a Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; NameError: name &#39;a&#39; is not defined 4.3、多维列表/元祖访问的示例&gt;&gt;&gt; tuple1 = [(2,3),(4,5)] &gt;&gt;&gt; tuple1[0] (2, 3) &gt;&gt;&gt; tuple1[0][0] 2 &gt;&gt;&gt; tuple1[0][2] Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; IndexError: tuple index out of range &gt;&gt;&gt; tuple1[0][1] 3 &gt;&gt;&gt; tuple1[2][2] Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; IndexError: list index out of range &gt;&gt;&gt; tuple2 = tuple1+[(3)] &gt;&gt;&gt; tuple2 [(2, 3), (4, 5), 3] &gt;&gt;&gt; tuple2[2] 3 &gt;&gt;&gt; tuple2[2][0] Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: &#39;int&#39; object is not subscriptable","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"Python列表介绍","slug":"Python/Python列表介绍","date":"2019-12-12T00:35:16.000Z","updated":"2020-08-07T10:14:55.587Z","comments":true,"path":"posts/58489.html","link":"","permalink":"http://www.a2data.cn/posts/58489.html","excerpt":"Python列表介绍","text":"Python列表介绍 Python列表解析章节1、列表介绍想一想： 前面学习的字符串可以用来存储一串信息，那么想一想，怎样存储公号所有粉丝的名字呢？ 定义100个变量，每个变量存放一个粉丝的姓名可行吗？有更好的办法吗？ 答： 列表 1.1、列表的格式变量A的类型为列表 namesList = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;] 比C语言的数组强大的地方在于列表中的元素可以是不同类型的 testList = [1, &#39;a&#39;] 1.2、打印列表demo: namesList = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;] print(namesList[0]) print(namesList[1]) print(namesList[2]) 结果： a2data a2data1 a2data2 2、列表的循环2.1、 使用for循环 为了更有效率的输出列表的每个数据，可以使用循环来完成 demo: namesList = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;] for name in namesList: print(name) 结果: a2data a2data1 a2data 2.2、 使用while循环为了更有效率的输出列表的每个数据，可以使用循环来完成 demo: namesList = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;] length = len(namesList) i = 0 while i&lt;length: print(namesList[i]) i+=1 结果: a2data a2data1 a2data2 3、列表的常见操作 列表中存放的数据是可以进行修改的，比如”增”、”删”、”改”、”查” 3.1、添加元素 (“增”append, extend, insert) append通过append可以向列表添加元素 demo: #定义变量A，默认有3个元素 A = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;] print(&quot;-----添加之前，列表A的数据-----&quot;) for tempName in A: print(tempName) #提示、并添加元素 temp = input(&#39;请输入要添加的学生姓名:&#39;) A.append(temp) print(&quot;-----添加之后，列表A的数据-----&quot;) for tempName in A: print(tempName) extend通过extend可以将另一个集合中的元素逐一添加到列表中 &gt;&gt;&gt; a = [1, 2] &gt;&gt;&gt; b = [3, 4] &gt;&gt;&gt; a.append(b) &gt;&gt;&gt; a [1, 2, [3, 4]] &gt;&gt;&gt; a.extend(b) &gt;&gt;&gt; a [1, 2, [3, 4], 3, 4] insertinsert(index, object) 在指定位置index前插入元素object &gt;&gt;&gt; a = [0, 1, 2] &gt;&gt;&gt; a.insert(1, 3) &gt;&gt;&gt; a [0, 3, 1, 2] 3.2、修改元素(“改”)：修改元素的时候，要通过下标来确定要修改的是哪个元素，然后才能进行修改 demo: #定义变量A，默认有3个元素 A = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;] print(&quot;-----修改之前，列表A的数据-----&quot;) for tempName in A: print(tempName) #修改元素 A[1] = &#39;a2data666&#39; print(&quot;-----修改之后，列表A的数据-----&quot;) for tempName in A: print(tempName) 结果: -----修改之前，列表A的数据----- a2data a2data1 a2data2 -----修改之后，列表A的数据----- a2data a2data666 a2data2 3.3、查找元素 (“查”in, not in, index, count) 所谓的查找，就是看看指定的元素是否存在 in, not in python中查找的常用方法为： in（存在）,如果存在那么结果为true，否则为false not in（不存在），如果不存在那么结果为true，否则false demo #待查找的列表 nameList = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;] #获取用户要查找的名字 findName = input(&#39;请输入要查找的姓名:&#39;) #查找是否存在 if findName in nameList: print(&#39;在字典中找到了相同的名字&#39;) else: print(&#39;没有找到&#39;) 说明： in的方法只要会用了，那么not in也是同样的用法，只不过not in判断的是不存在 index, countindex和count与字符串中的用法相同 &gt;&gt;&gt; a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;] &gt;&gt;&gt; a.index(&#39;a&#39;, 1, 3) # 注意是左闭右开区间 Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; ValueError: &#39;a&#39; is not in list &gt;&gt;&gt; a.index(&#39;a&#39;, 1, 4) 3 &gt;&gt;&gt; a.count(&#39;b&#39;) 2 &gt;&gt;&gt; a.count(&#39;d&#39;) 0 3.4、删除元素 (“删”del, pop, remove) 类比公号中，如果掉粉了，那么就应该把这个取关粉丝的姓名删除掉；在开发中经常会用到删除这种功能。 列表元素的常用删除方法有： del：根据下标进行删除 pop：删除最后一个元素 remove：根据元素的值进行删除 demo:(del) movieName = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;,&#39;a2data3&#39;,&#39;a2data4&#39;,&#39;a2data5&#39;] print(&#39;------删除之前------&#39;) for tempName in movieName: print(tempName) del movieName[2] print(&#39;------删除之后------&#39;) for tempName in movieName: print(tempName) 结果: ------删除之前------ a2data a2data1 a2data2 a2data3 a2data4 a2data5 ------删除之后------ a2data a2data1 a2data3 a2data4 a2data5 demo:(pop) movieName = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;,&#39;a2data3&#39;,&#39;a2data4&#39;,&#39;a2data5&#39;] print(&#39;------删除之前------&#39;) for tempName in movieName: print(tempName) movieName.pop() print(&#39;------删除之后------&#39;) for tempName in movieName: print(tempName) 结果: ------删除之前------ a2data a2data1 a2data2 a2data3 a2data4 a2data5 ------删除之后------ a2data a2data1 a2data2 a2data3 a2data4 demo:(remove) movieName = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;,&#39;a2data3&#39;,&#39;a2data4&#39;,&#39;a2data5&#39;] print(&#39;------删除之前------&#39;) for tempName in movieName: print(tempName) movieName.remove(&#39;a2data3&#39;) print(&#39;------删除之后------&#39;) for tempName in movieName: print(tempName) 结果: ------删除之前------ a2data a2data1 a2data2 a2data3 a2data4 a2data5 ------删除之后------ a2data a2data1 a2data2 a2data4 a2data5 3.5、排序(sort, reverse) sort方法是将list按特定顺序重新排列，默认为由小到大，参数reverse=True可改为倒序，由大到小。 reverse方法是将list逆置。 &gt;&gt;&gt; a = [1, 4, 2, 3] &gt;&gt;&gt; a [1, 4, 2, 3] &gt;&gt;&gt; a.reverse() &gt;&gt;&gt; a [3, 2, 4, 1] &gt;&gt;&gt; a.sort() &gt;&gt;&gt; a [1, 2, 3, 4] &gt;&gt;&gt; a.sort(reverse=True) &gt;&gt;&gt; a [4, 3, 2, 1] 4、列表的嵌套4.1 列表嵌套 类似while循环的嵌套，列表也是支持嵌套的 一个列表中的元素又是一个列表，那么这就是列表的嵌套 schoolNames = [[&#39;北京&#39;,&#39;山西&#39;], [&#39;湖南&#39;,&#39;天津&#39;,&#39;深圳&#39;], [&#39;长沙&#39;,&#39;上海&#39;]] 4.2、 应用 一个公号，有5个长期运营，现在要分配其中3个位置，但是有8位运营者等待分配，请编写程序，完成随机的分配 #encoding=utf-8 import random # 定义 一个运营管理者的列表 offices = [[],[],[]] # 定义一个列表用来存储8位运营者的名字 names = [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;] i = 0 for name in names: index = random.randint(0,2) offices[index].append(name) i = 1 for tempNames in offices: print(&#39;运营%d的人数为:%d&#39;%(i,len(tempNames))) i+=1 for name in tempNames: print(&quot;%s&quot;%name,end=&#39;&#39;) print(&quot;\\n&quot;) print(&quot;-&quot;*20)","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"python的字符串","slug":"Python/python的字符串","date":"2019-12-10T23:30:21.000Z","updated":"2020-08-07T10:27:27.657Z","comments":true,"path":"posts/29055.html","link":"","permalink":"http://www.a2data.cn/posts/29055.html","excerpt":"Python的字符串","text":"Python的字符串 Python的字符串1、字符串介绍 想一想： 当打来浏览器登录某些网站的时候，需要输入密码，浏览器把密码传送到服务器后，服务器会对密码进行验证，其验证过程是把之前保存的密码与本次传递过去的密码进行对比，如果相等，那么就认为密码正确，否则就认为不对；服务器既然想要存储这些密码可以用数据库（比如MySQL），当然为了简单起见，咱们可以先找个变量把密码存储起来即可；那么怎样存储带有字母的密码呢？ 答： 字符串 python中字符串的格式 如下定义的变量a，存储的是数字类型的值 a = 100 如下定义的变量b，存储的是字符串类型的值 b = &quot;hello a2data.cn&quot; 或者 b = &#39;hello www.a2data.cn&#39; 小总结： 双引号或者单引号中的数据，就是字符串 2、字符串输出demo name = &#39;小风&#39; position = &#39;大数据分析狮&#39; address = &#39;北京市朝阳区xxxx&#39; print(&#39;--------------------------------------------------&#39;) print(&quot;姓名：%s&quot;%name) print(&quot;职位：%s&quot;%position) print(&quot;公司地址：%s&quot;%address) print(&#39;--------------------------------------------------&#39;) 结果 -------------------------------------------------- 姓名： 小风 职位： 大数据分析狮 公司地址： 北京市朝阳区xxxx -------------------------------------------------- 3、字符串输入 在input的时候，通过它能够完成从键盘获取数据，然后保存到指定的变量中； 注意：input获取的数据，都以字符串的方式进行保存，即使输入的是数字，那么也是以字符串方式保存 demo userName = input(&#39;请输入用户名:&#39;) print(&quot;用户名为：%s&quot;%userName) password = input(&#39;请输入密码:&#39;) print(&quot;密码为：%s&quot;%password) 4、下标和切片4.1、下标索引 字符串中”下标”的使用 列表与元组支持下标索引好理解，字符串实际上就是字符的数组， 所以也支持下标索引。 如果有字符串:name = &#39;abcdef&#39;，在内存中的实际存储如下: 如果想取出部分字符，那么可以通过下标的方法，（注意python中下标从 0 开始） name = &#39;abcdef&#39; print(name[0]) print(name[1]) print(name[2]) 运行结果 4.2、切片 切片是指对操作的对象截取其中一部分的操作。字符串、列表、元组都支持切片操作。 切片的语法：[起始:结束:步长]注意：选取的区间属于左闭右开型，即从”起始”位开始，到”结束”位的前一位结束（不包含结束位本身)。 我们以字符串为例讲解。 如果取出一部分，则可以在中括号[]中使用 : name = &#39;abcdef&#39; print(name[0:3]) # 取 下标0~2 的字符 print(name[0:5]) # 取 下标为0~4 的字符 print(name[3:5]) # 取 下标为3、4 的字符 print(name[2:]) # 取 下标为2开始到最后的字符 print(name[1:-1]) # 取 下标为1开始 到 最后第2个 之间的字符 a = &quot;abcdef&quot; a[:3] &#39;abc&#39; a[::2] &#39;ace&#39; a[5:1:2] &#39;&#39; a[1:5:2] &#39;bd&#39; a[::-2] &#39;fdb&#39; a[5:1:-2] &#39;fd&#39; 想一想 （面试题）给定一个字符串aStr, 请反转字符串 例如： ‘www.a2data.cn&#39; 5、字符串常见操作 如有字符串mystr = &#39;hello world a2data and jackfeng&#39;，以下是常见的操作 5.1、find 检测 str 是否包含在 mystr中，如果是返回开始的索引值，否则返回-1 mystr.find(str,start=0, end=len(mystr)) mystr = &#39;hello world a2data and jackfeng&#39; 5.2、index 跟find()方法一样，只不过如果str不在 mystr中会报一个异常. mystr.index(str, start=0, end=len(mystr)) mystr = &#39;hello world a2data and jackfeng&#39; 5.3、count 返回 str在start和end之间 在 mystr里面出现的次数 mystr.count(str, start=0, end=len(mystr)) mystr = &#39;hello world a2data and jackfeng&#39; 5.4、replace 把 mystr 中的 str1 替换成 str2,如果 count 指定，则替换不超过 count 次. mystr.replace(str1, str2, mystr.count(str1)) name =&quot;hello world ha ha&quot; 5.5、split 以 str 为分隔符切片 mystr，如果 maxsplit有指定值，则仅分隔 maxsplit 个子字符串 mystr.split(str=&quot; &quot;, 2) name =&quot;hello world ha ha&quot; 5.6、capitalize 把字符串的第一个字符大写 mystr.capitalize() 5.7、title 把字符串的每个单词首字母大写 5.8、startswith 检查字符串是否是以 obj 开头, 是则返回 True，否则返回 False mystr.startswith(obj) 5.9、endswith 检查字符串是否以obj结束，如果是返回True,否则返回 False. mystr.endswith(obj) 5.10、lower 转换 mystr 中所有大写字符为小写 mystr.lower() 5.11、upper 转换 mystr 中的小写字母为大写 mystr.upper() 5.12、ljust 返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串 mystr.ljust(width) 5.13、rjust 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串 mystr.rjust(width) 5.14、center 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串 mystr.center(width) 5.15、lstrip 删除 mystr 左边的空白字符 mystr.lstrip() 5.16、rstrip 删除 mystr 字符串末尾的空白字符 mystr.rstrip() 5.17、strip 删除mystr字符串两端的空白字符 5.18、rfind 类似于 find()函数，不过是从右边开始查找. mystr.rfind(str, start=0,end=len(mystr) ) 5.19、rindex 类似于 index()，不过是从右边开始. mystr.rindex( str, start=0,end=len(mystr)) 5.20、partition 把mystr以str分割成三部分,str前，str和str后 mystr.partition(str) 5.21、rpartition 类似于 partition()函数,不过是从右边开始. mystr.rpartition(str) 5.22、splitlines 按照行分隔，返回一个包含各行作为元素的列表 mystr.splitlines() 5.23、isalpha 如果 mystr 所有字符都是字母 则返回 True,否则返回 False mystr.isalpha() 5.24、isdigit 如果 mystr 只包含数字则返回 True 否则返回 False. mystr.isdigit() 5.25、isalnum 如果 mystr 所有字符都是字母或数字则返回 True,否则返回 False mystr.isalnum() 5.26、isspace 如果 mystr 中只包含空格，则返回 True，否则返回 False. mystr.isspace() 5.27、join mystr 中每个字符后面插入str,构造出一个新的字符串 mystr.join(str) 想一想 （面试题）给定一个字符串aStr，返回使用空格或者’\\t’分割后的倒数第二个子串","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"python第二天作业答案","slug":"Python/python第二天作业答案","date":"2019-12-10T23:20:20.000Z","updated":"2020-08-07T10:27:32.223Z","comments":true,"path":"posts/27081.html","link":"","permalink":"http://www.a2data.cn/posts/27081.html","excerpt":"第二天作业答案!","text":"第二天作业答案! Python第二天作业 第二天学习链接： https://www.a2data.cn/posts/51417.html 1.2、练一练length = int(input(&#39;请输入刀具的长度（cm):&#39;)) if length &lt; 10: print(&#39;可以上火车回家咯&#39;) else: print(&#39;携带超过规定的管制刀具，不允许上火车&#39;) 3.3、练一练restMoney = int(input(&#39;请输入当前公交卡的余额（元）：&#39;)) if restMoney &gt; 2: print(&#39;可以上公交车&#39;) restSeats = int(input(&#39;请输入公交车上空座位数：&#39;)) if restSeats &gt; 0 : print(&#39;可以坐公交车回家咯&#39;) else: print(&#39;只能站着回家，好辛苦&#39;) else: print(&#39;坏了，卡里钱不够，赶紧用手机充一下卡&#39;) 9.3、打印：九九乘法表i = 1 while i &lt;= 9 : j = 1 while j &lt;= 9 and i &gt;= j: print(i,&#39;*&#39;,j,&#39;=&#39;,i*j,end = &#39; &#39;) j += 1 print(&#39;\\n&#39;) i += 1 #九九乘法表 i = 1 while i &lt;= 9: j = 1 while j &lt;= i: print(&quot;%d*%d=%-2d &quot; % (j, i, i * j), end=&#39;&#39;) j += 1 print(&#39;\\n&#39;) i += 1 11.1、必做题：userName = &#39;li&#39; passWord = &#39;1501127&#39; user = input(&#39;请输入用户名：&#39;) password = input(&#39;请输入密码：&#39;) if user == userName: if password == passWord: print(&quot;欢迎进入%s的世界&quot;% userName) else: print(&#39;用户名或者密码错误&#39;) else: print(&#39;用户名或者密码错误&#39;) 使用while，完成以下图形的输出i = 1 j = 9 while j &gt; 0: if j &gt; 5: if i &lt;= 5: print(&quot;* &quot; * i) else: continue else: print(&quot;* &quot; * j) j -= 1 i += 1 11.2、选做题：totalTimes = 40 kmile = int(input(&#39;请输入单次上班的里程（km):&#39;)) total = 5 if kmile &lt;= 6 and kmile &gt; 0: takeTimes = (100-5)//3 +1 total = 100 + (2*20-takeTimes)*3*0.8 print(&#39;每月乘坐地铁需要支出的总费用：%.2f 元&#39; % total) elif kmile &lt;= 12 and kmile &gt; 6: while totalTimes &gt; 0: if total &lt; 100: total += 4 elif total &gt;= 100 and total &lt; 150: total += 4* 0.8 elif total &gt;= 150: total += 4 * 0.5 totalTimes -= 1 print(&#39;每月乘坐地铁需要支出的总费用：%.2f 元&#39; % total) elif kmile &lt;= 22 and kmile &gt; 12: while totalTimes &gt; 0: if total &lt; 100: total += 5 elif total &gt;= 100 and total &lt; 150: total += 5*0.8 elif total &gt;= 150 and total &lt; 400: total += 5*0.5 totalTimes -= 1 print(&#39;每月乘坐地铁需要支出的总费用：%.2f 元&#39; % total) elif kmile &lt;= 32 and kmile &gt; 22: while totalTimes &gt; 0: if total &lt; 100: total += 6 elif total&gt;= 100 and total &lt; 150: total += 6 * 0.8 elif total &gt;= 150 and total &lt; 400: total += 6 * 0.5 totalTimes -= 1 print(&#39;每月乘地铁需要支出的总费用：%.2f 元&#39; % total) elif kmile &gt; 32: m = (kmile-32)//20+1 while totalTimes &gt; 0: if total &lt; 100: total += 6+m elif total&gt;= 100 and total &lt; 150: total += (6+m) * 0.8 elif total &gt;= 150 and total &lt; 400: total += (6+m) * 0.5 elif total &gt;= 400: total += 6+m totalTimes -= 1 print(&#39;每月乘地铁需要支出的总费用：%.2f 元&#39; % total)","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"Python判断和循环语句","slug":"Python/Python判断和循环语句","date":"2019-12-08T23:47:37.000Z","updated":"2020-08-07T10:28:06.616Z","comments":true,"path":"posts/51417.html","link":"","permalink":"http://www.a2data.cn/posts/51417.html","excerpt":"Python的判断和循环语句","text":"Python的判断和循环语句 Python判断循环语句1、if-else 掌握 if-else 的语法格式 想一想：在使用if的时候，它只能做到满足条件时要做的事情。那万一需要在不满足条件的时候，做某些事，该怎么办呢？ 答：else 1.1、使用格式 if 条件: 满足条件时要做的事情1 满足条件时要做的事情2 满足条件时要做的事情3 ...(省略)... else: 不满足条件时要做的事情1 不满足条件时要做的事情2 不满足条件时要做的事情3 ...(省略)... demo 马上要过年了，又到了抢票的季节。 chePiao = 1 # 用1代表有车票，0代表没有车票 if chePiao == 1: print(&quot;有车票，可以上火车&quot;) print(&quot;终于可以坐着回家了，美滋滋~~~&quot;) else: print(&quot;没有车票，不能上车&quot;) print(&quot;可否上车补票啊，真是一票难求啊~~~~(&gt;_&lt;)~~~~&quot;) 1.2、练一练 要求：从键盘输入刀子的长度，如果刀子长度没有超过10cm，则允许上火车，否则不允许上火车 2、elif 想一想: if能完成当xxx时做事情 if-else能完成当xxx时做事情1，否则做事情2 如果有这样一种情况： 当xxx1时做事情1， 当xxx2时做事情2， 当xxx3时做事情3， 那该怎么实现呢？ 答: elif 2.1、elif的功能elif的使用格式如下 if xxx1: 事情1 elif xxx2: 事情2 elif xxx3: 事情3 说明: 当xxx1满足时，执行事情1，然后整个if结束 当xxx1不满足时，那么判断xxx2，如果xxx2满足，则执行事情2，然后整个if结束 当xxx1不满足时，xxx2也不满足，如果xxx3满足，则执行事情3，然后整个if结束 demo score = 77 if score&gt;=90 and score&lt;=100: print(&#39;本次考试，等级为A&#39;) elif score&gt;=80 and score&lt;90: print(&#39;本次考试，等级为B&#39;) elif score&gt;=70 and score&lt;80: print(&#39;本次考试，等级为C&#39;) elif score&gt;=60 and score&lt;70: print(&#39;本次考试，等级为D&#39;) elif score&gt;=0 and score&lt;60: print(&#39;本次考试，等级为E&#39;) 2.2、注意点 可以和else一起使用 if 性别为男性: 输出男性的特征 ... elif 性别为女性: 输出女性的特征 ... else: 第三种性别的特征 ... 说明: 当 “性别为男性” 满足时，执行 “输出男性的特征”的相关代码 当 “性别为男性” 不满足时，如果 “性别为女性”满足，则执行 “输出女性的特征”的相关代码 当 “性别为男性” 不满足，“性别为女性”也不满足，那么久默认执行else后面的代码，即 “第三种性别的特征”相关代码 elif必须和if一起使用，否则出错 3、if嵌套想一想： 坐火车或者地铁的实际情况是：先进行安检如果安检通过才会判断是否有车票，或者是先检查是否有车票之后才会进行安检，即实际的情况某个判断是再另外一个判断成立的基础上进行的，这样的情况该怎样解决呢？ 答： if嵌套 3.1、嵌套格式 if 条件1: 满足条件1 做的事情1 满足条件1 做的事情2 ...(省略)... if 条件2: 满足条件2 做的事情1 满足条件2 做的事情2 ...(省略)... 说明 外层的if判断，也可以是if-else 内层的if判断，也可以是if-else 根据实际开发的情况，进行选择 3.2、嵌套应用demo chePiao = 1 # 用1代表有车票，0代表没有车票 daoLenght = 9 # 刀子的长度，单位为cm if chePiao == 1: print(&quot;有车票，可以进站&quot;) if daoLenght &lt; 10: print(&quot;通过安检&quot;) print(&quot;终于可以坐着回家了，美滋滋~~~&quot;) else: print(&quot;没有通过安检&quot;) print(&quot;刀子的长度超过规定，等待警察处理...&quot;) else: print(&quot;没有车票，不能进站&quot;) print(&quot;不要方，真是一票难求啊~~~~(&gt;_&lt;)~~~~&quot;) 结果1：chePiao = 1;daoLenght = 9 有车票，可以进站 通过安检 终于可以回家了，美滋滋~~~ 结果2：chePiao = 1;daoLenght = 20 有车票，可以进站 没有通过安检 刀子的长度超过规定，等待警察处理... 结果3：chePiao = 0;daoLenght = 9 没有车票，不能进站 一票难求啊~~~~(&gt;_&lt;)~~~~ 结果4：chePiao = 0;daoLenght = 20 没有车票，不能进站 一票难求啊~~~~(&gt;_&lt;)~~~~ 想一想:为什么结果3和结果4相同？？？ 3.3 、练一练 情节描述：上公交车，并且可以有座位坐下 要求：输入公交卡当前的余额，只要超过2元，就可以上公交车；如果空座位的数量大于0，就可以坐下 4、猜拳游戏 应用，根据if语句相关知识，完善猜拳游戏 优化参考代码 优化以下代码，解决只能玩一次的问题 import random player = input(&#39;请输入：剪刀(0) 石头(1) 布(2):&#39;) player = int(player) computer = random.randint(0,2) # 用来进行测试 # 感谢关注A2Data #print(&#39;player=%d,computer=%d&#39;,(player,computer)) if ((player == 0) and (computer == 2)) or ((player ==1) and (computer == 0)) or ((player == 2) and (computer == 1)): print(&#39;获胜，哈哈，你太厉害了&#39;) elif player == computer: print(&#39;平局，要不再来一局&#39;) else: print(&#39;输了，不要走，洗洗手接着来，决战到天亮&#39;) 5、循环语句 生活中的循环应用场景： 跑道、风扇、空调左右上下摆风、地铁日常运行等 开发中的循环场景。 某天，你惹你女朋友生气了， 需要跟她诚恳地道歉。 print(&quot;亲爱的，我错了&quot;) print(&quot;亲爱的，我错了&quot;) print(&quot;亲爱的，我错了&quot;) ...(还有99997遍)... 使用循环语句呢？ 一句话搞定 i = 0 while i&lt;10000: print(&quot;亲爱的，我错了&quot;) i+=1 # i+=1 同等于 i= i+1 使用场景： 一般情况下，需要多次重复执行的代码，都可以用循环的方式来完成 循环不是必须要使用的，但是为了提高代码的重复使用率，所以有经验的开发者都会采用循环 6、while循环格式 while 条件: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... demo i = 0 while i&lt;5: print(&quot;当前是第%d次执行循环&quot;%(i+1)) print(&quot;i=%d&quot;%i) i+=1 结果 当前是第1次执行循环 i=0 当前是第2次执行循环 i=1 当前是第3次执行循环 i=2 当前是第4次执行循环 i=3 当前是第5次执行循环 i=4 7、while循环应用7.1、计算1~100累积和 注意：包含 1 和 100 # A2Data提供参考代码 i = 1 sum = 0 while i&lt;=100: sum = sum + i i += 1 print(&quot;1~100的累积和为:%d&quot;%sum) 7.2 、计算1~100偶数累积和 注意： 同样包含1 和 100 # 欢迎关注A2Data 转发在看求支持哦 i = 1 sum = 0 while i&lt;=100: if i%2 == 0: sum = sum + i i+=1 print(&quot;1~100的累积和为:%d&quot;%sum) 8、break和continue8.1、break8.1.1、for循环 for循环场景下的使用案例。 具体差别，自己动手输出看。 正常for循环 name = &#39;a2data&#39; for x in name: print(&#39;----&#39;) print(x) 带有break name = &#39;a2data&#39; for x in name: print(&#39;----&#39;) if x == &#39;d&#39;: break print(x) 8.1.2、while循环 普通循环如下 i = 0 while i&lt;10: i = i+1 print(&#39;----&#39;) print(i) 带有‘break’循环 i = 0 while i&lt;10: i = i+1 print(&#39;----&#39;) if i==5: break print(i) break的作用：用来结束整个循环 8.2、continue8.2.1、for循环name = &#39;a2data&#39; for x in name: print(&#39;----&#39;) if x == &#39;d&#39;: continue print(x) 8.2.2、while循环i = 0 while i&lt;10: i = i+1 print(&#39;----&#39;) if i==5: continue print(i) 总结: continue的作用：用来结束本次循环，紧接着执行下一次的循环 8.2.3、注意点 break/continue只能用在循环中，除此以外不能单独使用 break/continue在嵌套循环中，只对最近的一层循环起作用 9、while循环嵌套9.1while嵌套格式 while 条件1: 条件1满足时，做的事情1 条件1满足时，做的事情2 条件1满足时，做的事情3 ...(省略)... while 条件2: 条件2满足时，做的事情1 条件2满足时，做的事情2 条件2满足时，做的事情3 ...(省略)... 9.2、练习打印如下图形 * * * * * * * * * * * * * * * 参考代码 i = 1 while i&lt;=5: j = 1 while j&lt;=i: print(&quot;* &quot;,end=&#39;&#39;) j+=1 print(&quot;\\n&quot;) i+=1 9.3、打印：九九乘法表 10、for循环 掌握 for 循环的语法格式 掌握 for-else 的执行过程 像while循环一样，for可以完成循环的功能。 在Python中 for循环可以遍历任何序列的项目， 如一个列表或者一个字符串等。 请跟着操作如下demo！ demo0 name = &#39;a2data&#39; for x in name: print(x) demo1 name = &#39;hello1&#39; # 皮一下很开心 for x in name: print(x) if x==&#39;l&#39;: break #退出for循环 else: print(&quot;==for循环过程中，如果没有break则执行==&quot;) demo2 name = &#39;hello&#39; for x in name: print(x) #if x==&#39;l&#39;: # break #退出for循环 else: print(&quot;==for循环过程中，如果没有break则执行==&quot;) 11、总结与练习 11.1、必做题：使用if，编写程序，实现以下功能 从键盘获取用户名、密码 如果用户名和密码都正确（预先设定一个用户名和密码），那么就显示“欢迎进入xxx的世界”，否则提示密码或者用户名错误 使用while，完成以下图形的输出 * * * * * * * * * * * * * * * * * * * * * * * * * 11.2、选做题：根据以下信息提示，计算出每月乘坐地铁支出的总费用 提示信息（票价）： 地铁6公里(含)内3元，公交车10公里(含)内2元，使用市政交通一卡通刷卡乘公交车普通卡5折，学生卡2.5折。 一、城市公共电汽车价格调整为：10公里(含)内2元，10公里以上部分，每增加1元可乘坐5公里。使用市政交通一卡通刷卡乘坐城市公共电汽车，市域内路段给予普通卡5折，学生卡2.5折优惠;市域外路段维持现行折扣优惠不变。享受公交政策的郊区客运价格，由各区、县政府按照城市公共电汽车价格制定。 二、轨道交通价格调整为：6公里(含)内3元;6公里至12公里(含)4元;12公里至22公里(含)5元;22公里至32公里(含)6元;32公里以上部分，每增加1元可乘坐20公里。使用市政交通一卡通刷卡乘坐轨道交通，每自然月内每张卡支出累计满100元以后的乘次，价格给予8折优惠;满150元以后的乘次，价格给予5折优惠;支出累计达到400元以后的乘次，不再享受打折优惠。 要求 假设每个月，你都需要上20天班，每次上班需要来回1次，即每天需要乘坐2次同样路线的地铁；每月月初第一次刷公交卡时，扣款5元；编写程序，请计算出你每月乘坐地铁需要的总费用","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"Python第一天作业答案","slug":"Python/Python第一天作业答案","date":"2019-12-08T13:04:54.000Z","updated":"2020-08-07T10:27:35.004Z","comments":true,"path":"posts/5010.html","link":"","permalink":"http://www.a2data.cn/posts/5010.html","excerpt":"第一天作业答案!~","text":"第一天作业答案!~ Python第一天作业 第一天学习链接： https://www.a2data.cn/posts/59977.html#toc-heading-43 必做题 1、 变量的命名组成 数字、字母、下划线，但是不能以数字开头 2、变量命名时的规则 1）变量名可以由数字，字母，下划线组成，但是不能以数字开头 2）Python中已经使用的关键字不允许开发者自己定义和关键字相同名字的标识符 3、驼峰法（大驼峰、小驼峰） 当变量是由两个或者多个单词组成的时候，可以利用驼峰命名法来命名： ①小驼峰命名法： 第一个单词以小写字母开始，后续单词的首字母大写 例如：firstName、lastName ②大驼峰命名法： 每个单词的首字母都大写 例如：FirstName、LastName、CamelCase 4、编写程序，完成以下要求： 提示用户进行输入数据 获取用户的数据数据（需要获取2个） 对获取的两个数字进行求和运行，并输出相应的结果 egg = input(&quot;请输入够买鸡蛋的金额：&quot;) bun = input(&quot;请输入够买包子的金额：&quot;) milk = input(&quot;请输入够买豆浆的金额：&quot;) breakfast = egg + bun + milk print(&quot;您的早餐费用共计为&quot;,breakfast,&quot;元！&quot;) egg = int(input(&quot;请输入够买鸡蛋的金额：&quot;)) bun = int(input(&quot;请输入够买包子的金额：&quot;)) milk = int(input(&quot;请输入够买豆浆的金额：&quot;)) breakfast = egg + bun + milk print(&quot;您的早餐费用共计为&quot;,breakfast,&quot;元！&quot;) 5、编写程序，完成以下要求 提示用户进行输入数据 获取用户的数据数据（需要获取2个） 对获取的两个数字进行减法运行，并输出相应的结果 totalwork =int(input(&#39;今天小风布置作业题数：&#39;)) finislwork =int(input(&#39;已经完成作业题数：&#39;)) restwork = totalwork -finislwork print(&#39;还需要完成%d 道就完成作业了&#39; % restwork) 6、编写身份认证系统print(&quot;=&quot;*22) print(&quot;欢迎进入身份证认证系统V1.0 &quot;) print(&quot;1.登陆&quot;) print(&quot;2.退出&quot;) print(&quot;3.认证&quot;) print(&quot;4.修改密码&quot;) print(&quot;=&quot;*21) 7、编写程序，从键盘获取一个人的信息，然后输出 print(&quot;=&quot;*21) name = input(&quot;姓名：&quot;) qq = input(&#39;QQ:&#39;) tel = input(&#39;手机号:&#39;) adress = input(&#39;公司地址:&#39;) print(&quot;=&quot;*21) 8、编写程序,判断用户名密码name = input(&#39;你的姓名：&#39;) password = input(&#39;登陆密码：&#39;) if len(name)&gt;0 and len(password)&gt;0: print(&#39;亲爱的%s,欢迎登陆A2Data学习管理系统&#39; % name) 文中习题 12.2 练一练age = int(input(&#39;请输入年龄：&#39;)) if age &gt;= 18: print(&#39;哥，已成年，网吧可以去了&#39;) 12.3 想一想 判断age大于或者等于18岁，使用的是 &gt;=，还有哪些呢？ age &gt; 18 or age =18","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"Python基础知识","slug":"Python/Python基础知识","date":"2019-12-05T14:43:54.000Z","updated":"2020-08-07T10:27:46.324Z","comments":true,"path":"posts/59977.html","link":"","permalink":"http://www.a2data.cn/posts/59977.html","excerpt":"Python的基础语法","text":"Python的基础语法 Python 为什么那么多培训机构？那么多的程序员呢？ 很简单啊。 因为 门槛低啊。 ==. 不信？来动手试试吧。 1、操作系统(科普一下)目标 了解操作系统及应用 操作系统接口示意图 那么没有安装操作系统的计算机, 那就是裸机 2、Python优缺点 时势造英雄 人生苦短，我用python Python可以做什么呢？ 3、Python的第一个程序 上篇已经说过一些，但是竟然有人问我如何创建！！ 此处以 jupyter 为例吧。 果真是炒鸡小白。 1、运行服务，进入web页面 2、进入你的工作目录 3、成功输出你的第一行代码 4、注释4.1、注释引入1、未使用注释 2、使用注释 3、注释的作用 通过用自己熟悉的语言，在程序中对某些代码进行标注说明，这就是注释的作用，能够大大增强程序的可读性 4.2、注释分类1、&lt;单行注释&gt; # 我是注释，可以在里写一些功能说明之类的哦 print(&#39;hello world&#39;) 2、&lt;多行注释&gt; 3、&lt;注意&gt; 在python的语法规范中推荐使用的方式： （早期版本，不写的话，``print(‘努力赚钱的小风’) `就会报错哦） # -*- coding:utf-8 -*- 5、变量以及类型目标 掌握变量的定义和修改 了解变量有哪些类型和查看方式 5.1、&lt;变量的定义&gt; A：简单来讲就是，在程序中，我们需要对2个数据进行求和，那么该怎么做呢？ B：类比现实生活中，比如你去买早餐，一个鸡蛋，一个茄子包子等，你需要算你共花了多少钱。 所以，对于Python而言，存储一个数据，就需要一个变量 程序就是用来处理数据，而变量就是用来存储数据的。 *思考：我们应该让变量占用多大空间，保存什么样的数据？* 5.2、&lt;变量的类型&gt;生活中类型的例子(拿车来举例吧)： 挖掘机、轿车、跑车、公交车 （类型，大小，价格都不同） 程序中： 充分利用空间，有效管理内存 那么问题来了，如何知道一个变量的类型呢？ Python中，只要定义了变量，且它有数据，那么它的类型就确定了。不用去说明它的类型，系统会自动辨别。 type(变量名称)—- 查看变量类型 6、标示符和关键字6.1、标示符 开发人员在程序中自定义的一些符号和名称 标示符是自己定义的,如变量名 、函数名等 6.2、标示符的规则 标示符由字母、下划线和数字组成，且数字不能开头 找一找:（如下，哪些是对的，哪些是错的？） fromNo12 from#12 my_Boolean my-Boolean Obj2 2ndObj myInt test1 Mike2jack My_tExt _test test!32 haha(da)tt int jack_rose jack&amp;rose GUI G.U.I a2data python中的标识符是区分大小写的 6.3、命名规则 见名知意 驼峰命名 下划线链接 6.4、关键字 python一些具有特殊功能的标示符，这就是所谓的关键字 关键字，是python已经使用的了，所以不允许开发者自己定义和关键字相同的名字的标示符 查看关键字 7、输出7.1、普通输出# 打印提示 print(&quot;hello world&quot;) 7.1、格式化输出7.1.1、格式化的目的print(&#39;小风今年10岁&#39;) print(&#39;小风今年18岁&#39;) print(&#39;小风今年20岁&#39;) # 思考，年龄多次使用，如何简化 -- 字符串可视化 7.1.2、格式化 7.1.3、换行输出#在输出的时候，如果有\\n那么，此时\\n后的内容会在另外一行显示 print(&quot;1234567890-------&quot;) # 会在一行显示 print(&quot;1234567890\\n-------&quot;) # 一行显示1234567890，另外一行显示------- 7.1.4、Python2-3输出区别 Python3 使用 print 必须要以小括号包裹打印内容，比如 print(&#39;hi&#39;) Python2 既可以使用带小括号的方式，也可以使用一个空格来分隔打印内容，比如 print &#39;hi&#39; 现在都是以python3为主 7.1.5、动手试试吧 编码完成一下名片的显示： ================================== 姓名: 努力赚钱的小风 QQ:xxxxxxx 手机号:185xxxxxx 公司地址:北京市xxxx ================================== #思考，如何格式化输出？换行？ 8、输入 这里简单说一下，Python2中的输入是 raw_input()函数 而在Python3中只有input() 9、运算符 算术运算符 运算优先级 赋值运算符 复合赋值运算符 9.1、算术运算符下面以a=10 ,b=20为例进行计算 运算符 描述 实例 + 加 两个对象相加 a + b 输出结果 30 - 减 得到负数或是一个数减去另一个数 a - b 输出结果 -10 * 乘 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 / 除 x除以y b / a 输出结果 2 % 取余 返回除法的余数 b % a 输出结果 0 ** 幂 返回x的y次幂 a**b 为10的20次方， 输出结果 100000000000000000000 // 取整除 返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0 &gt;&gt;&gt; 9 / 2.0 4.5 &gt;&gt;&gt; 9 // 2.0 4.0 &gt;&gt;&gt; 1 + 2*3 7 &gt;&gt;&gt; (1+2) * 3 9 9.2、赋值运算符 运算符 描述 实例 = 赋值运算符 把=号右边的结果给左边的变量 num=1+2*3 结果num的值为7 &gt;&gt;&gt; a, b = 1, 2 &gt;&gt;&gt; a 1 &gt;&gt;&gt; b 2 9.3、复合赋值运算符 运算符 描述 实例 += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c ** = a 等效于 c = c ** a //= 取整除赋值运算符 c //= a 等效于 c = c // a 10、数据类型转化 了解类型转换的作用 掌握常用的类型转换 函数 说明 int(x [,base ]) 将x转换为一个整数 long(x [,base ]) 将x转换为一个长整数 float(x ) 将x转换到一个浮点数 complex(real [,imag ]) 创建一个复数 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 unichr(x ) 将一个整数转换为Unicode字符 ord(x ) 将一个字符转换为它的整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 举例 a = &#39;100&#39; # 此时a的类型是一个字符串，里面存放了100这3个字符 b = int(a) # 此时b的类型是整型，里面存放的是数字100 print(&quot;a=%d&quot;%b) 11、判断语句介绍 直接拿一个例子来说明吧。 &lt;重要日期判断案例&gt; if 今天是周六或者周日: 约妹子 if 今天是情人节: 买玫瑰 if 今天发工资: 先还信用卡的钱 if 有剩余: 又可以happy了，O(∩_∩)O哈哈~ else: 噢，no。。。还的等30天 小总结： 如果某些条件满足，才能做某件事情，而不满足时不允许做，这就是所谓的判断 不仅生活中有，在软件开发中“判断”功能也经常会用到 12、if语句 掌握 if 语句的语法格式 12.1、if判断语句介绍 if语句是用来进行判断的，其使用格式如下： if 要判断的条件: 条件成立时，要做的事情 demo1: age = 30 print &quot;------if判断开始------&quot; if age&gt;=18: print &quot;我已经成年了&quot; print &quot;------if判断结束------&quot; 运行结果: ------if判断开始------ 我已经成年了 ------if判断结束------ demo2: age = 16 print &quot;------if判断开始------&quot; if age&gt;=18: print &quot;我已经成年了&quot; print &quot;------if判断结束------&quot; 运行结果: ------if判断开始------ ------if判断结束------ 小总结： 以上2个demo仅仅是age变量的值不一样，结果却不同；能够看得出if判断语句的作用：就是当满足一定条件时才会执行那块代码，否则就不执行那块代码 注意： 代码的缩进为一个tab键，或者4个空格 12.2、练一练要求：从键盘获取自己的年龄，判断是否大于或者等于18岁，如果满足就输出“哥，已成年，网吧可以去了” 使用input从键盘中获取数据，并且存入到一个变量中 使用if语句，来判断 age&gt;=18是否成立 12.3、想一想 判断age大于或者等于18岁，使用的是 &gt;=，还有哪些呢？ 13、比较、关系运算符13.1、比较(即关系)运算符python中的比较运算符如下表 运算符 描述 示例 == 检查两个操作数的值是否相等，如果是则条件变为真。 如a=3,b=3则（a == b) 为 true. != 检查两个操作数的值是否相等，如果值不相等，则条件变为真。 如a=1,b=3则(a != b) 为 true. &lt;&gt; 检查两个操作数的值是否相等，如果值不相等，则条件变为真。 如a=1,b=3则(a &lt;&gt; b) 为 true。这个类似于 != 运算符 &gt; 检查左操作数的值是否大于右操作数的值，如果是，则条件成立。 如a=7,b=3则(a &gt; b) 为 true. &lt; 检查左操作数的值是否小于右操作数的值，如果是，则条件成立。 如a=7,b=3则(a &lt; b) 为 false. &gt;= 检查左操作数的值是否大于或等于右操作数的值，如果是，则条件成立。 如a=3,b=3则(a &gt;= b) 为 true. &lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是，则条件成立。 如a=3,b=3则(a &lt;= b) 为 true. 13.2、 逻辑运算符 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是 True，它返回 True，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 14、小风作业练习必做题 说出变量名字，可以由哪些字符组成 写出变量命名时的规则 说出什么是驼峰法（大驼峰、小驼峰） 编写程序，完成以下要求： 提示用户进行输入数据 获取用户的数据数据（需要获取2个） 对获取的两个数字进行求和运行，并输出相应的结果 编写程序，完成以下要求： 提示用户进行输入数据 获取用户的数据数据（需要获取2个） 对获取的两个数字进行减法运行，并输出相应的结果 编写程序，完成以下信息的显示: ================================== = 欢迎进入到身份认证系统V1.0 = 1. 登录 = 2. 退出 = 3. 认证 = 4. 修改密码 ================================== 编写程序，从键盘获取一个人的信息，然后按照下面格式显示 ================================== 姓名: A2Data QQ:xxxxxxx 手机号:185xxxxxx 公司地址:北京市xxxx ================================== 编写程序，从键盘获取用户名和密码，然后判断，如果正确就输出以下信息 亲爱的xxx，欢迎登陆 A2Data学习管理系统","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"Python的由来","slug":"Python/Python的由来","date":"2019-12-04T08:27:00.000Z","updated":"2020-08-07T10:27:23.967Z","comments":true,"path":"posts/62910.html","link":"","permalink":"http://www.a2data.cn/posts/62910.html","excerpt":"‘人生苦短，我用Python。’","text":"‘人生苦短，我用Python。’ Python 环境搭建Anaconda这是一个支持 Linux, Mac, Windows系统的python发行版本，占空间约600MB。如对空间要求严格的用户，Miniconda是一种选择。 Windows系统 https://www.anaconda.com/distribution/ 首先打开这个网址 本文以作者系统为例， 双击安装文件 Anaconda3-2019.10-Windows-x86_64.exe，进入安装界面，点击 Next。 点击 I Agree，同意 Anaconda 的协议。 一般选择 Just Me，这也是建议安装选项，当然，选 All Users，为电脑上的所有用户安装也未尝不可。选好了以后点击 Next 继续。 在下图显示的界面选择安装目录，建议不要存C盘，这样以后会更多。 默认第一个勾选框是没有选中的，需要自己点选，这个选项说的是把 Anaconda 添加为 PATH 环境参数 。 后边基本没太多需要注意的。Install 安装到如下界面，可以选择安装，也可以跳过。我这里跳过了。 下一步，Finish 到此，安装完成。其实这个安装很简单。一般都会。 Pycharm开发者最爱之一的编译器。诸多便利之处。等待你 细细体会。 这里作者安装的是最新的IDEA 2019.02 这里不说明，具体安装教程。 主要说破解部分。 https://www.jetbrains.com/pycharm/ 下载之后，双击exe文件。正常安装即可。 划重点，安装完成之后我们选择试用，然后进去Pycharm 进行破解 1、下载补丁文件 jetbrains-agent.jar并将它放置到 pycharm安装目录的\\bin目录下（位置可随意，放这里是怕误操作删除了破解文件）。 2、进入项目界面**“Evaluate for free”免费试用，然后再创建一个空项目，这样就可以进入到pycharm的工作页面 3、配置文件 点击Pycharm最上面的菜单栏中的 “Help” -&gt; “Edit Custom VM Options…”**，如果提示是否要创建文件，点“Create”**。 在打开的vmoptions编辑窗口末行添加：**-javaagent:你pycharm的安装目录\\jetbrains-agent.jar** （注：请仔细检查补丁路径是否正确，如果错误则会出现Pycharm打不开的情况，这时候可以删除用户配置目录下的pycharm）windwos：C:\\Users\\用户名\\ 修改完配置文件之后重启Pycharm修改完配置文件之后重启Pycharm修改完配置文件之后重启Pycharm （重要事情说三遍） 4、输入激活码重启pycharm之后，点击菜单栏中的 “Help” -&gt; “Register …”，这里有两种激活方式： 一、选择最后一种License server激活方式，地址填入：http://jetbrains-license-server （应该会自动填上），或者点击按钮：**”Discover Server”** 来自动填充地址，完成激活 二、如果服务器激活方式无法激活，还可以选择Activation code方式激活，复制下面激活码即可 重启Pycharm，选择自动激活，会自动识别网址进行激活。没有出现日期，就说明永久了。（激活码以及激活插件，请在公号内联系小编获取！） 划重点—- 本教程适用于所有idea，不仅限pycharm哦 – 看到就是赚到，转发一波吧！ Python,你好！ 也许会迟到，但绝对不会缺席！ Anaconda 全宇宙最亲近一行代码 没有之一 这里我们通过执行Jupyter notebook ，启动方式有两种！ 1、点击 jupyter botebook 图标运行 2、Ctrl + R 在命令行中输入 Jupyter notebook 对于小白来说，你可能会遇到这样的问题？ 恭喜进入Coding的世界 Pycharm1、使用默认安装的Python 2、 如何更改可以调用anaconda解释器呢？ 添加对应的路径即可。 因为anaconda 集成了很多库，不用再安装了。","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"运营工具箱","slug":"Tools/运营工具箱","date":"2019-11-28T00:32:29.000Z","updated":"2020-08-07T10:29:03.872Z","comments":true,"path":"posts/41382.html","link":"","permalink":"http://www.a2data.cn/posts/41382.html","excerpt":"掌握这些工具，你就是自媒体大咖","text":"掌握这些工具，你就是自媒体大咖 126 种运营人必备工具微场景编辑器 易企秀：http://www.eqxiu.com/main 易企微：http://www.e7wei.com/ 兔展：http://www.rabbitpre.com/ 麦片 BlueMP：http://www.bluemp.cn 初页：http://www.ichuye.cn/ MAKA: http://maka.im/ 翼码旺财：http://cp.wangcaio2o.com/ 24好玩：http://24haowan.com/ 微页：http://www.zhichiwangluo.com/ 点点客海报：http://www.dodoca.com/ 秀米秀制作：http://xiumi.us/ 易传单：http://echuandan.com/ Epub360 意派：http://www.epub360.com/ LiveApp 场景应用：http://www.liveapp.cn/ Vxplo ：http://www.vxplo.cn/ 最酷网：http://www.zuiku.com/ 起飞页：http://www.qifeiye.com/#bit_elmpz WIX: http://www.wix.com/ 有图：http://www.360youtu.cn/ 图片素材来源 千图网：http://www.58pic.com/ 优美图：http://www.topit.me/ 花瓣：http://huaban.com/ 图虫：https://tuchong.com/ 图片 114：http://www.tupian114.com/ Picjumbo： https://picjumbo.com/ Pexels： https://www.pexels.com/ Gifs Categories：http://giphy.com/categories SOOGIF 动图搜索：http://soogif.com/ 素材公社：http://www.tooopen.com/ 插画家园：http://www.13cg.com/ Pixabay 免费高清图片：https://pixabay.com/ Wallpaper：http://cn.forwallpaper.com/ 图片处理网站 trikingly 建站工具：https://www.strikingly.com canva 海报设计：https://www.canva.com 暴走漫画制作器：http://baozoumanhua.com tuyitu 动图制作：http://www.tuyitu.com tagul 在线文字云制作：https://tagul.com smallpdf pdf 转换网站：https://smallpdf.com/cn Gif 录制编辑工具：GifCam 图片批量处理工具：美图秀秀批处理 创客贴：https://www.chuangkit.com/dc.html Magic Mockups：http://magicmockups.com/mockup/2/ 行业资源合作 APP换量/采量/变现/异业合作/礼品卡券 http://www.niaogebiji.com/pc/index/appchange 各大媒体平台 微信公众平台： https://mp.weixin.qq.com 企鹅媒体平台： http://om.qq.com/userAuth/index 头条号： http://mp.toutiao.com/ 搜狐公众平台： http://mp.sohu.com 网易媒体号： http://dy.163.com/wemedia/login.html UC 订阅平台： http://mp.uc.cn 百家号： http://publish.baidu.com 数据查询网站 搜狗微信搜索： http://weixin.sogou.com/ 新榜：http://www.newrank.cn/ 站长工具：http://tool.chinaz.com 百度搜索风云榜：http://top.baidu.com 百度指数：http://index.baidu.com 微指数： http://data.weibo.com/index 微博数据中心： http://data.weibo.com/datacenter/recommendapp 行业数据来源 媒体微博排行榜：http://v6.bang.weibo.com/xmt 友盟：http://www.umeng.com/ 中国新闻地图：http://vis.360.cn/open/cnnews/ 中国票房榜：http://www.cbooo.cn/ 收视率排行：http://www.tvtv.hk/archives/category/tv 农业大数据云平台：http://www.dataagri.com/agriculture/gis.action 房价指数：http://data.eastmoney.com/cjsj/newhouse.html 中国统计局：http://data.stats.gov.cn/ 主要城市拥堵实时排名：http://report.amap.com/traffic/ 中国综合社会调查：http://www.chinagss.org/ P2P 网贷指数：http://www.p2p001.com/wdzs/wdzs_p2pline.html Alexa：http://www.alexa.com/ 易车汽车指数：http://index.bitauto.com/ 旅游预测：http://trends.baidu.com/tour/ 网盘搜索网站 盘多多：http://www.panduoduo.net 网盘屋：http://www.wangpanwu.com/ 呆木瓜：http://www.daimugua.com 西林街：http://www.xilinjie.com 胖次网盘搜索引擎： http://www.panc.cc 百度网盘分享之家： http://wowenda.com/ 网盘 007：http://wangpan007.com/ 去转盘网：http://www.quzhuanpan.com/ 鸵鸟搜索：http://www.tuoniao.me/ 社群管理工具 进群宝：http://www.jinqunbao.com/ 小U管家企业版：http://www.xiaouqyfw.com/ 行业社群助手：https://xzs.jinqunla.com/ 群鲸SCRM个人号管理：http://www.qunsir.com/#/ Wetools：https://www.wxb.com/wetool 图文排版编辑器 i 排版：http://www.ipaiban.com/ 新榜编辑器：http://edit.newrank.cn/ 秀米：http://xiumi.us/ 96 微信编辑器：http://bj.96weixin.com/ 96 微信标题表情： http://bj.96weixin.com/emoji/ 135 编辑器：http://www.135editor.com/ 小蚂蚁微信编辑器：http://www.xmyeditor.com/ 易点编辑器：http://wxedit.yead.net/ 易企微微信编辑器：http://www.e7wei.cn/ 91 微信编辑器：http://www.91join.com/edit/ 微信编辑器：http://www.wxbj.cn/ 微助点微信编辑器：http://www.videaba.com/ 懒人模板：http://bj.lanrenmb.com/ 果优微信编辑器：http://guoyoo.99vu.com/ 做最好用的微信编辑器：http://editor.fzn.cc/ 微信在线编辑：http://wx.bzrw.net/ 微兔兔编辑器：http://www.weitutu.com/ 有图微信编辑器：http://bj.360youtu.com/ 排版 365：http://paiban.lizhi.in/ 乐排：http://pb.ishangtong.com/ 秀多多：http://xiudodo.com/?m=graphic#/for/new 在线问卷调查 腾讯问卷调查：http://wj.qq.com/ 麦客：http://www.mikecrm.com/ ICTR：http://cn2.ictr.cn/ 问道网：http://www.askform.cn/ 问卷星：http://www.sojump.com/ 调查派：http://www.diaochapai.com/ 问卷网：http://www.wenjuan.com/ SurveyMonkey：https://zh.surveymonkey.com/ 每日运营资讯 运营派https://www.adquan.com/ Next新产品http://next.36kr.com/posts 新榜资讯https://www.newrank.cn/public/news.html 二维码生成器 草料二维码：http://cli.im 联图网：http://www.liantu.com 二维工坊：http://www.2weima.com wwei 创意二维码：http://www.wwei.cn 二维码解码器：http://jiema.wwei.cn/ 半色调二维码生成器：https://spacekid.me/halftone-qr-code-generator/ 其他实用工具 多媒体格式转换工具：格式工厂 微信文章视频地址采集工具：http://www.hengha.tv/caiji.html 第一字体转换器：http://www.diyiziti.com/List 上传图片找字体：http://www.qiuziti.com/ 广告买卖网：http://www.admaimai.com/ GIF 压缩/水印/裁剪/制作/视频转 GIF：http://www.piggif.com/tools/compress 在线文件转换器：http://cn.office-converter.com/ PDF 转 DOC：http://pdf2doc.com/zh/ VIP 视频在线解析：http://vip.ifkdy.com/ 装逼神器：http://deepba.com/","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"},{"name":"运营工具","slug":"运营工具","permalink":"http://www.a2data.cn/tags/%E8%BF%90%E8%90%A5%E5%B7%A5%E5%85%B7/"}]},{"title":"打造稳定快速、高效免费图床","slug":"Tools/打造稳定快速、高效免费图床","date":"2019-11-26T13:41:06.000Z","updated":"2020-08-07T10:28:25.857Z","comments":true,"path":"posts/6059.html","link":"","permalink":"http://www.a2data.cn/posts/6059.html","excerpt":"超级图床，高速稳定","text":"超级图床，高速稳定 GitHub + jsDelivr + PicGo + Imagine 打造稳定快速、高效免费图床前言 为什么要使用图床呢？ 因为在不同平台发布同一篇文章的时候，最一个痛苦的点就是，图片存储问题，各个平台的文件存储方式各不相同，无法直接 Ctrl + C 的方式一键搞定，为了解决这个问题，使用 MarkDown + 图床 的方式进行文章的写作，将图片放到一个统一的地方，在文章中引入图片外链。所谓图床，就是将图片储存到第三方静态资源库中，其返回给你一个 URL 进行获取图片。MarkDown 支持使用 URL 的方式显示图片，我想这也是程序员为什么对其偏爱的原因之一。作为程序员，你会发现，现在很多论坛和社区都开始支持使用 MarkDown，如果你没使用图床的情况下，你分享同一篇文章，你要在不同的平台，各自重新编辑排版一遍和上传图片一次。有了图床，情况就不一样了，Ctrl+C 的方式就搞定了，根本不用再 Check 文章内容一遍。 图床的选择？ 微博图床：以前用的人比较多，从 2019 年 4 月开始开启了防盗链，凉凉 SM.MS：运营四年多了，也变得越来越慢了，到了晚上直接打不开图片，速度堪忧 其他小众图床：随时有挂掉的风险 Imgur 等国外图床：国内访问速度太慢，随时有被墙的风险 大厂储存服务：例如七牛云、又拍云、腾讯云COS、阿里云OSS等，操作繁琐，又是实名认证又是域名备案的，麻烦，而且还要花钱（有钱又不怕麻烦的当我没说） GitHub 图床：免费，但是国内访问速度慢（不过没关系，利用 jsDelivr 提供的免费的 CDN 加速 速度足够了） 使用流程 新建 GitHub 仓库 生成一个 Token 配置 PicGo 并使用 jsdelivr 作为 CDN 加速 使用 Imagine 进行图片压缩 上传图片到 PicGo 并使用图床 新建 GitHub 仓库 登录/注册 GitHub 新建一个仓库，填写好仓库名 仓库描述 将权限设置成 public 根据需求选择是否为仓库初始化一个 README.md 描述文件 新建 GitHub 仓库 生成一个 Token 点击用户头像 -&gt; 选择 Settings Settings 点击 Developer settings Developer settings 点击 Personal access tokens Personal access tokens 点击 Generate new token Generate new token 填写 Token 描述，勾选 repo，然后点击 Generate token 生成一个 Token 填写 Token 描述 获取 Token 密钥 注意这个 Token 只会显示一次，自己先保存下来，或者等后面配置好 PicGo 后再关闭此网页 获取 Token 密钥 配置 PicGo 并使用 jsdelivr 作为 CDN 加速前往下载 PicGo（点击下载），安装好后开始配置图床 设定仓库名：按照 用户名/图床仓库名 的格式填写 设定分支名：master 设定 Token：粘贴之前生成的 Token 指定存储路径：填写想要储存的路径，如 img/，这样就会在仓库下创建一个名为 img 的文件夹，图片将会储存在此文件夹中 设定自定义域名：它的的作用是，在图片上传后，PicGo 会按照自定义域名+上传的图片名的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为https://cdn.jsdelivr.net/gh/用户名/图床仓库名 配置 PicGo Text Q：什么是 jsdelivr ? A：jsDelivr 为开发者提供免费公共 CDN 加速服务 使用 Imagine 进行图片压缩通常情况下，图片大小都是超过 200KB 的，所以网页加载的时候会特别慢，一般我们会对图片进行压缩，这里我推荐 Imagine（点击下载） 支持全平台。 使用 Imagine 进行图片压缩 Imagine 采用的是有损压缩，介意的可以忽略这一步 顺便推荐一个无损压缩的网站：https://tinypng.com/ 上传图片到 PicGo 并使用图床配置好 PicGo 后，我们就可以进行高效创作了，将压缩后的图片拖拽到上传区，将会自动上传并复制访问链接，将链接粘贴到博文中就行了，访问速度杠杠的 上传图片到 PicGo 并使用图床 此外 PicGo 还有相册功能，可以对已上传的图片进行删除，修改链接等快捷操作，PicGo 还可以生成不同格式的链接、支持批量上传、快捷键上传、自定义链接格式、上传前重命名等，更多功能自己去探索吧！","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"}]},{"title":"如何构建知识体系","slug":"Tools/如何构建知识体系","date":"2019-11-22T17:09:07.000Z","updated":"2020-08-07T10:28:56.454Z","comments":true,"path":"posts/18572.html","link":"","permalink":"http://www.a2data.cn/posts/18572.html","excerpt":"成长是什么呢？","text":"成长是什么呢？ 成长就是孤独的把委屈和泪水拼命的咽下去不让别人知道。 只有在孤独中，才能够更好的意识到自己真正追求的是什么，才能不局限于当下的小事，放眼更远大的志向。 知识体系 是在(恰如其分、环环相扣的)提问和实践的基础上形成的概念和概念间联系的集合，知识点之间彼此形式多样的方式关联，形成了特定的结构。 知行概念 = 内涵 + 外延 + 联系（知 -&gt; 行） 外延的常用描述方式 “是什么而不是什么”，经验是用枚举外延以及枚举高价值联系的方式来对提升概念理解的精确度，即将内涵方式描述不显而易见的加入到备忘录。 理解 = 能够枚举更多概念的CASE以及概念间的联系，理解就是 识 -&gt; 记 -&gt; 忆（用场景+联系来唤醒，记的时候想着忆，写的时候想着读）。 学以致用的基础是理解概念间的高价值联系，而发挥力量的关键是显性表达。 我们可以借助“八大问”，来分析信息、观点、事件、经历等，从中整理出概念和联系。八大问是一个提问的框架，将针对信息、观点、事件、经历等的提问，分为“前、因、后、果、适、用、边、界”八类。 八大问可以分为两组，前因后果用于分析信息，适用边界用于整理信息。 前（前车之鉴）：为什么这件事对我重要？它是怎么引出这个信息的？ 因（相因相生）：作者有哪些关于原因的假设？怎么验证或排除这些假设？还有其他可能性吗？ 后（以观后效）：从已有信息去做之后会怎样？对我的好处（效用）是什么？ 果（自食其果）：不这么做的后果是什么？不改变的问题有多严重？ 适（适得其反）：有没有相反的观点？有没有不支持这个实现的案例(CASE to CASE)？ 用（使用条件）：要这样做，需要具备哪些条件？（考虑 成本、收益、效率、安全、态度、能力 等）这件事可以哪些方式来完成？ 边（旁敲边鼓）：从前有没有类似的（或乍看起来差不多的）信息？其他 （领域 | 行业 | 人）如 何解决类似问题呢？ 界（楚河汉界）：无论是相反的还是类似的信息，和这个信息的真正区别是什么？交界在哪里？ 应用指南 在使用八大问时，不一定要原模原样地问上面列举出的示范问题，可以在理解这八类问题的前提下，针对具体情境，提出合适的问题。也就是说，八大问最重要的是提供了一种提出有洞察力的问题的框架，这是他的意义所在。如果你有能力，可以领会心法，保持心法不变，提出新的问题。 如果一开始不知道怎么用，则建议直接使用示范问题或在其基础上做变化。欢迎一起探讨哦。","categories":[{"name":"职场","slug":"职场","permalink":"http://www.a2data.cn/categories/%E8%81%8C%E5%9C%BA/"}],"tags":[{"name":"毒鸡汤","slug":"毒鸡汤","permalink":"http://www.a2data.cn/tags/%E6%AF%92%E9%B8%A1%E6%B1%A4/"}],"author":"Jack风"},{"title":"Markdown","slug":"Tools/Markdown","date":"2019-11-11T12:43:06.000Z","updated":"2020-08-07T10:29:22.185Z","comments":true,"path":"posts/17683.html","link":"","permalink":"http://www.a2data.cn/posts/17683.html","excerpt":"‘MD,原来是这么用的，你懂了吗？’","text":"‘MD,原来是这么用的，你懂了吗？’ MarkDown 用法精选Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 强力推荐: TproaMarkDown编辑器跨平台 完美运行. Hexo```MHexoEditor编辑器博客好助手 完美支持 Hexo 博文. 优点：1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可 缺点：1、需要记一些语法（当然，是很简单。五分钟学会）。2、有些平台不支持Markdown编辑模式。 一、标题 在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。 示例：# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： # 如上是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 二、字体 加粗要加粗的文字左右分别用两个号包起来斜体要倾斜的文字左右分别用一个号包起来斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来删除线要加删除线的文字左右分别用两个~~号包起来 示例： **这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下：这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 三、引用块 在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 示例： &gt;这是引用的内容 &gt;&gt;这是引用的内容 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。 示例： --- ---- *** ***** 效果如下： 可以看到，显示效果是一样的。 五、图片语法： ![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： ![img][A2DATA](/resource/image/markdown/1.png) 效果如下： - hexo 3 &amp;#123;% asset_img test.jpg This is an test image %&amp;#125; 上传本地图片直接点击导航栏的图片标志，选择图片即可 六、超链接语法： [超链接名](超链接地址 &quot;超链接title&quot;) title可加可不加 示例： [简书](http://jianshu.com) [百度](http://baidu.com) 效果如下： 简书百度 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 &lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt; 示例 &lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt; 七、列表 无序列表 语法： 无序列表用 - + * 任何一种都可以 - 列表内容 + 列表内容 * 列表内容 注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表 语法： 数字加点 1.列表内容 2.列表内容 3.列表内容 注意：序号跟内容之间要有空格 效果如下： 1.列表内容 2.列表内容 3.列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 八、表格语法： 表头|表头|表头 ---|:--:|---: 内容|内容|内容 内容|内容|内容 第二行分割表头和内容。 - 有一个就行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略 示例： 姓名|技能|排行 |--|:--:|--:| |欢迎|关注|微信| |公号|平台|A2DATA| |我们|一起|加油| 效果如下： I II III 欢迎 关注 微信 公号 平台 A2DATA 我们 一起 加油 九、代码语法： 单行代码：代码之间分别用一个反引号包起来 `代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 (```) 代码... 代码... 代码... (```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例： 单行代码 `create database hero;` 代码块 (```) function fun()&amp;#123; echo &quot;这是一句非常牛逼的代码&quot;; &amp;#125; fun(); (```) 效果如下： 单行代码 create database hero; 代码块 function fun()&amp;#123; echo &quot;这是一句非常牛逼的代码&quot;; &amp;#125; fun(); 十、流程图 graph LR A[方形] --&gt;B(圆角) B --&gt; C&amp;#123;条件a&amp;#125; C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] graph TD A[方形] --&gt;B(圆角) B --&gt;C&amp;#123;条件a&amp;#125; C --&gt;|a=1|D[结果1] C --&gt;|a=2|E[结果2] F[竖向流程图] 效果如下： graph LR start[开始] --&gt; input[输入A,B,C] input --&gt; conditionA&amp;#123;A是否大于B&amp;#125; conditionA -- YES --&gt; conditionC&amp;#123;A是否大于C&amp;#125; conditionA -- NO --&gt; conditionB&amp;#123;B是否大于C&amp;#125; conditionC -- YES --&gt; printA[输出A] conditionC -- NO --&gt; printC[输出C] conditionB -- YES --&gt; printB[输出B] conditionB -- NO --&gt; printC[输出C] printA --&gt; stop[结束] printC --&gt; stop printB --&gt; stop","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"},{"name":"MarkDown","slug":"MarkDown","permalink":"http://www.a2data.cn/tags/MarkDown/"}]},{"title":"Strive","slug":"Tools/strive","date":"2019-11-04T14:11:30.000Z","updated":"2020-08-07T10:29:35.053Z","comments":true,"path":"posts/18321.html","link":"","permalink":"http://www.a2data.cn/posts/18321.html","excerpt":"‘在你牛到一定程度前,所有的一切全是态度问题。’","text":"‘在你牛到一定程度前,所有的一切全是态度问题。’ 你为什么[努力]? 一位麦肯斯7年老员工的忠告：所谓的能力问题，全都是态度问题！ 态度哪有那么多「能力问题」，在你牛到一定程度前，全是「态度问题」 职场上有句话，「ta这是能力问题，工作态度还是好的」。 通常做得不够好的时候，「能力问题」似乎就比较容易得到谅解。 我承认，时代、机缘、天赋、性格、出身、早年教育，等等这些我们无法全然掌控的因素，关系重大，或许将我们的个人「能力」划定在某个范围内。 生活，是公平的，你选择了自己轻松，那你身边的家人一定会为你的选择付出成本和代价。 有些事情，你尝试了不一定可以成功，但是你不尝试，肯定是一丝可能都没有。· 努力的理由最近突然明白，一个人努力的理由是什么。 是为了在看到自己喜欢的东西时，毫不犹豫拿起就付款的大方样子； 是为了想去一个地方时再也不用精打细算的计划费用，而是领包就走毫无顾虑的潇洒样子； 是为了遇到自己喜欢的人，再也不用担心自己配不上对方，而是在对方面前自信满满的样子； 是为了过再也不用对别人点头哈腰的日子。 总结起来，就是一句话： 我之所以这么努力， 是为了能过上自己想要的生活， 能与自己所爱的人自信满满的打招呼， 而不是畏首畏尾，连说句“你好”都觉得卑微。 梦在远方，路在脚下 这世界上 从来没有谁能够 随随便便成功 天才也需要99%汗水的付出 相信自己可以去改变境遇，有这点志气，才能有撸起袖子去行动的能力。 正如瑞达利欧在《原则》中所写： 没有什么比「明白现实世界如何运作」并且「如何应对它」更重要的事，而你在这个过程中的心态，决定了所有的差别。 生活不止眼前的苟且，还有远方的苟且。","categories":[{"name":"职场","slug":"职场","permalink":"http://www.a2data.cn/categories/%E8%81%8C%E5%9C%BA/"}],"tags":[{"name":"毒鸡汤","slug":"毒鸡汤","permalink":"http://www.a2data.cn/tags/%E6%AF%92%E9%B8%A1%E6%B1%A4/"}]},{"title":"SublimeText","slug":"Tools/SublimeText","date":"2019-09-23T14:17:10.000Z","updated":"2020-08-07T10:18:18.005Z","comments":true,"path":"posts/55860.html","link":"","permalink":"http://www.a2data.cn/posts/55860.html","excerpt":"超级编辑器","text":"超级编辑器 SublimeText 必备插件第一步 安装 Package Control组件快捷键 Ctrl+` import urllib.request,os; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#39;wb&#39;).write(urllib.request.urlopen( &#39;http://sublime.wbond.net/&#39; + pf.replace(&#39; &#39;,&#39;%20&#39;)).read()) 如果在Perferences-&gt;中看到package control这一项，则安装成功。 解决中文乱码问题Mac 快捷键： Cmd+ shift + p Windows : Ctrl + shift + p 1、打开 package control 2、输入： Install Package 3、安装 ： ConvertToUTF8插件 主题安装 Material theme 主题 安装方法：Ctrl(Mac下Cmd)+Shift+P install package -&gt; Material Theme install package -&gt; A File Icon 字体 装好又到之前的 首选项—–用户设置（user ）：选择字体：如果存在就修改为Fira Code，不存在就添加下面这行代码， &quot;font_face&quot;: &quot;Fira Code&quot; 至此大功告成，谢谢 字体安装路径 C:\\Users\\Desktop\\FiraCode-master\\FiraCode-master\\distr\\ttf FiraCode-master 字体下载已经上传到微云 更多骚操作等待你一起探讨哦 如需破解广告版本，请添加微信公众号：A2Data 联系小编获取哦。","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"}]},{"title":"Linux安装","slug":"Linux/Linux安装","date":"2019-09-13T11:15:31.000Z","updated":"2020-08-07T10:26:38.958Z","comments":true,"path":"posts/43150.html","link":"","permalink":"http://www.a2data.cn/posts/43150.html","excerpt":"linux介绍及安装","text":"linux介绍及安装 一、Linux简介linux是一种由unix衍生出来的操作系统，，操作系统是用户和计算机之间的界面. 一方面操作系统管理着所有计算机系统资源,另一方面操作系统为用户提供了一个抽象概念上的计算机. 在操作系统的帮助下, 用户使用计算机时,避免了对计算机系统硬件的直接操作.二、Linux国内流行版本介绍1、Redhat2、CentOS3、Suse4、红旗（redflag）三、Linux 优点 1.稳定2.多线程3.架构可扩展4.开源5.简单（IT）四、Linux 缺点 1.技术要求相对较强2.图形界面不够好五、安装安装RedHat系统的方法有很多种，我们主要介绍如何使用光盘安装方法安装RedHat系统。既然说Linux是一种操作系统那么最常用的操作系统就是windows日常生活中它是一般装到我们的pc上的，大多数的企业会使用Linux系统装在服务器上的，所以为了模拟环境我们用了一个软件叫做VMware它能够帮我们实现一个虚拟的网络环境还支持很多系统，下面我们就来安装一下Redhat6.4准备镜像rhel-server-6.4-x86_64-dvd.iso首先安装VMware这个直接去网上下载安装就好 安装好以后我们会看见一下这个界面建议大家使用英文版的，在企业工作大多数都是英文，先熟悉一下环境 1、首先我们新建一个虚拟机 2、选择典型 3、选择稍后安装操作系统，后期我们自己挂载镜像 4、接下来选择linux的版本，根据自己下载的镜像版本而定 5、下一步给虚拟机取一个名字，给它一个存放路径，注意：路径最好不要出现中文 6、下面是磁盘大小和，将虚拟磁盘统一成一个文件 7、检查一下如果没有问题点击finish 8、在左上方会出现一个linux这就是我们即将安装的虚拟机，然后选择镜像 9、把开始下载的镜像路径添加到上面点击ok 10、然后运行此虚拟机 Linux安装1、选择第一项，然后回车： 2、跳过光盘质量测试提示上一步回车后，将出现下面的界面，使用“Tab”键切换到“Skip”，然后回车： 3、点击next如果鼠标不能移动可用Ctrl+Alt进行切换 4、选择安装过程使用的语言选择安装过程使用的语言：中文(简体)，然后点“Next”（还是建议大家使用英文的，这里为了方便讲解就用中文了） 5、设置键盘设置键盘为“美国英语式”，然后点“下一步”： 6、选择系统使用的存储设备一般情况，均默认选择“基本存储设备”，然后点“下一步”： 7、出现下图提示时，点击“是，忽略所有数据”： 8、设置计算机名可根据实际情况，对计算机主机名进行命名也可以安装好后用命令行进行更改 9、配置网络点击界面左下角的“配置网络”，配置服务器网络：选中eth0进行配置 点击“编辑” 勾上“自动连接” 选择“IPv4设置”选项卡，“方法”选择“手动” 点击“添加” 分别点击并配置“地址”、“子网掩码”、“网关” 填上“DNS服务器”地址（如果没有可不填，多个DNS用逗号分隔） 点击“应用”完成配置可参考下图： 选择系统时区时区默认为“亚洲/上海”，注意需要去掉“系统时钟使用UTC时间”前面的勾，然后点“下一步”： 设置root账户密码建议输入一个复杂组合的密码，密码包含：大写、小写、数字、符号 10、磁盘分区创建自定义布局分区 10.1、创建第1个分区（启动分区）： 10.2、配置1.“挂载点”选择“/boot”2.“大小(MB)”填入“300”3.点击“确定” 10.3 创建第2个分区（主分区）1.“挂载点”选择“/home”2.“大小(MB)”填入“8000”（根据实际硬盘大小填写）3.点击“确定” 11、重复创建步骤1.“文件系统类型”选择“swap”2.“大小(MB)”填入“800”（根据实际内存大小填写，一般为内存的1.5-2倍，不大于8G）3.点击“确定”创建第4个分区（根分区）：重复创建步骤1.“挂载点”选择“/”2.勾选“使用全部可用分区”3.点击“确定” 点击下一步进行格式化 点击修改写入磁盘 只有一个盘所以点击下一步即可 基础软件安装 各项包含软件Desktop :基本的桌面系统，包括常用的桌面软件，如文档查看工具。Minimal Desktop :基本的桌面系统，包含的软件更少。Minimal :基本的系统，不含有任何可选的软件包。Basic Server：安装的基本系统的平台支持，不包含桌面。Database Server :基本系统平台，加上mysql和PostgreSQL数据率，无桌面。Web Server :基本系统平台，加上PHP, Web server，还有mysqI和PostgreSQL数据库的客户端，无桌面。Virtual Host :基本系统加虚拟化平台。Software Development Workstation :包含的软件包较多，基本系统，虚拟化平台，桌面环境，开发工具。注意：我们一般运行的时候都不会使用桌面，这里我们就不安装桌面了，其他的软件后期需要我们也可以再安装。 勾选ftp服务器 点击下一步开始安装 至此完成安装 进入系统 出现以下界面证明你成功了 使用root用户，输入你的密码就可以使用了","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Hexo图片问题","slug":"Hexo/Hexo图片问题","date":"2019-09-05T15:41:52.000Z","updated":"2020-08-07T08:56:43.926Z","comments":true,"path":"posts/ee789513.html","link":"","permalink":"http://www.a2data.cn/posts/ee789513.html","excerpt":"Hexo 上传图片相关的问题。","text":"Hexo 上传图片相关的问题。 使用hexo上传图片，但是发现在文章中引用本地图片时总是显示不出来。花费了许久时间才解决这个问题。因此将一些解决经验整理出来，希望能帮助到大家。 一、插件安装与配置 首先我们需要安装一个图片路径转换的插件，这个插件名字是hexo-asset-image npm install https://github.com/CodeFalling/hexo-asset-image --save 但是这个插件的内容需要修改【不然可能会出Bug】 打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码 &#39;use strict&#39;; var cheerio = require(&#39;cheerio&#39;); // http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string function getPosition(str, m, i) &amp;#123; return str.split(m, i).join(m).length; &amp;#125; var version = String(hexo.version).split(&#39;.&#39;); hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&amp;#123; var config = hexo.config; if(config.post_asset_folder)&amp;#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &#39;/&#39;, 1) + 1; else var beginPos = getPosition(link, &#39;/&#39;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&#39;/&#39;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;]; for(var i = 0; i &lt; toprocess.length; i++)&amp;#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &amp;#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &amp;#125;); $(&#39;img&#39;).each(function()&amp;#123; if ($(this).attr(&#39;src&#39;))&amp;#123; // For windows style path, we replace &#39;\\&#39; to &#39;/&#39;. var src = $(this).attr(&#39;src&#39;).replace(&#39;\\\\&#39;, &#39;/&#39;); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &amp;#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&#39;/&#39;).filter(function(elem)&amp;#123; return elem != &#39;&#39;; &amp;#125;); var srcArray = src.split(&#39;/&#39;).filter(function(elem)&amp;#123; return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;; &amp;#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&#39;/&#39;); $(this).attr(&#39;src&#39;, config.root + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src); &amp;#125; &amp;#125;else&amp;#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &amp;#125; &amp;#125;); data[key] = $.html(); &amp;#125; &amp;#125; &amp;#125;); 打开根目录下的_config.yml文件，修改下述内容post_asset_folder: true 二、问题推测1、本地图片没有有效的上传至github仓库中，导致引用无效解决方案，安装插件，请看上文如何安装 2、本地图片没有存放在同名文件夹下解决方案，将需要引用的本地图片存放在与文章名相同的文件夹中 3、图片路径出错这里多数人可能会将url 写成自己的域名。 切记：需要写成自己github项目的地址。我刚开始也错了。 4、相对路径引用的标签插件 通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 也就是说在存档页和主页不能使用和文章内容中的常规语法来引用图片。 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](/a2data.jpg) ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作） 正确的引用图片方式是使用下列的标签插件而不是 markdown ：———————————————— &amp;#123;% asset_img example.jpg This is an example image %&amp;#125; 这是一个MD引入图片 这是标签引用方式","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/categories/Hexo/"},{"name":"Img","slug":"Hexo/Img","permalink":"http://www.a2data.cn/categories/Hexo/Img/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/tags/Hexo/"}]}],"categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/categories/Hexo/"},{"name":"Cmomand","slug":"Hexo/Cmomand","permalink":"http://www.a2data.cn/categories/Hexo/Cmomand/"},{"name":"DataBase","slug":"DataBase","permalink":"http://www.a2data.cn/categories/DataBase/"},{"name":"Mysql","slug":"DataBase/Mysql","permalink":"http://www.a2data.cn/categories/DataBase/Mysql/"},{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"数据可视化","slug":"数据可视化","permalink":"http://www.a2data.cn/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"},{"name":"JavaSE","slug":"Java/JavaSE","permalink":"http://www.a2data.cn/categories/Java/JavaSE/"},{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"},{"name":"数据库","slug":"数据库","permalink":"http://www.a2data.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据库工具","slug":"数据库工具","permalink":"http://www.a2data.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B7%A5%E5%85%B7/"},{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"},{"name":"Blog","slug":"Hexo/Blog","permalink":"http://www.a2data.cn/categories/Hexo/Blog/"},{"name":"职场","slug":"职场","permalink":"http://www.a2data.cn/categories/%E8%81%8C%E5%9C%BA/"},{"name":"Gitee","slug":"Hexo/Gitee","permalink":"http://www.a2data.cn/categories/Hexo/Gitee/"},{"name":"Git","slug":"Git","permalink":"http://www.a2data.cn/categories/Git/"},{"name":"IDEA","slug":"IDEA","permalink":"http://www.a2data.cn/categories/IDEA/"},{"name":"大数据","slug":"大数据","permalink":"http://www.a2data.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Img","slug":"Hexo/Img","permalink":"http://www.a2data.cn/categories/Hexo/Img/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/tags/Hexo/"},{"name":"Mysql","slug":"Mysql","permalink":"http://www.a2data.cn/tags/Mysql/"},{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"Anaconda","slug":"Anaconda","permalink":"http://www.a2data.cn/tags/Anaconda/"},{"name":"数据可视化","slug":"数据可视化","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"},{"name":"集合体系","slug":"集合体系","permalink":"http://www.a2data.cn/tags/%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB/"},{"name":"API","slug":"API","permalink":"http://www.a2data.cn/tags/API/"},{"name":"正则","slug":"正则","permalink":"http://www.a2data.cn/tags/%E6%AD%A3%E5%88%99/"},{"name":"JDK","slug":"JDK","permalink":"http://www.a2data.cn/tags/JDK/"},{"name":"Java基础","slug":"Java基础","permalink":"http://www.a2data.cn/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"基础语法入门","slug":"基础语法入门","permalink":"http://www.a2data.cn/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/"},{"name":"JDK环境","slug":"JDK环境","permalink":"http://www.a2data.cn/tags/JDK%E7%8E%AF%E5%A2%83/"},{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"},{"name":"图床","slug":"图床","permalink":"http://www.a2data.cn/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Typora","slug":"Typora","permalink":"http://www.a2data.cn/tags/Typora/"},{"name":"Gitee","slug":"Gitee","permalink":"http://www.a2data.cn/tags/Gitee/"},{"name":"VMware","slug":"VMware","permalink":"http://www.a2data.cn/tags/VMware/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://www.a2data.cn/tags/Hadoop/"},{"name":"Cloudera","slug":"Cloudera","permalink":"http://www.a2data.cn/tags/Cloudera/"},{"name":"MobaXterm","slug":"MobaXterm","permalink":"http://www.a2data.cn/tags/MobaXterm/"},{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://www.a2data.cn/tags/Shell/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://www.a2data.cn/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"},{"name":"资料分享","slug":"资料分享","permalink":"http://www.a2data.cn/tags/%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB/"},{"name":"学习资源","slug":"学习资源","permalink":"http://www.a2data.cn/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"},{"name":"Git","slug":"Git","permalink":"http://www.a2data.cn/tags/Git/"},{"name":"IDEA","slug":"IDEA","permalink":"http://www.a2data.cn/tags/IDEA/"},{"name":"编码工具","slug":"编码工具","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A0%81%E5%B7%A5%E5%85%B7/"},{"name":"GitBook","slug":"GitBook","permalink":"http://www.a2data.cn/tags/GitBook/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.a2data.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://www.a2data.cn/tags/Ubuntu/"},{"name":"MapReduce","slug":"MapReduce","permalink":"http://www.a2data.cn/tags/MapReduce/"},{"name":"ApaHive","slug":"ApaHive","permalink":"http://www.a2data.cn/tags/ApaHive/"},{"name":"面经","slug":"面经","permalink":"http://www.a2data.cn/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"运营工具","slug":"运营工具","permalink":"http://www.a2data.cn/tags/%E8%BF%90%E8%90%A5%E5%B7%A5%E5%85%B7/"},{"name":"毒鸡汤","slug":"毒鸡汤","permalink":"http://www.a2data.cn/tags/%E6%AF%92%E9%B8%A1%E6%B1%A4/"},{"name":"MarkDown","slug":"MarkDown","permalink":"http://www.a2data.cn/tags/MarkDown/"}]}