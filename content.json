{"meta":{"title":"DataScience","subtitle":"","description":"","author":"JackFeng","url":"http://www.a2data.cn","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-08-01T03:24:02.867Z","updated":"2020-08-01T03:24:02.867Z","comments":true,"path":"404.html","permalink":"http://www.a2data.cn/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2020-09-11T09:55:13.993Z","updated":"2020-09-11T09:55:13.993Z","comments":true,"path":"README.html","permalink":"http://www.a2data.cn/README.html","excerpt":"","text":"A2DataDataScience 公众号 博客站点！"},{"title":"","date":"2020-09-14T12:23:47.733Z","updated":"2020-09-14T12:23:47.733Z","comments":false,"path":"Creator-said/index.html","permalink":"http://www.a2data.cn/Creator-said/index.html","excerpt":"","text":"畅所欲言"},{"title":"","date":"2020-09-12T11:40:27.798Z","updated":"2020-09-12T11:40:27.798Z","comments":true,"path":"about/index.html","permalink":"http://www.a2data.cn/about/index.html","excerpt":"关于我 Jack跨行的经历！","text":"关于我 Jack跨行的经历！ 一个成功跨行者的自述年轻，是我们唯一拥有权力去编织梦想的时光。 为什么说我的跨行经历呢，因为我的专业特殊，以及经历上的与众不同，全网唯一都不为过。下面来看看我的介绍。（来自粗人的自述） 年少风 学校： 山西师范大学体育学院(1本) 专业： 武术于民族传统体育 爱好： 软件控 &amp; 技术控 运动、健身、项目策划、有想法并愿意为之努力 Dream 梦想用大数据&amp;人工智能推动传统行业的发展。 行动是一切梦想的起点 没有什么，比犹豫和纠结更浪费时间。 只要你去做，那么一切就会简单起来。 大学特招之路特招 对于很多人来说，这是个比较特殊的渠道，对于我们上大学来说，需要在上大学前，就要参加比赛，打到省前三，才可以有二级证书。也就是成为二级运动员。 有了这个证书之后，你才可以报名参加特招考试。 我记得我那一届参赛选手有700+，然后我们整个系别招收人数不到70，也就基本上是十几个人里边选一个，而且是定点定考，就是你想去哪个学校，就得报哪个学校去考试。然后考文化课，以及专业，是以专业分数为优先录取，我当时考了89分，当时录取分数是往届最高的，75分。给大家基本普及一下我当时考试的内容。 很荣幸,我被录取了，录取名单在高考前就出来了，然后后边我还参加了一天的高考考试，用教练的话说，就是去体验体验高考的氛围。当时就自己写了点，然后睡了会，后边的姑娘还把试卷漏出来给我抄，我前边的同学也是认识的，学习好的那种，我都懒得抄，监考老师还帮我挡摄像头，我简直觉得自己遇到传说中的好老师，好队友，所以后来，我就没参加了。 怕影响别人。 因为我们的付出比常人更多，每天早上5点起，拉练一般最少是 5-7公里，当时有一个7.2 ，然后蛙跳，到7:30左右，晨练结束，开始吃饭，放松休息一下，从9点开始训练到中午，一般其他时间 都是以反应靶，空击、实战为主。 有一次去塔沟特训，教官只要第一名，真的是有几次吃不上早饭，不是因为你跑的慢，不达标，而是因为你们团队有人不符合，你快了不行，慢了也不行。这个经历是我受用终身的，人的潜力只有在特定的条件下才能最大价值的发挥出来。也让我从那时开始有了团队意识。 大学生涯2013年，我成功进入山西师范大学体育学院，可以毫不夸张的说，整个山西省百分之七八十的教师都是出自我们学校。 大一大二， 之后 暑期去过国企 ：北京公交总站，富士康，管理跆拳道馆，运营公众号合作。(那个时候，我就有了公众号，只不过开始都是给道管做) 为了梦想，你愿意付出什么？ 当别人都还在玩游戏，周六日出去玩的时候，你愿意去道馆代课么？当别人都舍不得买个u盘的时候，你愿意花5 6 百去买个1T 的移动硬盘吗？ 什么东西都是需要付出的，你做了多少未必有一定比例的收获，但是你不做，一定不会有收获。 你所有的付出都是为你心中的梦想去奠定基础。 久而久之，渐渐的发现，不论是一个技术工，还是一个教练，你的价值都只是在当前的一个工作时间， 一堂有趣的课程；学习ps （目前还是很low逼的设计）之后，我发现一门教程，可以影响很多人， 但是起初的付出只需要一分，而不论是教练或者是打工，你的价值都只是当前。 毕业时的抉择才是最艰难的 \\对于不爱学习的我：** 有一个技术梦，随着不断接触到计算机方向的东西。 起初的安装系统，到收集各类破解软件，觉得，哇，大牛 好厉害。之后，从开始辛苦的付出，到目前转行从业的大数据 人工智能 机器学习。 你的努力到底应该是怎样的呢？ 不是你有多少种想法，你掌握多少资源，你拥有多少朋友；而是 你在思考了之后，去做了什么，去舍弃了什么，去改变了什么！！！ 自媒体的所遇所感关于方向2018年10月，我开启了自己的公号之旅。也成了跟很多号主一样的作息，甚至经常凌晨一两点休息，一篇原创文章可能需要写2-3天，每天大概需要2-3小时，很多人就会说，不就是一篇文章么？ 有这么南么？ 首先，我开始的定位是大数据，大数据集群的安装是必不可少的一部分，不信你试试，搭建一台完全分布式的集群，配置好大数据的各个组件。 同时你又要一步一步操作，截图，分享。 如果你的机器不给力。可能卡死都有可能的。 所以不要以为什么都是那么简单的。看着做，跟自己做还是两码事！ 于是，从一个跨行的小白，就开始分享自己的大数据学习之旅，然后也有每个号主刚开始的激情，不断更，即使很晚也坚持去写。所以刚开始的阅读量还不错，但后来渐渐发现，定位不够垂直，大佬们说我写的太详细了。 但我从小白过来，我理解的只有小白才懂小白的痛点，为什么这么说呢？ 因为当你会了之后呢，你再去写的时候，你就会潜意识的略过一些较为基础，同时小白不懂得这些点。 然后我就坚持我的想法，写了下来了。 并且，我因为工作参与项目较多，所以分享的范围也比较广。 1Linux Hadoop HiveSQL Python Java Vue Git 等等 `后续会聚焦在数据领域` 那么，你就会看到我公众号内容比较杂，但很多都是干货，骚操作。这点我也会花时间整理一下。重新上线，让大家方便快捷的涨点知识。少踩点坑。多一些经验以及实操。有些跨行的经验，后续我会更新在星球，或者网站。 相信现在大家看到公号，发现写文章的比看文章的还多，因为一方面，号主不断引领粉丝发展自媒体，另一方面，公众号如果你玩的好，套路深，收益还是蛮大的。 看阅读量来定价格接广告的。 甚至有的号，你可以看到只有几篇原创，但是阅读量很高。所以就很值钱。 我呢，甚至组建了好几拨人，团队式的发文，最终都失败了。(原因有很多)，我从中学会很多，由于开始niubility 吹的有点大， 起名叫做 Ai大数据与机器学习，大数据还好，机器学习 不咋懂，受众也很宅。只有大数据的还好。也坚持了半年，中间有些事情，耽搁一段时间没更文。 后来想聚焦与数据，各行各业都离不开数据。 所以改名叫做—-&gt; A2Data 后来改名的更加专业： DataScience 重点 如果你开始了，自媒体之旅，那么断更 将是你最大的敌人。 不知道你看没看过李佳琦的直播，他之所以火，是因为他每天连续直播3-4个小时。 你不知道有多少个公众号，你一天不断更，就会被淹没。 所以，如果你是为了通过这盈利。 那么坚持是必须的。 而且你会发现，如果跟你同一批用户，刚开始做，你断更了两个月， 你会发现别人的号都做起来了，mmmp，真是个魔化的世界。(有木有) So, 一定要坚持 不断输出 曝光 内容输出，垂直领域。 固定时间，保持高频输出 排版标题，规划，一定要有规划 复盘，也就是最重要的一点，很多人都不做的 关于内容简单来说，一个公众号也好，朋友圈也好，知乎简书，都是在打造个人品牌。甚至大到公司，都是在做宣传，品牌。 写作的价值？写作是人人都需要的底层能力 1、沟通能力决定了你链接资源的效率。 2、写作是倒逼成长的绝佳方法 3、写作是学习效果 个人能力的放大器 个人品牌如何打造？简单讲 技能定位 + 持续曝光 持续曝光，就需要借助写作能力。 思路 职场简语 **英文 + 经典语录 ** 软文要素闪电胰腺 三点一线 三点： 寻找软文的核心诉求 痒点： 消费者享受的体验 （Good Experience） 痛点： 无法获得该功能会有什么痛苦 （Terrible Felling） 利益点： 解决方案 （Benifit Point ） 一线：故事性【热点、冲突、惊悚、情感、悬念、幽默、争议、名人等】 GTB核心 即用故事性的叙述来铺垫和陈述GT，最后用B收尾。 图样理论 1、以图代文，分段易读。 2、切记开门见山，不可以直接上来就说品牌、产品等 3、内容由浅入深，有趣打头。 4、受众第一，要有读者心态。 软文的目的是被阅读，没有打开率，一切都是无用功 {读者心态--&gt; 娱乐、八卦、时事、搞笑。。。} 关于工具 其实，我是个不折不扣的工具控。 一般朋友们有什么软件，工具的需要，都会找我，什么黑科技啥的？(偷笑) 对于号主来说，排版是一个最大的问题。 根据我一直以来的经验，这里给大家几点建议。 关于知识 不知道你是否也看到了？ 有这么一个现象 自从入了互联网， 发现很多人喜欢 ‘囤知识 囤资料’ 收藏xxx的干货，百度云盘可能存了好几T 的资源 但是，你真正掌握的有多少呢？ 学习了，做了多少？ 很多人有一个错觉，自以为关注了好多公众号，加了很多好友，积攒了很多资料，其实大多数是打广告的资料，你真正看的也不会有的。 在这里，小编的建议是：希望你可以选择一个方向，踏踏实实的学一点，有的时候，什么都做，什么都会，结果也可能是，什么都做不好，什么都不会 该奋斗的年纪，就不要再飘了市场永远不会一成不变的，所以，改变就是好事为什么会说着一点呢？ 因为很多人本来写公众号是分享个人经历，成长的，看到市场的利益，就会变得利益化；于是乎，有了很多小白蜂拥而至。时间花在了增粉、阅读、加人，微群，发圈，你会发现越来越的文章只是题目不一样，内容都一样。 用户好感度就降低了。 所以，微信现在对原创号非常友好。 其实，以上不是重点，重点是在本该奋斗的年级，应该踏踏实实的去提升自己，拥抱市场，而不是所谓的跟风。 我断更期间，自己有时候玩会游戏，真香，健健身，发现真的是好。 日常工作我都是爬楼梯上楼的，试问？每天运动的人，跟每天不动的人，长期结果能一样吗？ 你去练了两天拳，跟练了几年的，能一样？ 所以在该努力的年纪，希望大家，沉淀下来，好好想想，自己到底需要什么？可以去做什么？ 改变了哪些？还需要补充哪些？ 我时常鼓励我的朋友，激励他们说：你看我跨行都可以的 你们会更优秀的。 摸鱼一时爽，一直摸鱼一直爽 为什么越来越多人，交完智商税，反而混的比之前更差了，首先说一下，例如你进了某某某大佬的知识星球，或者加个好友，并不代表你厉害了，而是你是想向他学习之一，你是付费用户，其次，你的摸鱼时间更久了，你会应酬大佬吧，也许会关注更多的圈子动态，你划水的本领越来越强了。而大佬还是大佬，因为他已经经历过曾经你没有经历过的时光，遇上你没有遇上的风口，例如我跨行大数据的风口，现在你试试？ 再说说，我删了2k人的感想，我的公众号，基本上发文章不推文，不怎么发圈，不发群，也没有建立自己的微信群。 所以阅读量 活跃度 也很少。加了很多号主，有认识的不认识的。 也有很多好友。发现莫名的被删，莫名的被拉群。工作都忙不过来，所以 我花了近半个月的时间，删除了2k+好友 退出了200+微信群。现在相对亲近多了。 所以没有必要的社交，不对等的资源的社交，最终只是被割韭菜的下场，资源不会跑的，关键看你有没有实力。 1、未来制造业将不再是主要的雇主，人工智能和自动化将取代工人。人应该回归去做人类更擅长的、具备创造力、体验性的工作。 2、网上90%的评论都是没脑子的评论，各种水军和谣言是精神排泄物。 信息开放的时代，取出对你真正有价值的信息，帮助，资源，其实是一门学问，以前人人都是产品经理，现在人人都是数据分析。 对于我来讲： 成功就是用99次失败去尝试一次成功的可能性 那么对于新人来讲：技术就是最好的入场劵！ 亲爱滴朋友们，感谢您的阅读，流年笑掷 未来可期"},{"title":"archives","date":"2020-07-31T15:11:22.000Z","updated":"2020-07-31T15:11:22.852Z","comments":true,"path":"archives/index.html","permalink":"http://www.a2data.cn/archives/index.html","excerpt":"","text":""},{"title":"","date":"2020-08-03T09:52:03.000Z","updated":"2020-09-14T12:23:47.743Z","comments":true,"path":"books/index.html","permalink":"http://www.a2data.cn/books/index.html","excerpt":"","text":"书籍推荐 2020-09-12 1.21 -&gt; 1.22 如果有 喜欢的文章 ，点击 按钮 。请输入你的真实邮箱,按照以下格式留言1234567&#123;% folding cyan, 相关主题 %&#125;&#123;% btns circle grid5 %&#125;&#123;% cell 书籍名称, 书籍地址, 书籍封面 %&#125;&#123;% endbtns %&#125;&#123;% endfolding %&#125;欢迎贡献更多好书 。 2020-09-10 1.2 -&gt; 1.21 特殊节日: 长大方知少年纯、回首才懂师恩深 2020-08-20 1.0-&gt; 1.2 推、荐、微、信、读、书。 如何找书 快速找书https://weread.qq.com/#search 技术书籍好书推荐学习使我快乐 Python相关 Python编程：从入门到实践利用Python进行数据分析（原书第2版）超简单：用Python让Excel飞起来Python Qt GUI与数据可视化编程Python网络爬虫从入门到实践 Spark相关 Spark SQL入门与实践指南Spark大数据分析实战Spark全栈数据分析 推荐 价值：我对投资的思考"},{"title":"所有分类","date":"2020-08-01T03:20:39.634Z","updated":"2020-08-01T03:20:39.634Z","comments":true,"path":"categories/index.html","permalink":"http://www.a2data.cn/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-08-01T03:57:10.000Z","updated":"2020-09-14T12:23:47.725Z","comments":true,"path":"contact/index.html","permalink":"http://www.a2data.cn/contact/index.html","excerpt":"","text":"噫，你来了：欢迎留言哦 查看留言规则 1、 直接输入QQ号即可自动补全邮箱哦2、 你有好的想法或者建议可以加小编微信哦,(来源备注博客) a2xf6693、 拒绝垃圾评论！"},{"title":"","date":"2020-09-15T13:26:42.478Z","updated":"2020-09-15T13:26:42.478Z","comments":true,"path":"friends/index.html","permalink":"http://www.a2data.cn/friends/index.html","excerpt":"","text":"友情链接 友链更新通知 关于本站添加友链 本站信息 本站开通自助友链,请根据相关要求自己添加即可。 请优先添加本站链接。如下信息。 小编微信：a2xf669十年之约 开源社区 ，请点击 加入 。12345678&#123; &quot;title&quot;: &quot;DataScience&quot;, &quot;description&quot;: &quot;放弃不难，但坚持一定很酷&quot;, &quot;screenshot&quot;: &quot;https://7.dusays.com/2020/09/11/0e4b344a04092.png&quot;, &quot;url&quot;: &quot;www.a2data.cn&quot;, &quot;avatar&quot;: &quot;https://7.dusays.com/2020/09/10/3694a41d52ade.jpg&quot;, &quot;version&quot;: &quot;十年之约&quot;&#125; 如何交换友链？ 互换博客，要求原创不低于20篇。长期维护者优先。请根据根据自己内容选择对应模板填写。添加完成之后，请刷新页面即可。 添加 您的链接 ，请点击 按钮 。按照格式填写并提交。 12345678&#123; &quot;title&quot;: &quot;博客名&quot;, &quot;description&quot;: &quot;描述&quot;, &quot;screenshot&quot;: &quot;背景图&quot;, &quot;url&quot;: &quot;博客链接&quot;, &quot;avatar&quot;: &quot;作者头像&quot;, &quot;version&quot;: &quot;分类&quot;&#125; 为了提高图片加载速度，建议优化头像和截图： 打开 压缩图 上传自己的头像，将图片尺寸调整到 96px 后下载。将压缩后的图片上传到 sm.ms 。 图床 并使用此图片链接作为头像。重复上述步骤，把压缩网站截图并把尺寸调整到 540x360 以下。 请添加本站到您的友链中，如果您也使用 issue 作为友链源，只需要告知您的友链源仓库即可。"},{"title":"","date":"2020-08-03T10:43:31.000Z","updated":"2020-09-14T12:23:47.741Z","comments":true,"path":"movies/index.html","permalink":"http://www.a2data.cn/movies/index.html","excerpt":"","text":"视频推荐 Audio Your browser does not support the video tag."},{"title":"","date":"2020-08-03T12:30:41.000Z","updated":"2020-09-14T12:23:47.738Z","comments":true,"path":"tools/index.html","permalink":"http://www.a2data.cn/tools/index.html","excerpt":"","text":"》 这里为大家推荐常用软件 以及下载链接"},{"title":"所有标签","date":"2020-08-01T03:20:49.302Z","updated":"2020-08-01T03:20:49.302Z","comments":true,"path":"tags/index.html","permalink":"http://www.a2data.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Day14.模块和包","slug":"Python/Python入门/Day14模块和包","date":"2020-09-16T04:16:55.000Z","updated":"2020-09-16T04:18:38.866Z","comments":true,"path":"posts/5144bcf.html","link":"","permalink":"http://www.a2data.cn/posts/5144bcf.html","excerpt":"模块和包","text":"模块和包 模块什么是模块？定义：逻辑上就是一组功能的组合；实质上一个模块就是一个包含了python定义和声明的文件，文件名就是模块名字加上.py后缀。 import加载的模块分为四个通用类别： 使用python编写的代码（.py文件） 已被编译为共享库或DLL的C或C++扩展； 包好一组模块的包； 使用C编写并链接到python解释器的内置模块； 如何使用模块？想要使用模块，必须先要将模块加载进来，可以通过关键字 import 或 from进行加载；需要注意的是模块和当前文件在不同的命名空间中。 模块的构成模块可以包含可执行的语句和函数的定义，这些语句的目的是初始化模块，它们只在模块名第一次遇到导入import语句时才执行（import语句是可以在程序中的任意位置使用的,为了避免同一个模块重复导入，python的优化手段是：第一次导入后就将模块名加载到内存了，后续的import语句仅是对已经加载大内存中的模块对象增加了一次引用，不会重新执行模块内的语句） 模块导入的过程import 语句 想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下： import moduels(模块名字） 导入整个模块，这种导入方式比较占用内存 import moduels (模块名字) as XX这里是导入整个模块的同时给它取一个别名，因为有些模块名字比较长，用一个缩写的别名代替在下次用到它时就比较方便 from modules(模块名字) import func(方法）从一个模块里导入方法，你要用到模块里的什么方法就从那个模块里导入那个方法，这样占用的内存就比较少 也可以用别名表示 ： from modules(模块名字) import func(方法）as XX from package.modules import func(方法）从一个包的模块里导入方法 这个方法跟上面那种基本一样，占用的内存也比较少 也可以用别名表示，from modules(模块名字) import func(方法）as XX from…..import *表示导入模块中所有的不是以下划线(_)开头的名字都导入到当前位置，大部分情况下我们的python程序不应该使用这种导入方式，因为*你不知道你导入什么名字，很有可能会覆盖掉你之前已经定义的名字。而且可读性极其的差，在交互式环境中导入时没有问题。 还有一点要说的是，如果使用* 的方式进行了导入，这时只想使用里面的某个或某些功能时，可以使用__ all__来进行约束； 注意：__ all__只是用来约束* 方式的，其他方式导入的话，不会生效； 1234567891011121314#直接导入import pandas#加别名import pandas as pd# #看一下from.....import 的使用from sys import modulesprint(modules)# #再看一下使用as引用这个模块的某个功能；from matplotlib import pyplot as plt#这样在之后我们要调用这个模块只需要用plt即可，相当于起别名。 包包是一种组织管理代码的方式，包里放着模块 用于将模块包含在一起的一个文件夹 假如一个模块的名称是 A.B，那么他表示一个包 A中的子模块B 。 包的结构 /— 包 #顶层包 /—/— init.py 包的 #初始化顶层包 /—/— 模块1 /—/— 模块2 /—/— 子包 /—/—/— init.py 包的标志文件 /—/—/— 子包的模块1 包的导入操作包的导入分为import和from…import…两种，但是无论哪种方式，在导入时必须都遵循一个原则：凡是在导入时带点的，点的左边必须是一个包，否则非法。在导入后使用时，就没有这些规则了，点的左边可以是包、模块、函数等（他们可以用点的方式调用自己的属性）。 包的本质就是文件夹，导入包就相当于导入包下的__ init__.py文件 下面我们具体看下包的导入有哪些方式 import package_name直接导入一个包，可以直接使用__ init__.py的内容 eg.import time， 用import直接导入python的time模块 import package name as p具体用法跟作用方法，跟上面一致，相当于起别名 注意的是此方法默认是对 __ init__.py的内容进行导入 from … import …导from package import module,module2….. eg. from random import randint 即导入random包中的randint函数 ​ from time import time,localtima 即从time包导入time函数和localtime函数 from package import *导入指定包的所有内容 包和模块区别包是比模块更高层的概念，模块一般是一个文件，包是一个目录，一个包中可以包含很多个模块。 包的all 定义在init.py文件中，模块的all定义在模块文件的开头 以下包用P表示，模块用M表示，方法用F表示 1234567891011#在Python中引入模块可以用import Mfrom M import * from M import F#引入包的方式可以是import Pfrom P import Mfrom P import *from P.M import Ffrom P1.P2.M import F 另外，包的init.py文件不能少。 概念说明这里理清python中模块、库、包之间的概念差异 模块(module)其实就是py文件，里面定义了一些函数、类、变量等。 包(package)是多个模块的聚合体形成的文件夹，里面可以是多个py文件，也可以嵌套文件夹。 库是参考其他编程语言的说法，是指完成一定功能的代码集合，在python中的形式就是模块和包。","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day13.继承和多态","slug":"Python/Python入门/Day13继承和多态","date":"2020-09-16T04:15:29.000Z","updated":"2020-09-16T04:18:38.863Z","comments":true,"path":"posts/8f19a96e.html","link":"","permalink":"http://www.a2data.cn/posts/8f19a96e.html","excerpt":"继承 和多态","text":"继承 和多态 继承什么是继承？ 继承是一种创建新的类的方式，新创建的叫子类，继承的叫父类、超类、基类。 特点：子类可以使用父类的属性（特征、技能） 继承是类与类之间的关系 为什么要继承？ 减少代码冗余、提高重用性 如何使用继承？继承分为单继承和多继承 我们先看单继承 12345678910class A(object): def pp(self): print(&#x27;pp A&#x27;)class B(A): def pp(self): super().pp() print(&quot;pp B&quot;)b = B()b.pp() 12#pp A#pp B super（）常用的方法是在__ init __()方法中确保父类被正确的初始化了： super(cls,inst).__ init__() #cls,init 可以省略 12345678910class A(object): def __init__(self): self.x = 1class B(A): def __init__(self): super(B,self).__init__() self.x = self.x +1 print(self.x)b = B() 1#2 也可以直接调用父类的一个方法 ： A.__ init__(self) 12345678910class A(object): def __init__(self): self.x = 1class B(A): def __init__(self): A.__init__(self) self.x = self.x +1 print(self.x)b = B() 1#2 多继承例子： 1234567891011121314151617181920212223class A(object): def __init__(self): print(&quot;Enter A&quot;)class B(A): def __init__(self): print(&#x27;Enter B&#x27;) super(B,self).__init__() print(&#x27;Leave B&#x27;)class C(A): def __init__(self): print(&#x27;Enter C&#x27;) super(C, self).__init__() print(&#x27;Leave C&#x27;)class D(B,C): def __init__(self): print(&#x27;Enter D&#x27;) super(D,self).__init__() print(&quot;Leave D&quot;)d = D() 123456789&#x27;&#x27;&#x27;Enter DEnter BEnter CEnter ALeave CLeave BLeave D&#x27;&#x27;&#x27; 使用__ bases__方法可以获取子类继承的类 1234567891011class Parent2(): print(&#x27;我是第二个爹&#x27;)class Parent(): print(&#x27;我是第一个爹&#x27;) class SubClass(Parent, Parent2): print(&#x27;我是子类&#x27;)print(SubClass.__bases__)#注意，如果sub = SubClass(),sub是没有__bases__方法的 123456&#x27;&#x27;&#x27;我是第二个爹我是第一个爹我是子类(&lt;class &#x27;__main__.Parent&#x27;&gt;, &lt;class &#x27;__main__.Parent2&#x27;&gt;)&#x27;&#x27;&#x27; super()的用法：super()的本质 先说说python中如何实现继承———对于你定义的每一个类，Python会计算出一个所谓的方法解析顺序(MRO)列表。 这个MRO列表就是一个简单的所有基类的线性顺序表。为了实现继承，Python会在MRO列表上从左到右开始查找基类，直到找到第一个匹配这个属性的类为止。 而这个MRO列表的构造是通过一个C3线性化算法来实现的。 我们不去深究这个算法的数学原理，它实际上就是合并所有父类的MRO列表并遵循如下三条准则： 子类会先于父类被检查 多个父类会根据它们在列表中的顺序被检查 如果对下一个类存在两个合法的选择，选择第一个父类 虽然名义上来说super是用来调用父类中的方法，但是super实际上是在MRO表中找到下一个匹配的类。super原型如下： 123def super(cls, inst): mro = inst.__class__.mro() return mro[mro.index(cls) + 1] 两个参数 cls 和 inst 分别做了两件事： inst 负责生成 MRO 的 list 通过 cls 定位当前 MRO 中的 index, 并返回 mro[index + 1] 关于super的概念大家不用深究，只要掌握其语法会用了就行。 多态 一个操作的意义取决于被操作对象类型，相同的消息给与不同的对象会引发不同的动作。 多态意味着变量并不知道引用的对象是什么，根据引用对象的不同，表现不同的行为方式。 在处理多态对象时，只需要关注他的接口即可。 同一个操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。 注意：多态和多态性是两种不同的概念多态： 传统意义上的多态指一类事物有多种形态，比如动物类，可以有猫，狗，猪等等。（一个抽象类有多个子类，因而多态的概念依赖于继承） 用代码表示如下： 1234567891011121314151617import abcclass Animal(metaclass=abc.ABCMeta): #同一类事物：动物 @abc.abstractmethod def talk(self): passclass Cat(Animal): #动物的形态之一：猫 def talk(self): print(&#x27;say miaomiao&#x27;) class Dog(Animal): #动物的形态之二：狗 def talk(self): print(&#x27;say wangwang&#x27;) class Pig(Animal): def talk(self): print(&#x27;say aoao&#x27;) 多态性: 多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。 12345678910111213141516171819202122232425262728import abcclass Animal(metaclass=abc.ABCMeta): #同一类事物：动物 @abc.abstractmethod def talk(self): passclass Cat(Animal): #动物的形态之一：猫 def talk(self): print(&#x27;say miaomiao&#x27;) class Dog(Animal): #动物的形态之二：狗 def talk(self): print(&#x27;say wangwang&#x27;) class Pig(Animal): def talk(self): print(&#x27;say aoao&#x27;) c=Cat()d=Dog()p=Pig()def func(obj): obj.talk() func(c)func(d)func(p) 123#say miaomiao#say wangwang#say aoao 综上可以说，多态性是 : 一个接口,多种实现 多态性的好处: 增加了程序的灵活性,以不变应万变，不论对象千变万化，使用者都是同一种形式去调用，如func(obj) 增加了程序额可扩展性,通过继承animal类创建了一个新的类，使用者无需更改自己的代码，还是用func(obj)去调用 小作业：今天依旧没有新的小作业哦，第十二天的作业是综合性的哦~","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day12.方法的重写和魔法方法","slug":"Python/Python入门/Day12方法的重写和魔法方法","date":"2020-09-13T16:28:44.000Z","updated":"2020-09-14T15:13:15.583Z","comments":true,"path":"posts/b7cd6609.html","link":"","permalink":"http://www.a2data.cn/posts/b7cd6609.html","excerpt":"方法的重写和魔法方法","text":"方法的重写和魔法方法 例题引导：使用魔法方法__new__构造一个摄氏度转换为华氏度的类： 解题思路：构建类-调用魔法方法-表达函数功能 参考答案： 123class C2F(float): def __new__(cls,arg = 0.0): return float.__new__(cls,arg * 1.8 + 32) 学习引导： 魔法方法： ​ __ init__: ​ __ class__: ​ __ str__: 类的专有方法 方法重写如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下： 123456789101112class Parent: #定义父类 def myMethod(self): print(&#x27;调用父类方法&#x27;) class Child(Parent): #定义子类 def myMethod(self): print(&#x27;调用子类方法&#x27;) c=Child() #子类实例c.myMethod() #子类调用重写方法super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法#super()是用于调用父类（超类）的一个方法。 12#调用子类方法#调用父类方法 魔法方法在python中，有一些内置好的特定的方法，这些方法在进行特定的操作时会自动被调用，称之为魔法方法，下面介绍几种常见的魔法方法。 __ new__(cls[,* argv]) __ new__ 是在一个对象实例化的时候所调用的第一个方法，它的第一个参数是这个类，其他的参数是用来直接传递给 __ init__ 方法 __ new__ 决定是否要使用该 __ init__ 方法，因为 __ new__ 可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 __ new__ 没有返回实例对象，则 __ init__ 不会被调用 __ new__ 主要是用于继承一个不可变的类型比如一个 tuple 或者 string cls：代表一个类的名称 self：代表一个实例对象的名称 1234567class myMethod(str): def __new__(cls,string): string=string.upper() return str.__new__(cls,string) X=myMethod(&#x27;DataScience&#x27;)print(X) 1#DATASCIENCE __ init__：初始化函数，在创建实例对象为其赋值时使用，在__ new__ 之后，__ init __ 必须至少有一个参数self，就是这个 __ new__ 返回的实例，__ init__ 是在 __ new__ 的基础上可以完成一些其它初始化的动作，__ init__不需要返回值。 1234567class Dog: def __init__(self,color,brand): self.color=color self.brand=brandpuppy=Dog(&#x27;黑色&#x27;,&#x27;拉布拉多&#x27;)print(puppy) 1#&lt;__main__.Dog object at 0x0000028EC0609DC8&gt; 下面再来一个结合__ init__ 和__ new__两个魔法方法的例子： 123456789101112131415class A(object): passclass B(A): def __init__(self): print(&#x27;__init__被调用&#x27;) def __new__(cls): print(&#x27;__new__被调用&#x27;) print(id(cls)) return object.__new__(A) #注意此处采用了参数A而不是cls，__new__没有正确返回当前类cls的实例b=B()print(b)print(type(b)) #类型所继承的基类print(id(A))print(id(B)) 12345678&#x27;&#x27;&#x27;__new__被调用2812126085768&lt;__main__.A object at 0x0000028EC0574108&gt;&lt;class &#x27;__main__.A&#x27;&gt;28121260838802812126085768&#x27;&#x27;&#x27; 从运行结果可以看出，__ new__ 中的参数cls和B的id是相同的，表明__ new__ 中默认的参数cls就是B类本身，而在return时，并没有正确返回当前类cls的实例，而是返回了其父类A的实例，因此__ init__ 这一魔法方法并没有被调用，此时__ new__虽然是写在B类中的，但其创建并返回的是一个A类的实例对象。 现在将return中的参数A变为cls，再来看一下运行结果： 123456789101112131415class A(object): passclass B(A): def __init__(self): print(&#x27;__init__被调用&#x27;) def __new__(cls): print(&#x27;__new__被调用&#x27;) print(id(cls)) return object.__new__(cls) #注意此处采用了参数A而不是cls，__new__没有正确返回当前类cls的实例b=B()print(b)print(type(b)) #类型所继承的基类print(id(A))print(id(B)) 123456789&#x27;&#x27;&#x27;__new__被调用2812126087656__init__被调用&lt;__main__.B object at 0x0000028EC057C148&gt;&lt;class &#x27;__main__.B&#x27;&gt;28121260867122812126087656&#x27;&#x27;&#x27; 可以看出，当__ new__ 正确返回其当前类cls的实例对象时，__ init__被调用了，此时创建并返回的是一个B类的实例对象。 __ class__：获得已知对象的类 ( 对象.__ class__)。 基础格式如下： 1234class My: passa=A()print(a.__class__) 1#&lt;class &#x27;__main__.A&#x27;&gt; __ class__在下面这种情况中是有用的：即当一个类中的某个成员变量是所有该类的对象的公共变量时. 下面看一个例子： 123456789101112class My: count=0 def addcount(self): self.__class__.count +=1 a=My()a.addcount()print(a.count)print(&#x27;*&#x27;*50)b=My()b.addcount()print(b.count) 123#1#**************************************************#2 从运行结果可以看出，虽然a和b是两个不同的My类的实例对象，但采用了__ class__ 之后，分别调用两个对象的addcount方法之后，获取到的对象的count属性却是在不断累加的，此时self.__ class__ .count不再是单纯的某个对象私有的属性，而是类的所有实例对象的共有属性,它相当于self.A.count。若将self.__ class__ .count += 1变为self.count += 1,此时__ class__的效果就十分明显了。 123456789101112class My: count=0 def addcount(self): self.count +=1 a=My()a.addcount()print(a.count)print(&#x27;*&#x27;*50)b=My()b.addcount()print(b.count) 123#1#**************************************************#1 __ str__：在将对象转换成字符串 str(对象) 测试的时候，打印对象的信息，__ str__ 方法必须要return一个字符串类型的返回值，作为对实例对象的字符串描述，__ str__ 实际上是被print函数默认调用的，当要print（实例对象）时，默认调用__ str__ 方法，将其字符串描述返回。如果不是要用str()函数转换。当你打印一个类的时候，那么print首先调用的就是类里面的定义的__ str__。 123456789class My(): def __init__(self,name): self.name=name def __str__(self): return(&#x27;我是My类的实例对象my，我的名字叫%s&#x27;%self.name) my=My(&#x27;小王&#x27;)print(My)print(my) 12#&lt;class &#x27;__main__.My&#x27;&gt;#我是My类的实例对象my，我的名字叫小王 类的专有方法 __ init__ : 构造函数，在生成对象时调用 __ del__ : 析构函数，释放对象时使用 __ repr__ : 打印，转换 __ setitem__ : 按照索引赋值 __ getitem__: 按照索引获取值 __ len__: 获得长度 __ cmp__: 比较运算 __ call__: 函数调用 __ add__: 加运算 __ sub__: 减运算 __ mul__: 乘运算 __ truediv__: 除运算 __ mod__: 求余运算 __ pow__: 乘方 做一个总结： 修改类方法和属性，会影响实例方法和属性 一个实例属性的修改，不会影响另一个实例属性 类方法可以修改，但实例方法不允许修改 小作业​ 今天没有小作业，昨天的作业完成情况如何？","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day11.封装","slug":"Python/Python入门/Day11封装","date":"2020-09-13T16:27:05.000Z","updated":"2020-09-13T16:31:31.315Z","comments":true,"path":"posts/80bb221f.html","link":"","permalink":"http://www.a2data.cn/posts/80bb221f.html","excerpt":"Python 的封装学习。","text":"Python 的封装学习。 例题引导：构造一个名为Vector的类，用来储存一个平面坐标系中的向量(例如(1,2))； 在类中构造向量的相加、相减和相乘三种方法，并分别返回计算结果的向量； 再构造一个输出向量的方法，按照(x,y)的格式输出向量； 最后使用main函数输入两个向量，输出他们的加、减、乘计算结果。 解题思路：关于类的创建以及函数的创建及调用 参考答案： 12345678910111213141516171819202122232425262728293031323334class Vector(object): def __init__(self, x, y): self.x = x self.y = y def __add__(self, other): #加 x = self.x + other.x y = self.y + other.y return Vector(x, y) def __sub__(self, other): #减 x = self.x - other.x y = self.y - other.y return Vector(x, y) def __mul__(self, times): #乘 return Vector(self.x * times, self.y * times) def __repr__(self): #格式化输出 return &#x27;Vector(&#123;&#125;, &#123;&#125;)&#x27;.format(self.x, self.y)def main(): v1 = Vector(3, 5) v2 = Vector(4, 5) v3 = v1 + v2 v4 = v3 * 2 v5 = v2 - v1 print(v3) print(v4) print(v5)if __name__ == &#x27;__main__&#x27;: main() 学习引导： 类定义 类对象 类属性与方法 类和对象为了更好的理解本节内容，你首先需要了解什么是面向对象。 python语言是一种面向对象的语言，因此在python中创建一个类和对象是很容易的。 下面简单介绍一下面向对象中的一些基本概念： 类(class):类是抽象的概念，它是一种数据结构，就好比一个模型，该模型是生活中具有相同属性（特征）和方法（动作）的同一类事务，可以用它来生产真实的物体（实例），对象是类的实例。 对象：对象就是具有类属性和方法的具体事物（就是基于类而创建的一个具体的事物），python中一切皆对象。对象包括两个数据成员（类变量和实例变量）和方法。对象的属性一般指主要的特征和参量，而方法主要指函数。 类与对象的关系：对象是有类产生的。一个类为它的全部对象给出了一个统一的定义，而他的每个对象则是符合这种定义的一个实体，因此类和对象的关系就是抽象和具体的关系 实例化：创建一个类的实例，类的具体对象。 实例化对象：由类生产的一个具体对象就叫实例化对象，也就是对象。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或实例变量用于处理类及其实例对象的相关数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程称为方法的覆盖（override重写）。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用self修饰的变量。 继承：即一个派生类(derived class)继承基类(base class)的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。 Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。 对象可以包含任意数量和类型的数据。 面向对象编程的特征： 封装：对外部隐藏对象的工作细节 继承：子类自动共享父类之间数据和方法的机制 多态：可以对不同类的对象调用相同的方法，产生不同的结果 类定义类实例化后，可以使用其属性。创建一个类之后，可以通过类名访问其属性。 语法格式如下： 1234567class ClassName(): #类的命名一般首字母大写，括号中参数可带可不带,带只能带继承的基类名称 &#x27;这里可写类的说明文档&#x27; &lt;statement-1&gt; . . . &lt;statement-N&gt; 类对象类对象支持两种操作：属性引用和实例化。 属性引用：使用和python中所有的属性引用一样的标准语法：obj.name。 类对象创建后，类命名空间中所有的命名都是有效属性名。 123456789101112class MyClass: &quot;演示一个简单的类实例&quot; i=&#x27;DataScience&#x27; def func(self): return &#x27;Hello World&#x27; #实例化类x=MyClass()#访问类的属性和方法print(&#x27;MyClass类的属性i为：&#x27;,x.i)print(&#x27;MyClass类的方法func输出为&#x27;,x.func()) 12#MyClass类的属性i为： DataScience#MyClass类的方法func输出为 Hello World 类有一个名为 __ init__() 的特殊方法（构造方法），该方法在类实例化时会自动调用。 语法格式如下： 12def __init__(self): self.data=[] __ init__ () 方法可以有参数，参数通过 __ init__() 传递到类的实例化操作上。例如: 1234567class Special: def __init__(self,realpart,imagpart): self.r=realpart self.i=imagpartx=Special(&#x27;welcome&#x27;,12)print(x.r,x.i) 1#welcome 12 selfself 代表类的实例，而非类。 类的方法与普通的函数有一个区别—它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。 1234567class Test: def test(self): print(self) print(self.__class__) t=Test()t.test() 12#&lt;__main__.Test object at 0x000002698B8C56C8&gt;#&lt;class &#x27;__main__.Test&#x27;&gt; 从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。 self 不是 python 关键字，我们把他换成 datascience 也是可以正常执行的: 1234567class Test: def test(datascience): print(datascience) print(datascience.__class__)t = Test()t.test() 12#&lt;__main__.Test object at 0x000002698B8CC448&gt;#&lt;class &#x27;__main__.Test&#x27;&gt; 类属性与方法 类中的函数叫方法 类中的变量叫属性 类的私有属性__private_attrs:两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时self. private_attrs。 类的方法在类的内部，使用def关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数self，且为第一个参数，self代表的是类的实例。 注意：self这个名字不是定死的，也可以使用this，但最好还是用常用的self。 类的私有方法__ private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self. __private_methods。 实例私有属性的实例如下“ 1234567891011121314class PrivateEX: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount += 1 self.publicCount += 1 print (self.__secretCount) counter = PrivateEX()counter.count()counter.count()print (counter.publicCount)print (counter.__secretCount) # 报错，实例不能访问私有变量 12345678910111213#1#2#2---------------------------------------------------------------------------AttributeError Traceback (most recent call last)&lt;ipython-input-1-f0d64b9d6654&gt; in &lt;module&gt; 12 counter.count() 13 print (counter.publicCount)---&gt; 14 print (counter.__secretCount) # 报错，实例不能访问私有变量AttributeError: &#x27;PrivateEX&#x27; object has no attribute &#x27;__secretCount&#x27; 类的私有方法实例如下： 1234567891011121314151617181920class Private: def __init__(self, name, url): self.name = name # public self.__url = url # private def who(self): print(&#x27;name : &#x27;, self.name) print(&#x27;url : &#x27;, self.__url) def __foo(self): # 私有方法 print(&#x27;这是私有方法&#x27;) def foo(self): # 公共方法 print(&#x27;这是公共方法&#x27;) self.__foo() x = Private(&#x27;DataScience&#x27;, &#x27;https://www.a2data.cn/#indexCard&#x27;)x.who() # 正常输出x.foo() # 正常输出x.__foo() # 报错 外部不能调用私有方法 12345678910111213141516&#x27;&#x27;&#x27;name : DataScienceurl : https://www.a2data.cn/#indexCard这是公共方法这是私有方法&#x27;&#x27;&#x27;---------------------------------------------------------------------------AttributeError Traceback (most recent call last)&lt;ipython-input-8-0696acdddb15&gt; in &lt;module&gt; 18 x.who() # 正常输出 19 x.foo() # 正常输出---&gt; 20 x.__foo() # 报错 外部不能调用私有方法AttributeError: &#x27;Private&#x27; object has no attribute &#x27;__foo&#x27; 通过类的实例化，可以创建多个实例对象。 下面的例子为多个对象的实例化： 123456789class my_class(): num=100 def print_num(self): print(&#x27;num is %d&#x27;%(self.num)) class_1=my_class() #实例化class_2=my_class() #实例化class_1.print_num()class_2.print_num() 12#num is 100#num is 100 1234class_1.num=10 #修改实例属性my_class.num=50 #修改类属性class_1.print_num()class_2.print_num() 12#num is 10#num is 50 12class_1.num2=5 #新增类属性print(class_1.num2) 1#5 类增加/修改属性从外部添加/修改属性 1234class Example(): passExample.num=100print(Example.num) 1#100 从内部添加/修改属性 1234567class Example(): @classmethod def add_num(cls): cls.num=input(&#x27;请输入：&#x27;) print(cls.num) Example.add_num() 12#请输入：2#2 在这里我们介绍一下上段代码所用到的@classmethod 一般来说，要使用某个类的方法，需要先实例化一个对象再调用方法。 而使用@staticmethod或@classmethod，就可以不需要实例化，直接类名.方法名()来调用。这有利于组织代码，把某些应该属于某个类的函数给放到那个类里去，同时有利于命名空间的整洁,既然@staticmethod和@classmethod都可以直接类名.方法名()来调用，那他们有什么区别呢？ 现从他们使用区别来看： @staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样。 @classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数。 如果在@staticmethod中要调用到这个类的一些属性方法，只能直接类名.属性名或类名.方法名。 而@classmethod因为持有cls参数，可以来调用类的属性，类的方法，实例化对象等，避免硬编码。 类方法不但能调用类属性，还能直接调用类中的其他方法 下面为一个成绩录入的例子 12345678910111213141516171819class List(): @classmethod def enter(cls): cls.name=input(&#x27;请输入学生姓名：&#x27;) cls.grade=int(input(&#x27;请输入考试成绩：&#x27;)) @classmethod def count(cls): if cls.grade&gt;=60: return &#x27;及格&#x27; else: return &#x27;不及格&#x27; @classmethod def result(cls): print(cls.count()) List.enter()List.result() 12345&#x27;&#x27;&#x27;请输入学生姓名：xiaowang请输入考试成绩：32不及格&#x27;&#x27;&#x27; 小作业： 本次的习题可能难度稍大，涉及后面的知识，大家可以慢慢来。 构造四个类，其需要包含的属性和方法如下： people类：公开的属性（名字，年龄），私有属性（体重），构造方法，普通方法（输出名字和年龄）； student类（继承people类）：公开的属性（年级），继承父类的构造方法并加入自身的属性，普通方法（输出名字、年龄和年级）； speaker类：公开的属性（演讲主题，姓名），构造方法，普通方法（输出名字和演讲主题）； introduction类（同时继承speaker和student）：继承父类的构造方法。 尝试调用你的函数中各类和方法。 开发一把枪:1）判断是否有子弹，没有子弹无法射击 2）使用 print 提示射击，并且输出子弹数量 承接上面的枪的类,现改良ak47加强版,冒蓝火的,装弹量增加30","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day10.高阶函数","slug":"Python/Python入门/Day10高阶函数","date":"2020-09-11T09:08:50.000Z","updated":"2020-09-12T10:51:45.921Z","comments":true,"path":"posts/8b540f5a.html","link":"","permalink":"http://www.a2data.cn/posts/8b540f5a.html","excerpt":"高阶函数 定义 内置的有哪些","text":"高阶函数 定义 内置的有哪些 例题引导：用reduce()函数和lambda表达式，求:1+2+…100 本题要点： ​ 函数格式：reduce(func,iter1) ​ 参数介绍： ​ func:函数,有且只有两个参数 ​ iter1:可迭代对象 ​ 功能:将可迭代对象中的元素依次取出,并作用func函数,把作用的结果作为下一次参数继续运算。 参考答案： 12from functools import reduceprint(reduce(lambda x,y: x+y,range(1,101))) 学习引导： 高阶函数定义 内置高阶函数介绍 高阶函数什么是高阶函数？变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。比如: 12345def add(x,y,f): return f(x) + f(y)op = add(1,1,abs) #这里把python内置函数abs作为参数传递给addprint (op) 1#2 内置函数：一般都是因为使用频率比较频繁或是是元操作，所以通过内置函数的形式提供出来，通过对python的内置函数分类分析可以看出来：基本的数据操 作基本都是一些数学运算（当然除了加减乘除）、逻辑操作、集合操作、基本IO操作，然后就是对于语言自身的反射操作，还有就是字符串操作，也是比较常用 的，尤其需要注意的是反射操作。 比如常用的常用的abs、round等 内置高阶函数 filter函数filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。 语法：filter(function, iterable) 参数：function—- 判断函数，iterable – 可迭代对象 返回值：返回列表 实例如下 1234def is_odd(n): return n % 2 == 1alist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])print(list(alist)) 1#[1, 3, 5, 7, 9] map函数接收一个函数 f 和一个或多个序列list，并通过把函数 f 依次作用在 序列list 的每个元素上，得到一个新的 list 并返回。 语法：map(function, iterable, …) 参数：function – 函数，iterable – 一个或多个序列 返回值：Python 2.x 返回列表/Python 3.x 返回迭代器 实例如下 12345list_=[1,2,3,4,5]def square(x) : # 计算平方数 return x ** 2list_2=list(map(square,list_)) # 计算列表各个元素的平方print(list_2) 1#[1, 4, 9, 16, 25] 使用 lambda 匿名函数 12list_3=list(map(lambda x: x ** 2, list_)) # 使用 lambda 匿名函数print(list_3) 1[1, 4, 9, 16, 25] 实例2 123# 提供了两个列表，对相同位置的列表数据进行相加list_4=list(map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]))print(list_4) 1#[3, 7, 11, 15, 19] reduce函数reduce()函数接收的参数和 map()类似，但是行为不同。reduce() 函数会对参数序列中元素进行累积。reduce()传入的函数 f 必须接收两个参数,用传给 reduce 中的函数 f（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 f 函数运算，最后得到一个结果。 语法：reduce(function, iterable[, initializer]) 参数：function – 函数，有两个参数。iterable – 可迭代对象。initializer – 可选，初始参数 实例如下 12345from functools import reduce #自 Python3 之后，这个函数从全局命名空间中移除，放在了 functools模块，因为如果想正确执行，必须这样def add(x,y): #两数想家 return x+yreduce(add, [1,2,3,4,5]) 1#15 1&gt;&gt;&gt; reduce(lambda x, y: x+y, [1,2,3,4,5]) # 使用 lambda 匿名函数 1#15 123def f(a,b): return a+bprint(reduce(f,list_,10)) #这里的第三个参数是做为初始值的 1#25 小作业： 请尝试用filter()删除1~100的素数，输出剩余的整数。 利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。 例如.输入：[‘xandra’, ‘William’, ‘ELIZABETH’]，输出：[‘Xandra’, ‘William’, ‘Elizabeth’]","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day9.函数下","slug":"Python/Python入门/Day9函数下","date":"2020-09-11T09:08:27.000Z","updated":"2020-09-11T09:19:13.464Z","comments":true,"path":"posts/b572816f.html","link":"","permalink":"http://www.a2data.cn/posts/b572816f.html","excerpt":"匿名函数 函数嵌套 函数递归 作用域","text":"匿名函数 函数嵌套 函数递归 作用域 例题引导： 一个由元组构成的列表：a = [(‘b’,3), (‘a’,2), (‘d’,4), (‘c’,1)] 要求：使用lambda表达式和函数sorted()，分别按照元组第一个元素排序(即abcd排序)，按照元组第二个元素排序(即1234排序)，输出相应的列表结果。 要点：了解lambda表达式和排序函数sorted()用法 参考答案： 12345a = [(&#x27;b&#x27;,3), (&#x27;a&#x27;,2), (&#x27;d&#x27;,4), (&#x27;c&#x27;,1)]print(sorted(a, key=lambda x:x[0]))print(sorted(a, key=lambda x:x[1])) 学习引导： 匿名函数 函数的返回值 函数的说明文档 函数的嵌套 变量作用域 函数递归 匿名函数 python可以使用lambda来创建匿名函数 所谓匿名，即不再使用def这样的标准语句来专门定义函数 lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda中封装有限的逻辑进去。 lambda函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间中的参数。 有名函数的定义规则为【def+函数名+参数】；而匿名函数则是用【lambda+参数+表达式】的方式定义函数 lambda的语法只包含一个语句，格式如下： 1lambda [arg1[,arg2,...,argN]]:expression 下面用几个例子对两种函数进行对比，以便大家理解。 用def格式写 1234#用def格式写def func(x,y): return x*yfunc(2,3) #6 用匿名函数写 123#用匿名函数写func=lambda x,y:x*yfunc(3,4) 1#12 从上面例子可以看出匿名函数相较标准函数的优点有： 不用取名称，因为给函数取名是比较头疼的一件事，特别是函数比较多的时候可以直接在使用的地方定义，如果需要修改，直接找到修改即可，方便以后代码的维护工作 语法结构简单 函数的返回值return[表达式]语句用于退出函数，选择性的向调用方返回一个表达式。不带参数值的return语句返回None。 下面演示一下return语句的用法： 123456789def sum(arg1,arg2): &quot;返回两个参数的和&quot; total=arg1+arg2 print(&#x27;函数内：&#x27;,total) return total#调用sum函数total=sum(23,32)print(&#x27;函数外：&#x27;,total) 12#函数内： 55#函数外： 55 函数的说明文档 定义：即对函数进行简单的解释说明（一般对参数和返回值进行说明） 作用：方便他人理解和自己日后的复读 语法结构如下： 1234def 函数名（参数）: &#x27;函数的说明文档内容&#x27; 函数体 return 返回值 对于函数的内置函数，可以使用help()函数查看其内置文档。 函数的嵌套在函数中再定义一个函数 语法结构如下： 1234567def outer(): def inner(): print(&#x27;inner&#x27;) print(&#x27;outer&#x27;) inner()outer()# inner() #该句会报错 12#outer#inner 一个案例 123456789#一个案例def outer(): str=&#x27;Hello World&#x27; def inner(): print(str) return innerinfo=outer()info() 1#Hello World 变量作用域一个标识符的可见范围，就是标识符的作用域。一般常说的是变量的作用域。 函数中的局部作用域：local 嵌套函数中父级函数的局部作用域：enclosing 全局作用域：global 系统内置的变量：如 int、str、list 等关键字 局部变量：在某个函数内部定义，作用在函数内部。生命周期：从变量被创建开始到函数结束死亡。 全局变量：定义在.py模块内部，作用在整个.py模块。生命周期：从变量被创造开始到.py模块结束死亡。 案例演示 123456def Demo1(): num=1 print(num) Demo1()print(num) #该句报错。因为num是局部作用，所以在函数外面是找不到num这个变量的。 1#1 123456789---------------------------------------------------------------------------NameError Traceback (most recent call last)&lt;ipython-input-56-d3aaf0ba8dea&gt; in &lt;module&gt; 5 6 Demo1()----&gt; 7 print(num)NameError: name &#x27;num&#x27; is not defined 对上例的解释 123456789num = 0def Demo1(): num = 1 print(&quot;在demo1中的结果:&quot;,num)def Demo2(): print(&quot;在demo2中的结果:&quot;,num)Demo1()Demo2() 12#在demo1中的结果: 1#在demo2中的结果: 0 从结果可以看出，我们在demo1中num = 1，只在demo1内部起作用，而全局变量num仍然是0；因为在python中，在函数内部改变全局变量的值，会默认的在函数内部创建一个新的变量，全局变量并没有改变。 要想要改变全局变量的值，需要在函数内部用global声明。 现修改上面代码如下： 1234567891011num = 0def Demo1(): global num num = 1 print(&quot;在demo1中的结果:&quot;,num)def Demo2(): print(&quot;在demo2中的结果:&quot;,num)Demo1()Demo2()print(&quot;在函数外面中的结果:&quot;,num) 123#在demo1中的结果: 1#在demo2中的结果: 1#在函数外面中的结果: 1 还有一种情况是当全局变量是可变数据类形，我们可以通过修改可变数据类型的方法，修改可变类型的内容，从而实现修改全局变量。（这里因为可变数据类型改变时，会在内存中改变数据的值） 1234567891011121314num_list = [1,2,3]def Demo1(demo1_list): demo1_list.append(4) print(&quot;在demo1中的结果:&quot;,demo1_list)def Demo2(): print(&quot;在demo2中的结果:&quot;,num_list)Demo1(num_list)Demo2()print(&quot;在函数外面中的结果:&quot;,num_list) 123#在demo1中的结果: [1, 2, 3, 4]#在demo2中的结果: [1, 2, 3, 4]#在函数外面中的结果: [1, 2, 3, 4] 列表 += 与 + 的区别 #+： 12345678910111213num_list = [1,2,3]def Demo1(demo1_list): demo1_list = demo1_list + [4,5,6] print(&quot;在demo1中的结果:&quot;,demo1_list)def Demo2(): print(&quot;在demo2中的结果:&quot;,num_list)Demo1(num_list)Demo2()print(&quot;在函数外面中的结果:&quot;,num_list) 123#在demo1中的结果: [1, 2, 3, 4, 5, 6]#在demo2中的结果: [1, 2, 3]#在函数外面中的结果: [1, 2, 3] #+=： 1234567891011121314num_list = [1,2,3]def Demo1(demo1_list): demo1_list += [4,5,6] print(&quot;在demo1中的结果:&quot;,demo1_list)def Demo2(): print(&quot;在demo2中的结果:&quot;,num_list)Demo1(num_list)Demo2()print(&quot;在函数外面中的结果:&quot;,num_list) 123#在demo1中的结果: [1, 2, 3, 4, 5, 6]#在demo2中的结果: [1, 2, 3, 4, 5, 6]#在函数外面中的结果: [1, 2, 3, 4, 5, 6] 因为： 对于+号操作，可变对象和不可变对象调用的都是__add__操作 对于+=号操作，可变对象调用add__，不可变对象调用的是__iadd(不可变对象没有iadd) __iadd__是原地修改 函数递归 定义：在调用一个函数的过程中直接或间接的调用该函数本身，称之为递归调用。 递归调用最多能调用999层。 1234567891011121314151617#基础模型一def func(): print(&#x27;from func&#x27;) func() #直接调用自身 func() #基础模型二def func(): print(&#x27;from func&#x27;) bar() #间接调用自身def bar(): print(&quot;from bar&quot;) func()func() 虽然以上两中方式为函数递归的基础模型，但往往不能直接这样使用。因为没有一个函数的结束条件，仅仅相当于一个死循环。 递归分为两个重要的阶段: 递推+回溯 递推：函数不断减少问题规模直至最终的终止条件。 回溯：拿到最终明确的值后，返回给上次调用进行处理，直至初始层。 下面为一个练习题：解决年龄问题，求出Jack的年龄 1234567891011121314&quot;&quot;&quot;Jack 他比小王 大两岁。 4 age(3) + 2小王 他比大枫 大两岁。 3 age(2) + 2大枫 他比美丽 大两岁。 2 age(1) + 2美丽：我今年18. 1 18&quot;&quot;&quot;def age(n): if n == 1: return 18 else: return age(n-1) + 2print(age(4)) 1#24 注意在Python： 1、递归调用必须有一个明确的结束条件 2、在python中没有尾递归优化,递归调用的效率不高 3、进入下一次递归时,问题的规模必须降低 再来一个例子输入任意一个数，让其除以2，直到不能再除 1234567def cal(num): if num%2==0:#先判断能不能整除 num=num//2 return cal(num) else: return numprint(cal(8)) 1#1 小作业： 定义并调用两个函数*fib(n)和PrintFN(m,n)*，输出指定的斐波那契数信息(斐波那契数列：1,1,2,3,5,8,…不了解的自行百度)。函数要求： fib(n)*：返回斐波那契数列的第n个值 PrintFN(m,n)*：用列表返回[m, n]中的所有斐波那契数。 例如输入：20 100 6，输出： 12fib(6) = 134 解决汉诺塔问题（汉诺塔规则请自行百度）： 有ABC三根柱子，将A柱上的n个盘子移动到C柱。控制台输入盘子个数n，输出移动的所有步骤，格式样例“A–&gt;C”。 假设你正在爬楼梯。需要 n 阶你才能到达楼顶（给定n为正整数），每次可以爬 1 或 2 个台阶。编写函数，返回有多少种不同的方法可以爬到楼顶。 123456789101112def climbStairs(n): dp = [] dp.append(1) # 初始状态，只有1阶的时候有一种走法 dp.append(2) # 有2阶的时候有两种走法 if n==1: #终止条件 return 1 if n==2: #终止条件 return 2 for i in range(2,n): dp.append(dp[i-1]+dp[i-2]) #递归 return dp[-1] 以下代码是否能执行，原因是？如何修改？ 12345678def fun1(): x = 3 def fun2(): x *= x return x return fun2()print(fun1()) 写出以下代码的执行结果： 12345678910def fun2(): print(2) def fun3(): print(6) print(4) fun3() print(8)print(3)fun2()print(5)","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day8.函数上","slug":"Python/Python入门/Day8函数上","date":"2020-09-11T09:08:12.000Z","updated":"2020-09-11T09:18:46.325Z","comments":true,"path":"posts/3fb6e39.html","link":"","permalink":"http://www.a2data.cn/posts/3fb6e39.html","excerpt":"函数 概念 定义 创建 参数","text":"函数 概念 定义 创建 参数 例题引导： 【模拟轮盘抽奖游戏】 轮盘分为三部分: 一等奖, 二等奖和三等奖;轮盘转的时候是随机的,奖项设置如下：如果范围在[0,0.08)之间,代表一等奖,如果范围在[0.08,0.3)之间,代表2等奖,如果范围在[0, 1.0)之间,代表3等奖, 要求：假设本次活动1000人参加, 模拟游戏时各等级奖品个数需要准备多少个。 解题思路：定义游戏规则（用字典表达）-构建函数-生成随机数-编写游戏逻辑-调用函数-遍历1000名用户-打印输出 参考答案： 12345678910111213141516171819202122232425262728293031import random #导入随机数模块rewardDict = &#123; &#x27;一等奖&#x27;: (0, 0.08), &#x27;二等奖&#x27;: (0.08, 0.3), &#x27;三等奖&#x27;: (0.3, 1)&#125; #因为该值为一对一映射，所以想到用字典定义得奖范围def rewardFun(): #开始构建函数 &quot;&quot;&quot;用户得奖等级&quot;&quot;&quot; # 生成一个0～1之间的随机数 num = random.random() # 判断随机转盘转的数是几等奖 for k, v in rewardDict.items(): # 这里的v是元组 if v[0] &lt;= num &lt; v[1]: return k# print rewardFun()resultDict = &#123;&#125;for i in range(1000): # res:本次转盘的等级(一/二/三等奖) res = rewardFun() #调用函数 if res not in resultDict: resultDict[res] = 1 else: resultDict[res] = resultDict[res] + 1for k, v in resultDict.items(): print k, &#x27;----------&gt;&#x27;, v 学习引导： 函数概念 函数定义 函数调用 参数调用 参数传递 函数函数的概念函数是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集。它是编辑好的、可直接调用的、可重复使用的，用来实现单一或相关联功能的代码段 优点： 提高程序的模块性； 使程序变得可扩展； 减少重复代码； 使程序变得可维护； 函数的定义函数必须先创建才可以使用，该过程称为函数定义，使用函数的过程称为函数调用。 函数可以根据自己的需求来定义，但有一些规则需要注意： 函数代码块必须以def开头，后接函数标识符名称和圆括号()； 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数； 函数的第一行语句可以选择性的使用文档字符-用于存放函数说明； 函数内容以冒号起始，并且缩进； 函数名称的命名应符合标识符的命名规则；（可由字母、下划线和数字组成；不能以数字开头；不能与关键字重名） return[表达式]结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回None 函数定义的一般格式： 123#函数定义的一般格式：def 函数名 (参数列表)： 函数体 12345#实例1def hello(): print(&#x27;Hello World&#x27;) hello() 1#Hello World 实例2-计算圆的面积,带参数 1234567#实例2-计算圆的面积,带参数def area(r): pi=3.412 return pi*(r^2)r=5print(&#x27;圆的面积为:&#x27;,area(r)) 1#圆的面积为: 23.884 函数调用即使用函数的过程 简单的调用应用 123456789#函数功能：打印该字符串def println(str): print(str) return#调用函数println(&#x27;调用上述函数&#x27;)println(&#x27;打印这段字符串&#x27;)println(&#x27;多次调用函数&#x27;) 123#调用上述函数#打印这段字符串#多次调用函数 参数调用参数分为形参、实参 形参：函数定义时括号内的参数 实参：函数调用时括号内的参数 形参相当于变量，实参相当于变量的值 在实际代码中表示如下： 123456789#定义时：def func(a,b,c): pass其中 a,b,c 为形参#调用时：func(1,2,3)其中1，2，3为实参 形参：只在被调用时，才分配存储单元。调用结束，立刻释放所分配的内存。 形参只在函数内部有效 实参：可以是：常量、变量、表达式、函数 进行函数调用时，实参必须是确定的值 位置参数： 位置形参：函数定义时，从左往右写的参数，比如上面的 a, b , c 位置实参：函数调用时，从左往右写的参数, 比如上面的 1，2，3 位置形参定义多少个，调用时位置实参必须写上多少个，多一个少一个都不行。 位置参数必须以正确的顺序传入函数。调用时的数量必须和声明时的一样。 12345def func(a,b,c): return a+b+c#调用print(func(2,3,4)) 1#9 错误演示： 12345def func(a,b,c): return a+b+c#调用print(func(2,3)) #实参数量不对应，报错 123456789---------------------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-21-38b482e25fef&gt; in &lt;module&gt; 3 4 #调用----&gt; 5 print(func(2,3))TypeError: func() missing 1 required positional argument: &#x27;c&#x27; 关键参数： 正常情况下，给函数传参数，要按顺序。如果不想按顺序，就用关键参数。 指定参数名的参数，就叫做关键参数。 函数调用时：func(a=1, b=2), 这种指定了参数名的参数，就是关键参数。 调用函数时，关键参数可以和位置参数一起用，但是关键参数必须在位置参数的后面。不然会报错。 12345def func(a,b,c): return a+b+c#调用print(func(4,c=3,b=2)) 1#9 默认参数： 函数定义时，默认参数必须在位置形参的后面。 函数调用时，指定参数名的参数，叫关键参数。 而在函数定义时，给参数名指定值的时候，这个参数叫做默认参数。 关键参数，和默认参数两个参数写法一样，区别在于： 关键参数是在函数调用时，指定实参的参数名，也可以说指定值的参数名。 默认参数是在函数定义时，指定参数名的值。 写法： 12def (a, b=100): pass 定义时，有默认参数的话，调用时，这个实参可以不写。如果实参不写的话，这个形参的参数值是他的默认值。 实例演示： 123456789def info(name,age=18): print(&#x27;名字:&#x27;,name) print(&#x27;年龄:&#x27;,age) return #调用info(age=22,name=&#x27;Jack&#x27;)print(&#x27;****************&#x27;)info(name=&#x27;Jack&#x27;) 1234567&#x27;&#x27;&#x27;名字: Jack年龄: 22*****************名字: Jack年龄: 18&#x27;&#x27;&#x27; 动态参数： * args ** kwargs当你需要一个函数能处理很多参数，超过已声明的参数数量，这时就需要动态参数。与上述两中参数不同的是，该参数声明不需要命名。 * args一个’* ‘的参数会以元组(tuple)的形式导入，存放未命名的变量参数 12345678#函数定义def printinfo(arg1,*vartuple): print(&#x27;输出：&#x27;) print(arg1) print(vartuple) #调用printinfo(34,45,32,12) #输出： #34 #(45, 32, 12) 如果函数调用时没有指定参数，动态参数则表现为空元组。 12345678#函数定义def printinfo(arg1,*vartuple): print(&#x27;输出：&#x27;) print(arg1) print(vartuple) #调用printinfo(34) #输出： #34 #() ** kwargs还有一种动态参数,加了两个星号则以字典的形式导入 12345678#函数定义def printinfo(arg1,**vardict): print(&#x27;输出：&#x27;) print(arg1) print(vardict) #调用printinfo(34,a=45,b=32,c=12) #输出： #34 #&#123;&#39;a&#39;: 45, &#39;b&#39;: 32, &#39;c&#39;: 12&#125; 声明函数时，参数中的* 可以单独出现。 如果* 单独出现，后面的参数必须以关键字传入 1234def func(a,b,*,c): return a+b-cfunc(3,2,4) #非关键字传入报错 123456789---------------------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-34-f69556d382a4&gt; in &lt;module&gt; 2 return a+b-c 3 ----&gt; 4 func(3,2,4)TypeError: func() takes 2 positional arguments but 3 were given 关键字传入正确 1func(3,4,c=5) 1#2 参数传递 python语言中，类型属于对象，变量是没有类型的,例如: a=[1,2,3] a=’DataScience’ 其中[1,2,3]是list类型，’DataScience’是string类型，变量a没有类型，它只是一个对象的引用（一个指针），可以指向list类型对象也可以指向string类型对象 可更改(mutable)与不可更改(immutable)对象 在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。 python 函数的参数传递： 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响 python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 12345678910#传不可变对象实例##函数定义def changeInt(a): a=10 #函数调用b=5changeInt(b)print(b) 1#5 实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。 1234567891011#传可变对象实例def changelist(List): #对传入的列表进行扩展 List.append([1,2,3,4]) print(&#x27;函数内取值:&#x27;,List) return#函数调用List=[&#x27;datascience&#x27;]changelist(List)print(&#x27;函数外取值:&#x27;,List) 12#函数内取值: [&#x27;datascience&#x27;, [1, 2, 3, 4]]#函数外取值: [&#x27;datascience&#x27;, [1, 2, 3, 4]] 可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。 传入函数的和在末尾添加新内容的对象用的是同一个引用。 小作业 1.构造一个describe_pet函数，调用该函数输入以下2只宠物的信息： I have a cat. My cat’s name is Monkey. I have a lizard. My lizard’s name is Cola. 编写函数, 接收一个列表(包含10个整形)和一个整形k, 返回一个新列表，要求: \\- 将列表下标k之前对应(不包含k)的元素逆序; \\- 将下标k及之后的元素逆序; 请用函数实现一个判断用户输入的年份是否是闰年的程序 构造一个greeting函数，调用函数并使用循环，对输入的参数返回整理后的greeting信息。 例如，在控制台分别输入名字“Mary”和姓“Chen”，调用函数后输出”Hello, Mary Chen!”，并提示输入下一组姓和名。直到控制台输入姓或名为“end”时，程序结束。","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day7.集合","slug":"Python/Python入门/Day7集合","date":"2020-09-11T09:07:40.000Z","updated":"2020-09-11T09:18:46.328Z","comments":true,"path":"posts/1d1dff0b.html","link":"","permalink":"http://www.a2data.cn/posts/1d1dff0b.html","excerpt":"集合: 创建 增加 转化 删除 遍历 运算","text":"集合: 创建 增加 转化 删除 遍历 运算 例题引导： 有两个班英语班和数学班，需要统计这两个班中报名情况，例如统计既报名了英语班又报名数学班的同学名字,即统计为交集。 12english_c =&#123;&quot;ZhangSan&quot;,&quot;LiSi&quot;,&quot;James&quot;,&quot;Alex&quot;&#125;math_c =&#123;&quot;WangWu&quot;,&quot;LiuDeHua&quot;,&quot;James&quot;,&quot;Alex&quot;&#125; 解题思路：统计两个集合中相同的元素 ，应想到利用集合的相关函数来实现，这道题没什么套路，只需要掌握知识点，会用即可。 参考答案： 123456789101112131415161718192021english_c =&#123;&quot;ZhangSan&quot;,&quot;LiSi&quot;,&quot;James&quot;,&quot;Alex&quot;&#125;math_c =&#123;&quot;WangWu&quot;,&quot;LiuDeHua&quot;,&quot;James&quot;,&quot;Alex&quot;&#125;#1、交集--&gt; in a and in b#统计既报了英语班又报了数学班的同学print(english_c &amp; math_c)print(english_c.intersection(math_c))#输出为：&#123;&#x27;Alex&#x27;, &#x27;James&#x27;&#125;#2、并集--&gt; in a or in b#统计报名了两个班的所有同学print(english_c | math_c)print(english_c.union(math_c))#输出为：&#123;&#x27;James&#x27;, &#x27;ZhangSan&#x27;, &#x27;LiuDeHua&#x27;, &#x27;LiSi&#x27;, &#x27;Alex&#x27;, &#x27;WangWu&#x27;&#125;#3、差集--&gt; in a not in b#统计只报名英语班的同学print(english_c - math_c)print(english_c.difference(math_c))#输出为：&#123;&#x27;LiSi&#x27;, &#x27;ZhangSan&#x27;&#125;4、交差补集#统计只报名一个班的同学print(english_c ^ math_c)#输出为：&#123;&#x27;LiuDeHua&#x27;, &#x27;ZhangSan&#x27;, &#x27;WangWu&#x27;, &#x27;LiSi&#x27;&#125; 学习引导： 数据类型-集合 创建 增删 循环 关系运算 数据类型-集合特点： 里面的元素不可变，不能在集合中存放列表或字典，而字符串、元组、数字等不可变类型可以存放 天生去重，在集合中无法存放相同的元素 无序。不能像列表一样通过索引来标记其元素在列表中的位置，例如{1，2，3}和{2，1，3}是同一个集合。 集合的创建123#集合的创建s=&#123;1,2,3,&#x27;32&#x27;,&#x27;data&#x27;,&#x27;文字&#x27;,&#x27;d&#x27;,&#x27;f&#x27;&#125;s 1#&#123;1, 2, 3, &#x27;32&#x27;, &#x27;d&#x27;, &#x27;data&#x27;, &#x27;f&#x27;, &#x27;文字&#x27;&#125; 1type(s) #查看类型 1#set 列表转集合123#列表转集合l=[1,2,3,&#x27;df&#x27;,&#x27;ffd&#x27;]l 1#[1, 2, 3, &#x27;df&#x27;, &#x27;ffd&#x27;] 1set(l) 1#&#123;1, 2, 3, &#x27;df&#x27;, &#x27;ffd&#x27;&#125; 集合的新增 add123#新增s.add(&#x27;科学&#x27;)s 1#&#123;1, 2, 3, &#x27;32&#x27;, &#x27;d&#x27;, &#x27;data&#x27;, &#x27;f&#x27;, &#x27;文字&#x27;, &#x27;科学&#x27;&#125; 集合的删除 discard/remove/pop法一 123#删除s.discard(&#x27;32&#x27;)s 1#&#123;1, 2, 3, &#x27;d&#x27;, &#x27;data&#x27;, &#x27;f&#x27;, &#x27;文字&#x27;, &#x27;科学&#x27;&#125; 法二 12s.remove(2)s 1#&#123;1, 3, &#x27;d&#x27;, &#x27;data&#x27;, &#x27;f&#x27;, &#x27;文字&#x27;, &#x27;科学&#x27;&#125; 法三 1s.pop() 1#1 1s 1#&#123;3, &#x27;d&#x27;, &#x27;data&#x27;, &#x27;f&#x27;, &#x27;文字&#x27;, &#x27;科学&#x27;&#125; 集合的循环123#循环for i in s: print(i) 12345678&#x27;&#x27;&#x27;3科学文字datadf&#x27;&#x27;&#x27; 集合的关系运算123#集合的关系运算s=&#123;1,2,3,&#x27;32&#x27;,&#x27;data&#x27;,&#x27;文字&#x27;,&#x27;d&#x27;,&#x27;f&#x27;&#125;s2=&#123;&#x27;science&#x27;,&#x27;学长&#x27;,&#x27;学员&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,3,2,6,7&#125; 交集 1s&amp;s2 1#&#123;2, 3, &#x27;f&#x27;&#125; 并集 12#并集s | s2 1#&#123;1, 2, 3, &#x27;32&#x27;, 6, 7, &#x27;d&#x27;, &#x27;data&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;science&#x27;, &#x27;学员&#x27;, &#x27;学长&#x27;, &#x27;文字&#x27;&#125; 差集 12#差集s-s2 1#&#123;1, &#x27;32&#x27;, &#x27;d&#x27;, &#x27;data&#x27;, &#x27;文字&#x27;&#125; 对称差集 12#对称差集s ^ s2 1#&#123;1, &#x27;32&#x27;, 6, 7, &#x27;d&#x27;, &#x27;data&#x27;, &#x27;e&#x27;, &#x27;science&#x27;, &#x27;学员&#x27;, &#x27;学长&#x27;, &#x27;文字&#x27;&#125; 判断两个集合是否包含相同的元素，不包含返回true，包含返回false 1s.isdisjoint(s2) 1#False 1s.isdisjoint(&#123;123&#125;) 1#True 子集 12#是否为子集的判断s.issubset(s2) 1#False 1&#123;1,2,3&#125;.issubset(&#123;1,2,3,4,5&#125;) 1#True 小作业 以下代码输出结果是： 12s = &#123;1,2,3&#125;print(s[1]) A. 1 B. 2 C. 无法输出 集合的特性有哪些?","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day6.字典","slug":"Python/Python入门/Day6字典","date":"2020-09-11T09:07:06.000Z","updated":"2020-09-11T09:18:46.331Z","comments":true,"path":"posts/71dd948a.html","link":"","permalink":"http://www.a2data.cn/posts/71dd948a.html","excerpt":"字典 创建 增加 删除 修改 查询 遍历","text":"字典 创建 增加 删除 修改 查询 遍历 例题引导： 【数字重复统计,以字典形式输出】 随机生成1000个数,统计20-100以内的数字,并统计出现次数 参考答案： 解题思路：先制造1000个随机数—整理随机数以便统计(排序)—构造字典—遍历随机数，通过key值确定value值—打印输出 12345678910111213141516171819import random #导入随机数模块all_nums = [] #定义空列表存储数字for item in range(1000): #列表长度为1000 all_nums.append(random.randint(20,100)) #选择20-100内的随机数# print(all_nums) #可以先打印看一下生成的随机数# print(&#x27;**********&#x27;)sorted_nums = sorted(all_nums) #排序num_dict = &#123;&#125; #定义空字典for num in sorted_nums: #循环遍历，通过key值找value if num in num_dict: num_dict[num] += 1 else: num_dict[num] = 1print(num_dict) 学习引导： 数据类型-字典 创建 增删改查 循环 数据类型-字典关键点： 健与值用冒号：分开 项与项用逗号，分开 特性： key-value结构； key必须是不可变类型，唯一性； 可存放多个value，可修改，不唯一； 无序； 查询速度快，不受dict大小影响； 字典的创建12345#直接给出key和valueinfo=&#123;&#x27;name&#x27;:&#x27;小王&#x27;, &#x27;num&#x27;:&#x27;20192812&#x27;, &#x27;gender&#x27;:&#x27;女&#x27;&#125;info 1#&#123;&#x27;name&#x27;: &#x27;小王&#x27;, &#x27;num&#x27;: &#x27;20192812&#x27;, &#x27;gender&#x27;: &#x27;女&#x27;&#125; 法二 123#key和value分别赋值keys=[1,2,3,4,5]&#123;&#125;.fromkeys(keys) 1#&#123;1: None, 2: None, 3: None, 4: None, 5: None&#125; 1&#123;&#125;.fromkeys(keys,100) 1#&#123;1: 100, 2: 100, 3: 100, 4: 100, 5: 100&#125; 字典的增加123#字典的增加info[&#x27;age&#x27;]=&#x27;20&#x27;info 1#&#123;&#x27;name&#x27;: &#x27;小王&#x27;, &#x27;num&#x27;: &#x27;20192812&#x27;, &#x27;gender&#x27;: &#x27;女&#x27;, &#x27;age&#x27;: &#x27;20&#x27;&#125; 字典的删除 pop/del/clear法一 123#字典的删除info.pop(&#x27;gender&#x27;)info 1#&#123;&#x27;name&#x27;: &#x27;小王&#x27;, &#x27;num&#x27;: &#x27;20192812&#x27;, &#x27;age&#x27;: &#x27;20&#x27;&#125; 法二 12del info[&#x27;name&#x27;]info 1#&#123;&#x27;num&#x27;: &#x27;20192812&#x27;, &#x27;age&#x27;: &#x27;20&#x27;&#125; 法三 12info.clear()info 1#&#123;&#125; 字典的修改 update123456789#字典的修改dic=&#123;&#x27;name&#x27;:&#x27;小王&#x27;, &#x27;num&#x27;:&#x27;20192898&#x27;, &#x27;gender&#x27;:&#x27;男&#x27;&#125;dic2=&#123;&#x27;name&#x27;:&#x27;小王&#x27;, &#x27;num&#x27;:&#x27;20192812&#x27;, &#x27;gender&#x27;:&#x27;女&#x27;, &#x27;age&#x27;:&#x27;20&#x27;&#125;dic2 1#&#123;&#x27;name&#x27;: &#x27;小王&#x27;, &#x27;num&#x27;: &#x27;20192812&#x27;, &#x27;gender&#x27;: &#x27;女&#x27;, &#x27;age&#x27;: &#x27;20&#x27;&#125; 12dic.update(dic2) #合并后重合的key被覆盖dic 1#&#123;&#x27;name&#x27;: &#x27;小王&#x27;, &#x27;num&#x27;: &#x27;20192812&#x27;, &#x27;gender&#x27;: &#x27;女&#x27;, &#x27;age&#x27;: &#x27;20&#x27;&#125; 查操作12#查操作&#x27;age&#x27;in dic #判断该元素是否在字典中 1#True 1&#x27;age2&#x27;in dic 1#False 1dic.get(&#x27;name&#x27;) #读取name的值 1#&#x27;小王&#x27; 1dic.keys() #获取所有key值 1#dict_keys([&#x27;name&#x27;, &#x27;num&#x27;, &#x27;gender&#x27;, &#x27;age&#x27;]) 1dic.values() #获取所有value值 1#dict_values([&#x27;小王&#x27;, &#x27;20192812&#x27;, &#x27;女&#x27;, &#x27;20&#x27;]) 1dic.items() #以列表返回可遍历的(键, 值) 元组数组 1#dict_items([(&#x27;name&#x27;, &#x27;小王&#x27;), (&#x27;num&#x27;, &#x27;20192812&#x27;), (&#x27;gender&#x27;, &#x27;女&#x27;), (&#x27;age&#x27;, &#x27;20&#x27;)]) 字典的循环 三种第一种 12for i in dic: print(i) #遍历Key值 123456&#x27;&#x27;&#x27;namenumgenderage&#x27;&#x27;&#x27; 第二种 12for i in dic.items(): #遍历字典 print(i) 123456&#x27;&#x27;&#x27;(&#x27;name&#x27;, &#x27;小王&#x27;)(&#x27;num&#x27;, &#x27;20192812&#x27;)(&#x27;gender&#x27;, &#x27;女&#x27;)(&#x27;age&#x27;, &#x27;20&#x27;)&#x27;&#x27;&#x27; 第三种 12for i,j in dic.items(): #遍历字典 print(i,j) 123456&#x27;&#x27;&#x27;name 小王num 20192812gender 女age 20&#x27;&#x27;&#x27; 小作业 交换字典的key和value 构造一个字典，存储以下两位客人所点pizza order： first: ​ guest_surname: Grand ​ crust: thin ​ toppings: mushrooms cheese onion second: ​ guest_surname: Suzu ​ crust: thick ​ toppings: mushrooms onion peppers 按上述显示格式输出该字典（注意输出格式的缩进和换行）","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day5.布尔元组字符串","slug":"Python/Python入门/Day5布尔元组字符串","date":"2020-09-11T08:48:34.000Z","updated":"2020-09-11T09:18:46.333Z","comments":true,"path":"posts/f9586000.html","link":"","permalink":"http://www.a2data.cn/posts/f9586000.html","excerpt":"数据类型-元组-字符串-布尔","text":"数据类型-元组-字符串-布尔 例题引导: 把True变为False，把False变为True后输出： 参考答案： 12print not Trueprint not False 学习引导： 数据类型-布尔 数据类型-元组 数据类型-字符串 bool布尔类型布尔类型取值只有两种情况，表示真假值，即 yes or no python 中布尔值使用常量True 和 False来表示；注意大小写 比较运算符&lt; &gt; == 等返回的类型就是bool类型； 布尔类型通常在 if （判断）和 while （循环）语句中应用 下面是一个简单的案例演示 1234print(True==1)print(False==0)print(2&gt;1)print(0&gt;3) 123456&#x27;&#x27;&#x27;TrueTrueTrueFalse&#x27;&#x27;&#x27; 小测试：请列举布尔值是false的值： 数据类型-元组和列表很相似，区别在于 不可修改 用小括号框 其余用法基本一致 下面我们直接演示一些元组的方法 123#索引、长度、切片、循环a=[2,3,4,5,&#x27;32&#x27;,&#x27;你好&#x27;]a 1#[2, 3, 4, 5, &#x27;32&#x27;, &#x27;你好&#x27;] 1a[4] #元组中第5个元素 1#&#x27;32&#x27; 1len(a) #元组a的长度 1#6 1a[0:3] #取该元组中第一个到第三个的值 1#[2, 3, 4] 遍历元组12for i in a: print(i) 123456234532你好 查询判断1&#x27;32&#x27; in a #判断字符串32是否在元组a中 1#True 132 in a #判断整数32是否在元组a中 1#False 如果不可变的元组中包含可变的元素（例如列表），则元组可变 12tuple_=(3,4,2,&#x27;元组&#x27;,[3,4,&#x27;d&#x27;,&#x27;2&#x27;],&#x27;32&#x27;)tuple_ 1#(3, 4, 2, &#x27;元组&#x27;, [3, 4, &#x27;d&#x27;, &#x27;2&#x27;], &#x27;32&#x27;) 123#更改数据会报错tuple_[3]=1tuple_ 12345678---------------------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-9-13fb7bda7784&gt; in &lt;module&gt;----&gt; 1 tuple_[3]=1 2 tuple_TypeError: &#x27;tuple&#x27; object does not support item assignment 123#更改元组中的列表部分tuple_[4][0]=&#x27;数据&#x27;tuple_ 1#(3, 4, 2, &#x27;元组&#x27;, [&#x27;数据&#x27;, 4, &#x27;d&#x27;, &#x27;2&#x27;], &#x27;32&#x27;) string字符串 和列表操作类似 切片 索引 特点是不可变性 python中单引号和双引号使用完全相同。使用三引号(‘’’或”””)可以指定一个多行字符串。 123456789print(&#x27;data science&#x27;)print(&quot;data science&quot;)print(&#x27;&#x27;&#x27;this is data scienceLearning together&#x27;&#x27;&#x27;)print(&quot;&quot;&quot;this is data scienceLearning together&quot;&quot;&quot;) 12345678&#x27;&#x27;&#x27;data sciencedata sciencethis is data scienceLearning togetherthis is data scienceLearning together&#x27;&#x27;&#x27; 转义符 ‘’:反斜杠可以用来转义，使用r可以让反斜杠不发生转义。 如 r”data science \\n” 则\\n会显示，并不是换行。 按字面意义级联字符串，如”this “ “is “ “data science”会被自动转换为this is data science。 转义字符演示 12345print(&#x27;data\\nscience&#x27;) #表示换行print(r&#x27;data\\nscience&#x27;) #加r则无特殊意义，正常输出print(&#x27;this&#x27;,&#x27;is&#x27;,&#x27;DataScience&#x27;) #逐个输出字符串 123456&#x27;&#x27;&#x27;datasciencedata\\nsciencethis is DataScience&#x27;&#x27;&#x27; 字符串可以用 ‘+’运算符连接在一起，用 ‘*’ 运算符重复。 123str=&#x27;DataScience&#x27;print(str+&#x27;你好&#x27;) #连接两个字符串print(str*5) #打印该字符串5次 12#DataScience你好#DataScienceDataScienceDataScienceDataScienceDataScience Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。 索引演示： 123str=&#x27;DataScience&#x27;print(str[1]) #打印该字符串中第一个元素print(str[2:-1]) #打印该字符串中第三个元素到倒数第二个元素 12#a#taScienc Python中的字符串不能改变。 123str=&#x27;DataScience&#x27;str[0]=&#x27;s&#x27;print(str[0]) 12345678---------------------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-31-f432ac1ed2d2&gt; in &lt;module&gt; 1 str=&#x27;DataScience&#x27;----&gt; 2 str[0]=&#x27;s&#x27; 3 print(str[0]) 1TypeError: &#x27;str&#x27; object does not support item assignment Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。字符串的截取的语法格式如下：变量[头下标:尾下标:步长] 12str=&#x27;welcome to the DataScience&#x27;print(str[0:13:2]) 1#wloet h 关于字符串的内容，后面有一节会详细讲解。 今天没有很多小练习，建议复习一下之前的学习内容。","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"1.Git使用","slug":"Git/Git使用","date":"2020-09-11T08:37:06.000Z","updated":"2020-09-11T09:15:05.024Z","comments":true,"path":"posts/ff995e29.html","link":"","permalink":"http://www.a2data.cn/posts/ff995e29.html","excerpt":"Git 快速学习。","text":"Git 快速学习。 0、查看本机公钥 步骤： 1、进入.ssh目录 cd ~/.ssh 2、找到id_rsa.pub文件 ls / ll 3、查看文件 cat id_rsa.pub 123456789JackFeng@JackFeng MINGW64 ~/Desktop$ cd ~/.sshJackFeng@JackFeng MINGW64 ~/.ssh$ lsconfig id_rsa id_rsa.pub id_rsa_sql id_rsa_sql.pub known_hostsJackFeng@JackFeng MINGW64 ~/.ssh$ cat id_rsa.pub 1、配置多个git仓库123456789101112多仓库之间 &#x27;ssh-key切换&#x27;#1、生成客户端自己的密钥对ssh-keygen ---- 一顿回车即可# 实际操作 换成你的邮箱即可ssh-keygen -t rsa -C &quot;youremail@example.com&quot;可以在客户端的家目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥。 生成新的ssh-key 12#second@mail.com 工作邮箱地址ssh-keygen -t rsa -C &#x27;second@mail.com&#x27; -f id_rsa_second 配置多个仓库 在.ssh目录创建config文本文件并完成相关配置(最核心的地方)每个账号单独配置一个Host，每个Host要取一个别名，每个Host主要配置HostName和IdentityFile两个属性即可 Host的名字可以取为自己喜欢的名字，不过这个会影响git相关命令，例如： HostName 这个是真实的域名地址IdentityFile 这里是id_rsa的地址PreferredAuthentications 配置登录时用什么权限认证–可设为publickey,password publickey,keyboard-interactive等User 配置使用用户名 config 1234567891011121314# 配置github.comHost github.com HostName github.com IdentityFile ~\\.ssh\\id_rsa PreferredAuthentications publickey User yinjie.feng# 配置SQLSQHost SQL HostName github.com IdentityFile ~\\.ssh\\id_rsa_sql PreferredAuthentications publickey User yinjie.feng 测试是否调通 123456789101112131415JackFeng@JackFeng MINGW64 ~/.ssh$ vim configJackFeng@JackFeng MINGW64 ~/.ssh$ ssh -T git@github.comHi A2Data! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.JackFeng@JackFeng MINGW64 ~/.ssh$ vim configJackFeng@JackFeng MINGW64 ~/.ssh$ ssh -T git@SQLHi MineData-SQL! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. git add、git commit、git remote add、git push需要说明的一点，在git commit 时需要一次身份验证，正确输入你的用户名和邮箱就可以了。 另外注意：github根据配置文件的user.email来获取github帐号显示author信息，所以对于多帐号用户一定要记得将user.email改为相应的email(monster@mail.com)。 总结一下:其实建立第二个密钥对的区别就在于对第二密钥对的声明，因此需要在.ssh目录下添加config文件，添加语句dentityFile ~/.ssh/id_rsa_sql声明这是第二个密钥对。这条连接命令就体现出来了。 查看用户名12git config user.namegit config user.email 修改用户名123git config --global user.name &quot;xxx&quot;git config --global user.email &quot;xxx&quot; 2、从远程项目拉取1git clone 项目地址 3、提交代码到远程仓库12345678910111213141516171819常规操作##添加git add . .#查看状态git status# 提交git commit -m &quot;代码描述&quot;# 再次查看状态git status# 拉取最新代码git pull# 提交git push 4、git分支操作Git初始化 解决 fatal: Not a git repository (or any of the parent directories): .git 问题 1git init 12345678910git clone --- 克隆项目JackFeng@JackFeng MINGW64 /d/Practice$ git clone git@github.com:MineData-SQL/SQL.gitCloning into &#x27;SQL&#x27;...remote: Enumerating objects: 3, done.remote: Counting objects: 100% (3/3), done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Receiving objects: 100% (3/3), done. 创建分支12git branch &lt;branch_name&gt; #指定分支名称git checkout -b [&quot;分支名&quot;] 查看分支123git branch # 查看所有分支,* 号所属代表当前分支git branch # 查看分支详情，包括分支指向得commitid及提交信息 切换分支123git checkout &lt;branch_name&gt; #切换到指定分支git checkout -b &lt;branch_name&gt; #创建并切换到指定分支 删除分支12345git branch -d &lt;branch_name&gt;.#删除一个干净的分支(即相对当前分支而言该分支没有新的提交记录)git branch -D &lt;branch_name&gt;.#强制删除一个分支，该分支有没有合并到当前分支的提交记录注意：删除分支前都需要先切换到其他分支才能进行删除操作 分支恢复 思路：对于已经有提交记录的分支删除后，实际上只是删除指针，commit记录还保留，如果想恢复，需要使用git reflog查找该分支指向的 commitId，然后根据commitId创建新的分支 HEAD@&#123;1&#125; 1234git refloggit branch &lt;branch_name&gt; &lt;hash_val&gt; #根据指定commit创建新分支 分支改名1git branch -m &lt;branch_name&gt; newname 123456789JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two)$ git branch -m master-one master-OJackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two)$ git branch master master-O* master-two 分支合并 git merge #将指定分支合并到当前分支如果两个分支没有产生分叉情况，那么会进行快速合并，即fast-forward方式，它并不会产生新的commitId，只是改变了指针的指向，产生分叉合并可能会有冲突情况。 示例： 合并master-O分支到master分支，此时合并为fast-forward方式 分支合并细节 git merge -ff -m &quot;msg&quot; #合并分支时禁用Fast forward模式 如果使用fast-forward方式进行分支合并，只是简单改变了分支指针，而不会产生新的commit记录。 为了保证合并数据的完整性，我们也可以在合并时指定不使用fast-forward方式，使用 --ff 选项。这样，在merge时就会生成一个新的commit，从日志上就可以看到分支合并记录了。 示例：我们在master-two分支上新增一次提交，然后合并到master分支上，git log查看最新一次的提交记录，显示的正是我们合并分支时的记录 git log --pretty=oneline -1 123456789101112131415161718192021222324252627282930313233343536JackFeng@JackFeng MINGW64 /d/Practice/SQL (master)$ git checkout master-twoSwitched to branch &#x27;master-two&#x27;JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two)$ echo &quot; thank you for attention DataScience &quot; &gt;&gt; a2data.txtJackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two)$ git add a2data.txtwarning: LF will be replaced by CRLF in a2data.txt.The file will have its original line endings in your working directoryJackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two)$ git commit -m &quot; add file&quot;[master-two 59a8816] add file 1 file changed, 1 insertion(+) create mode 100644 a2data.txtJackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two)$ git checkout masterSwitched to branch &#x27;master&#x27;Your branch is up to date with &#x27;origin/master&#x27;.JackFeng@JackFeng MINGW64 /d/Practice/SQL (master)$ git merge --ff -m &quot;meger master-two branch&quot; master-twoUpdating ab83ffb..59a8816Fast-forward (no commit created; -m option ignored) a2data.txt | 1 + 1 file changed, 1 insertion(+) create mode 100644 a2data.txtJackFeng@JackFeng MINGW64 /d/Practice/SQL (master)$ git log --pretty=oneline -159a88161e630f0853b852946fddb6c7e787906fe (HEAD -&gt; master, master-two) add file 冲突解决 当对分叉分支进行合并时，如果两个分支都对同一文件进行了修改，那么合并时就有可能会产生冲突情况。 如果两个分支对同一文件的修改是有规律的，比如对不同地方的修改，那么git工具可以实现自动合并. 如果无法自动合并，则需要对冲突文件进行手动修改，修改完成后使用git add表示冲突已经解决，然后使用git commit进行提交 示例：在master分支上对两个文件进行修改提交. a2data.txt和*DataScience。 然后切换到master-O分支上对两个文件进行修改提交. 文件由于修改的是不同地方，所以自动合并。 我们查看DataScience文件的内容，==上面和下面的内容分别代表了不同分支的修改内容，将冲突标记去掉，然后内容根据需求进行恰当的修改，然后进行一次提交即完成了冲突的解决。 修改文件相同则会产生合并冲突 (merge conflict) master master-O 合并分支 分支同步 主要是 自己的分支与主分支保持同步。 步骤： 1、git remote add master &#103;&#x69;&#x74;&#x40;&#x67;&#105;&#x74;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;:A2Data/A2Data.github.io.git // 主分支master 2、 git branch -v 查看是否添加 3、git fetch master // 获取主分支的最新修改到本地 4、git merge master/master-O // 将master分支修改内容merge到本地个人分支； // 该步骤或者可以分成2步： 1） # git checkout master-O； // checkout到master-O分支 2） # git merge master； //合并主分支修改到本地master分支； 5、git push //本地分支提交到github上的个人分支 分支暂存 git stash #将工作暂存git stash list #列出所有的暂存状态 从暂存区之中进行恢复，有两种处理方式：1.先恢复，而后再删除暂存git stash applygit stash drop2.恢复的同时也将stash内容删除git stash pop 当我们在分支上进行代码开发时，有可能会接到突发需求，而当前的代码尚未完成，所以还**不能直接提交。** 为了解决这样的问题，git就提供了分支暂存的机制，可以将开发一半的分支进行保存，在适当的时候进行代码恢复。 示例：在master-two分支上新建文件，然后添加到暂存区表示尚未完成的任务，对当前分支进行暂存，git status显示工作空间是干净的。 5、git命令问题 GitBash 中按下 Ctrl+C 无法中断 webpack-dev-server 解决办法： 打开 cmd 复制 taskkill /F /IM node.exe 然后粘贴运行 搞定 这是 GitBash 的一个 BUG，不知何时修复。 欢迎关注","categories":[{"name":"Git","slug":"Git","permalink":"http://www.a2data.cn/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.a2data.cn/tags/Git/"}]},{"title":"Python数据类型-列表","slug":"Python/Python入门/Day4数据类型-列表","date":"2020-09-03T12:51:46.000Z","updated":"2020-09-11T08:26:08.609Z","comments":true,"path":"posts/8c0ed688.html","link":"","permalink":"http://www.a2data.cn/posts/8c0ed688.html","excerpt":"Python数据类型-列表！！！","text":"Python数据类型-列表！！！ 例题引导： 三个小盆友 Candy,Mandy,Sandy 分别拿着玩具 Teddy bear,Barbie,Lego。 建立列表存储上述变量，并依次输出每位小盆友拿着什么玩具(xxx is holding xxx.)。 参考答案： 1234kids = [&#x27;candy&#x27;,&#x27;mandy&#x27;,&#x27;sandy&#x27;]toys = [&#x27;Teddy bear&#x27;,&#x27;Barbie&#x27;,&#x27;Lego&#x27;] #先建立两个列表for i in range(0,3): #遍历输出 print(kids[i].title()+&#x27; is holding &#x27;+toys[i]+&#x27;.&#x27;) 学习引导： 数据类型-列表 增加 插入 嵌套 删除 修改 …… 数据类型-列表List（列表） 是 Python 中使用最频繁的数据类型。 列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。 列表是写在方括号 [] 之间、用逗号分隔开的元素列表。 和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。 列表截取的语法格式如下：变量[头下标：尾下标] 列表中的元素是可以改变的，很多操作和字符串类似 下面演示部分列表常用的操作 123456789a=[&#x27;123&#x27;,&#x27;datascience&#x27;,&#x27;4345&#x27;,&#x27;f&#x27;,&#x27;3&#x27;]b=[&#x27;ppp&#x27;]print(a[2]) #输出第三个元素a[0]=321 #讲列表a中的第一个元素替换print(a[0]) #打印a中第一个元素print(a[0:3]) #打印a中第一个到第三个元素。注意：python语言取左不取右print(a[2:-1]) #打印a中第三个到倒数第二个元素print(a+b) #将列表a，b相加print(b*3) #将列表b乘以三 12345678&#x27;&#x27;&#x27;4345321[321, &#x27;datascience&#x27;, &#x27;4345&#x27;][&#x27;4345&#x27;, &#x27;f&#x27;][321, &#x27;datascience&#x27;, &#x27;4345&#x27;, &#x27;f&#x27;, &#x27;3&#x27;, &#x27;ppp&#x27;][&#x27;ppp&#x27;, &#x27;ppp&#x27;, &#x27;ppp&#x27;]&#x27;&#x27;&#x27; 列表的特点： 可存放多个值 有序。按照从左到右的顺序定义列表元素，下标从0开始按顺序访问 可修改指定索引位置的值，是可变的。 增加 append12names=[&#x27;data&#x27;,&#x27;science&#x27;]names 1#[&#x27;data&#x27;, &#x27;science&#x27;] 12names.append(&#x27;excellent&#x27;)names 1#[&#x27;data&#x27;, &#x27;science&#x27;, &#x27;excellent&#x27;] 插入 insert/extend12names.insert(2,&quot;数据科学&quot;)names 1#[&#x27;data&#x27;, &#x27;science&#x27;, &#x27;数据科学&#x27;, &#x27;excellent&#x27;] 123name=[&#x27;数据科学&#x27;,&#x27;学姐&#x27;,&#x27;学长&#x27;]names.extend(name)names 1#[&#x27;data&#x27;, &#x27;science&#x27;, &#x27;数据科学&#x27;, &#x27;excellent&#x27;, &#x27;数据科学&#x27;, &#x27;学姐&#x27;, &#x27;学长&#x27;] 嵌套 insert1names 1#[&#x27;data&#x27;, &#x27;science&#x27;, &#x27;数据科学&#x27;, &#x27;excellent&#x27;, &#x27;数据科学&#x27;, &#x27;学姐&#x27;, &#x27;学长&#x27;] 12names.insert(2,[0,0,4])names 1#[&#x27;data&#x27;, &#x27;science&#x27;, [0, 0, 4], &#x27;数据科学&#x27;, &#x27;excellent&#x27;, &#x27;数据科学&#x27;, &#x27;学姐&#x27;, &#x27;学长&#x27;] 直接删除 del1names 1#[&#x27;data&#x27;, &#x27;science&#x27;, [0, 0, 4], &#x27;数据科学&#x27;, &#x27;excellent&#x27;, &#x27;数据科学&#x27;, &#x27;学姐&#x27;, &#x27;学长&#x27;] 12del names[2]names 1#[&#x27;data&#x27;, &#x27;science&#x27;, &#x27;数据科学&#x27;, &#x27;excellent&#x27;, &#x27;数据科学&#x27;, &#x27;学姐&#x27;, &#x27;学长&#x27;] pop 删除1names 1#[&#x27;data&#x27;, &#x27;science&#x27;, &#x27;数据科学&#x27;, &#x27;excellent&#x27;, &#x27;数据科学&#x27;, &#x27;学姐&#x27;, &#x27;学长&#x27;] 123names.pop() #默认删除最后一个元素并返回被删除的值names.pop(1)names 1#[&#x27;data&#x27;, &#x27;数据科学&#x27;, &#x27;excellent&#x27;, &#x27;数据科学&#x27;, &#x27;学姐&#x27;] clear 清空1name 1#[&#x27;数据科学&#x27;, &#x27;学姐&#x27;, &#x27;学长&#x27;] 12name.clear()name 1#[] 修改1names 1#[&#x27;data&#x27;, &#x27;数据科学&#x27;, &#x27;excellent&#x27;, &#x27;数据科学&#x27;, &#x27;学姐&#x27;] 123names[0]=&#x27;data2&#x27;names[-1]=&#x27;Shon&#x27;names 1#[&#x27;data2&#x27;, &#x27;数据科学&#x27;, &#x27;excellent&#x27;, &#x27;数据科学&#x27;, &#x27;Shon&#x27;] 查操作 index /count/remove1names 1#[&#x27;data2&#x27;, &#x27;数据科学&#x27;, &#x27;excellent&#x27;, &#x27;数据科学&#x27;, &#x27;Shon&#x27;] 1names.index(&#x27;excellent&#x27;) #返回从左开始匹配到的第一个excellent的索引 1#2 1names.count(&#x27;数据科学&#x27;) #返回元素“excellent”的个数 1#2 1&#x27;data2&#x27; in names 1#True 1names 1#[&#x27;data2&#x27;, &#x27;数据科学&#x27;, &#x27;excellent&#x27;, &#x27;数据科学&#x27;, &#x27;Shon&#x27;] 12names.remove(&#x27;Shon&#x27;)names 1#[&#x27;data2&#x27;, &#x27;数据科学&#x27;, &#x27;excellent&#x27;, &#x27;数据科学&#x27;] 切片操作就像切面包，一片一片的把列表切开 切片操作是列表操作中 12a=[&#x27;123&#x27;,&#x27;987&#x27;,&#x27;3&#x27;,&#x27;dc&#x27;,&#x27;真的&#x27;,&#x27;r&#x27;]a 1#[&#x27;123&#x27;, &#x27;987&#x27;, &#x27;3&#x27;, &#x27;dc&#x27;, &#x27;真的&#x27;, &#x27;r&#x27;] 1a[0:2] 1#[&#x27;123&#x27;, &#x27;987&#x27;] 1a[4:-1] 1#[&#x27;真的&#x27;] 1a[0:-1] 1#[&#x27;123&#x27;, &#x27;987&#x27;, &#x27;3&#x27;, &#x27;dc&#x27;, &#x27;真的&#x27;] 1a[4:] 1#[&#x27;真的&#x27;, &#x27;r&#x27;] 12#步长a[0:4:2] 1#[&#x27;123&#x27;, &#x27;3&#x27;] 1a[0::2] 1#[&#x27;123&#x27;, &#x27;3&#x27;, &#x27;真的&#x27;] 1a[-1:-6:-1] 1#[&#x27;r&#x27;, &#x27;真的&#x27;, &#x27;dc&#x27;, &#x27;3&#x27;, &#x27;987&#x27;] 1a[0::] 1#[&#x27;123&#x27;, &#x27;987&#x27;, &#x27;3&#x27;, &#x27;dc&#x27;, &#x27;真的&#x27;, &#x27;r&#x27;] 反转1a[::-1] 1#[&#x27;r&#x27;, &#x27;真的&#x27;, &#x27;dc&#x27;, &#x27;3&#x27;, &#x27;987&#x27;, &#x27;123&#x27;] 1a[::-2] 1#[&#x27;r&#x27;, &#x27;dc&#x27;, &#x27;987&#x27;] 排序12b=[4,90,54,23,44,456,1,4]b 1#[4, 90, 54, 23, 44, 456, 1, 4] 12b.sort()b 1#[1, 4, 4, 23, 44, 54, 90, 456] 12m=&#x27;数据科学&#x27;m 1#&#x27;数据科学&#x27; 1m[::-1] 1#&#x27;学科据数&#x27; 循环列表while循环 for循环 123for i in b: print(i) 12345678910&#x27;&#x27;&#x27;14423445490456&#x27;&#x27;&#x27; 今日小作业 输入n个整数，用空格分开，输出这些整数中的最大值及最大值的下标，如对应多个下标，返回最小下标。 例如输入3 4 7 2 5 7，输出7 2 判断季节,输入一个月份,判断该季节属于哪个季节 敏感词替换习题,模仿评论中出现敏感词后,替换成*,将不敏感的词以列表形式输出 用range()函数创建一个1到100的正整数数列：[1, 2, 3, …, 100]请利用切片从上述数列中分别取出： 前10个数； 后10个偶数； 3的倍数； 不大于50的5的倍数。 将输入的一行字符串构造为列表（每个字母为一个元素），依次做如下操作并输出结果： 1） 将第2个元素（元素个数从0开始计算）直到末尾替换为op； 2） 将第3个元素替换为ui； 3） 从第2个元素开始直到末尾，每隔一个元素，替换一个元素，依次替换为wo","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day3.Python判断与循环语句","slug":"Python/Python入门/Day3判断&循环语句","date":"2020-09-03T02:12:36.000Z","updated":"2020-09-11T09:16:40.665Z","comments":true,"path":"posts/901b8cd5.html","link":"","permalink":"http://www.a2data.cn/posts/901b8cd5.html","excerpt":"Python判断与循环语句！！！","text":"Python判断与循环语句！！！ 例题引导： Q：输入3个整数，按从小到大依次输出，用“-&gt;”符号相连： 例如：输入4，2，6，输出2 -&gt; 4 -&gt; 6 A： 12345678910111213141516171819a = int(input(&#x27;请输入第一个整数：&#x27;))b = int(input(&#x27;请输入第二个整数：&#x27;))c = int(input(&#x27;请输入第三个整数：&#x27;))if (a &gt; b):x = bb = aa = xif (a &gt; c):x = cc = aa = xif (b &gt; c):x = cc = bb = xprint(a,&#x27;-&gt;&#x27;,b,&#x27;-&gt;&#x27;,c) 学习引导： if判断语句 while循环 continue、break的用法 for语句 判断语句if判断语句该语句的语法格式如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#单条件判断：if condition_1: result_1else: result_2#多条件判断：if condition_1: result_1elif: result_2elif: result_3else: result_4 &#x27;&#x27;&#x27;现在我们做一个成绩评级的小程序要求：按照90-100/80-89/60-79/40-59/小于39划分五个等级&#x27;&#x27;&#x27;score=eval(input(&quot;请输入成绩:\\n&quot;))#eval是Python的一个内置函数，这个函数的作用是，返回传入字符串的表达式的结果。if (score&gt;90)&amp;(score&lt;=100): print(&#x27;该同学成绩为优&#x27;)elif (score&gt;80)&amp;(score&lt;=89): #多条件判断 print(&#x27;该同学成绩为良&#x27;)elif (score&gt;60)&amp;(score&lt;=79): print(&#x27;该同学成绩为良&#x27;)elif (score&gt;40)&amp;(score&lt;=59): print(&#x27;该同学成绩为不及格&#x27;)elif (score&lt;39)&amp;(score&gt;0): print(&#x27;该同学请自行退学&#x27;)&#x27;&#x27;&#x27;请输入成绩:34该同学请自行退学&#x27;&#x27;&#x27; 小测试： 在日常编码中if的使用率会很高,但是过度臃肿的if条件会增加代码的理解难度,导致最后只能自己看懂一些 123456789101112131415161718for a in Data: if a.b: if a.c: if a.d:# do sth...for a in balabala: if not a.b: continue if not a.c: continue if not a.d: continue# do sth.. 如上两端代码,进行测试的时候其中的值可以随意,虽然判断逻辑不尽相同,但是目的是一样的,这时候执行效率会有差别吗?那么if这种不可能避免的代码怎么才能进行优化,提高执行效率呢? 体质指数(BMI)=体重(kg)÷身高^2(m)，请根据公式构造一段代码，输入体重和身高，输出BMI指数结果：低于18.5：过轻18.5-25：正常25-28：过重28-32：肥胖高于32：严重肥胖 将一个正整数分解质因数。例如：输入90,打印出90=233*5 循环语句while 循环while语句格式： 12while condition(判断条件): statements(执行语句) 实例：计算1-100的和 123456789101112131415161718192021#简单一点的写法n=0sum=0while n&lt;=100: sum +=n n+=1print(sum)#规范一点的写法# n = 100# sum = 0# counter = 1# while counter &lt;= n:# sum = sum + counter# counter += 1# # print(&quot;1 到 %d 之和为: %d&quot; % (n,sum))#5050 下面做一个小游戏，猜一下随机数 这里用到了random这个随机数模块，这个模块用于生成随机数。 其中random.randint(a,b)用于生成指定范围内的整数，参数a是下限，参数b是上限，生成的随机数介于二者之间。 1234567891011121314151617import randomn=random.randint(0,10)user_guess=int(input(&quot;Input your guess:&quot;))if user_guess&gt;n: print(&#x27;try smaller...&#x27;)elif user_guess&lt;n: print(&#x27;try bigger...&#x27;)else: print(&#x27;Bingo!You got it!&#x27;)print(n)&#x27;&#x27;&#x27;Input your guess:9try smaller...1&#x27;&#x27;&#x27; 上面的这串程序只能猜一次，那如果我们想要猜出结果呢?这个时候就要用到循环。下面我们对上面的代码进行优化 12345678910111213141516171819202122import randomn = random.randint(0, 10)user_guess = int()while user_guess != n: user_guess = int(input(&quot;Input your guess:&quot;)) if user_guess &gt; n: print(&#x27;try smaller...&#x27;) elif user_guess &lt; n: print(&#x27;try bigger...&#x27;) else: print(&#x27;Bingo!You got it!&#x27;)print(n)&#x27;&#x27;&#x27;Input your guess:3try smaller...Input your guess:1Bingo!You got it!1&#x27;&#x27;&#x27; 小测试： 丑数是只包含质因数 2, 3, 5 的正整数。控制台输入一个正整数，判断其是否为丑数。 有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来的第几号。 使用while循环输出1-2+3-4+5…..+99的和。 continue、break的用法 continue是终止本次循环 break是终止循环 12345678910111213141516171819202122#continue举例#输出十以内小于等于4和大于等于7的数count=0while count&lt;10: count +=1 if count&gt;4 and count&lt;7: continue print(count)&#x27;&#x27;&#x27;123478910&#x27;&#x27;&#x27; continue + else 的用法 123456789101112131415161718192021count=0while count&lt;10: count +=1 if count&gt;4 and count&lt;7: #当数字满足上述条件时，执行continue，终止本次循环，不执行打印语句。 continue print(count)else: print(&#x27;循环正常结束&#x27;)&#x27;&#x27;&#x27;123478910循环正常结束&#x27;&#x27;&#x27; break的用法 123456789101112131415count=0while count&lt;10: count +=1 if count&gt;4: #当数字大于4的时候执行break，终止循环 break print(count)else: print(&#x27;循环正常结束&#x27;)&#x27;&#x27;&#x27;1234&#x27;&#x27;&#x27; 小测试 定义用户名“python”和密码“666666”，控制台提示用户输入用户名和密码，判断用户名和密码是否正确。 输入正确则跳出循环，输出“你好！”，不正确则提示“验证失败，请重新输入！”并继续提示用户输出用户名和密码，直到用户输入正确的信息，程序结束。 for语句for循环可以遍历任何序列的所有元素 for语句的一般格式如下： 1234for variable(变量) in [sequence(序列)]: statements(执行语句)else: statements(执行语句) 循环实例： 123456789101112131415161718192021222324252627a=[&#x27;welcome&#x27;,&#x27;to&#x27;,&#x27;data&#x27;,&#x27;science&#x27;]for i in a: #遍历数组内的每一个元素并且打印 print (i) for i in &#x27;DataScience&#x27;: #遍历该字符串的每一个元素且打印 print (i)print(&#x27;遍历结束&#x27;)&#x27;&#x27;&#x27;welcometodatascienceDataScience遍历结束&#x27;&#x27;&#x27; for…else…语句12345678910111213#判断一个数是不是质数n=int(input(&#x27;请随机输入一个实数：&#x27;)) for i in range(2,n): if n%i == 0: #判断是否能整除，如能，打印输出，终止循环；若不能，执行else语句 print(n,&#x27;能被&#123;&#125;整除，不是质数&#x27;.format(i)) #format的用法，之前的课程我们有讲到 break# continueelse: print (n,&#x27;是一个质数&#x27;)&#x27;&#x27;&#x27;请随机输入一个实数：44 能被2整除，不是质数&#x27;&#x27;&#x27; 循环嵌套for 循环嵌套和while 循环嵌套的案例演示 for 循环嵌套格式 1234567891011for variable in seuqence: for veriable_ in sequence_: statements_ statements#while 循环嵌套格式while condition: while condition_: statements_ statements#for 和 while 也可相互嵌套 判断1-20之间哪些是质数 12345678910111213141516171819202122232425i = 2while(i &lt; 20): j = 2 while(j &lt;= (i/j)): if not(i%j): break j = j + 1 if (j &gt; i/j): print (i, &quot; 是质数&quot;) i = i + 1print (&quot;结束!&quot;)&#x27;&#x27;&#x27;2 是质数3 是质数5 是质数7 是质数11 是质数13 是质数17 是质数19 是质数结束!&#x27;&#x27;&#x27; 小测试 在一行中输入8个人的身高（按空格分隔），输出8人的身高平均值和身高超过平均值的数： 例如：输入166 178 192 188 173 169 170 172，输出： avg = 176.0 178 192 188 将一笔零钱换成5分、2分和1分的硬币，要求每种硬币至少有一枚，有几种不同的换法？ 输入待换的零钱数额x∈(8,100)。 要求按5分、2分和1分硬币的数量依次从大到小的顺序，输出各种换法。每行输出一种换法，格式为：“fen5:5分硬币数量, fen2:2分硬币数量, fen1:1分硬币数量, total:硬币总数量”。最后一行输出“count = 换法个数”。 例如，输入13，输出如下： 12345fen5:2, fen2:1, fen1:1, total:4fen5:1, fen2:3, fen1:2, total:6fen5:1, fen2:2, fen1:4, total:7fen5:1, fen2:1, fen1:6, total:8count = 4 输入行数，输出高度为该行数的等边三角形，每行个数递增1。例如输入3，输出： 123 * * * * * * 计算10到20000之间,所有质数,并思考执行时间(在进行大数据量运算时,代码执行效率会影响很多) 一个数如果恰好等于它的因子之和，这个数就称为”完数”。例如6=1＋2＋3。编程找出1000以内的所有完数。","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day2.Python变量和运算符","slug":"Python/Python入门/Day2变量和运算符","date":"2020-09-02T15:58:05.000Z","updated":"2020-09-11T08:26:08.606Z","comments":true,"path":"posts/80ca38c0.html","link":"","permalink":"http://www.a2data.cn/posts/80ca38c0.html","excerpt":"Python变量与运算符！！！","text":"Python变量与运算符！！！ 我们还是用一个问题来引出今天的学习内容,同样是计算成绩。 Q：给定学生三门成绩 (1)计算该学生的平均成绩并打印平均成绩保留两位小数点 (2)计算该学生语文成绩占总成绩的百分之多少？并打印，百分比也保留两位小数 Chinese = 92 Math = 98.5 English = 93 A： 123456789101112131415161718192021# ID 生成唯一UUIDChinese = 92Math = 98.5English = 93# 总成绩SumScore = Chinese + Math + English# 平均成绩AvgScore = SumScore / 3# 百分比ChinesePercent = ( Chinese / SumScore ) * 100print(&quot;%s的平均成绩为%.2f&quot; %(ID,AvgScore))#输出9fde9178-ec75-11ea-9d07-a0510bfd82f69fde9178-ec75-11ea-9d07-a0510bfd82f6的平均成绩为94.50 学前引导： 变量&amp;运算符(本文重点)： 变量 转义字符 运算符 初识判断语句 关于变量变量的创建过程首先，当我们定义了一个变量**name = ‘Data’**的时候，在内存中其实是做了这样一件事。 程序开辟了一块内存空间，将’Data’存储进去，再让变量名name指向’Data’所在的内存地址。如下所示： 12345#通过下列方法可以查看这个变量在内存中的地址name = &#x27;Data&#x27;print(id(name))2720846969904 变量的修改一般我们认为修改一个变量就是用新值把就旧值覆盖掉 实际的原理是什么样的呢？ 程序先申请了一块内存空间来存储’Data’，让name变量名指向这块内存空间，往下执行name = ‘Science’之后，又申请了另一块内存空间来存储’Science’，并让原本指向’Data’内存的链接断开，让name再指向’Science’。 123456789#案例演示name = &#x27;Data&#x27;print(id(name))name = &#x27;Science&#x27;print(id(name))27208469699042718733174640 变量的指向关系当执行name2 = name1时，事实上时让name2指向了’Data’所在的内存地址。 修改name1的值，相当于断开了name1到’Data’的链接，重新建立name1和’Science’之间的链接。 在这个过程中，始终没有影响到name2和’Data’之间的关系，因此name2还是’Data’，而name1变成了’Science’ 12345678#案例演示name1 = &#x27;Data&#x27;name2 = name1print(name1, name2)name1 = &#x27;Science&#x27;print(name1, name2)Data DataScience Data 变量小测试：1、以下可以作为python标识符是___。 A.2morrow B.your-name C._study D.abc*123 2、如下示例:字符串str1的值赋值给str2时,str2的变量地址是否改变?如果是字典赋值呢? 1234str1= &#x27;python&#x27;str2= &#x27;pandas&#x27;str2= str1 运算符 算术运算符 运算优先级 赋值运算符 复合赋值运算符 算术运算符即基本的算术运算：加+、 减- 、乘* 、除/ 、取余% 、幂** 、取整除// 下面以a=10 ,b=20为例进行计算 运算符 描述 实例 + 加 两个对象相加 a + b 输出结果 30 - 减 得到负数或是一个数减去另一个数 a - b 输出结果 -10 * 乘 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 / 除 x除以y b / a 输出结果 2 % 取余 返回除法的余数 b % a 输出结果 0 ** 幂 返回x的y次幂 a**b 为10的20次方， 输出结果 100000000000000000000 // 取整除 返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0 1234567891011121314151617181920# 更多案例a=21b=3c=4print(a+b)print(a-b)print(a/b)print(a*b)print(c**3)print(a%c)print(a//c)print(45-a)24187.063641524 赋值运算符 运算符 描述 实例 = 赋值运算符 把=号右边的结果给左边的变量 num=1+2*3 结果num的值为7 直接赋值= 加法赋值运算符 += 减法赋值运算符 -= 乘法赋值运算符 *= 除法赋值运算符 /= 取余赋值运算符 %= 幂赋值运算符**= 取整除赋值运算符//= 其中比较常见的运算符有+=(自加)和-=(自减) 12345678910a&#x3D;3b&#x3D;2c&#x3D;10# c+&#x3D;ac&#x2F;&#x3D;bprint(c)a+&#x3D;4print(a)5.07 复合赋值运算符 运算符 描述 实例 += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c ** = a 等效于 c = c ** a //= 取整除赋值运算符 c //= a 等效于 c = c // a 比较运算符比较运算符通常在条件判断中经常使用到 相等== 不相等！= 大于&gt; 小于&lt; 大于等于&gt;= 小于等于&lt;= 如下表 运算符 描述 示例 == 检查两个操作数的值是否相等，如果是则条件变为真。 如a=3,b=3则（a == b) 为 true. != 检查两个操作数的值是否相等，如果值不相等，则条件变为真。 如a=1,b=3则(a != b) 为 true. &lt;&gt; 检查两个操作数的值是否相等，如果值不相等，则条件变为真。 如a=1,b=3则(a &lt;&gt; b) 为 true。这个类似于 != 运算符 &gt; 检查左操作数的值是否大于右操作数的值，如果是，则条件成立。 如a=7,b=3则(a &gt; b) 为 true. &lt; 检查左操作数的值是否小于右操作数的值，如果是，则条件成立。 如a=7,b=3则(a &lt; b) 为 false. &gt;= 检查左操作数的值是否大于或等于右操作数的值，如果是，则条件成立。 如a=3,b=3则(a &gt;= b) 为 true. &lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是，则条件成立。 如a=3,b=3则(a &lt;= b) 为 true. 123456789101112a=5b=10c=1print(a&gt;b)if a&gt;b: print(&#x27;a大于b&#x27;)else: print(&#x27;a小于b&#x27;)Falsea小于b 逻辑运算符逻辑运算符为结果真假的与或非分别用and or not来表示，我们这里可以通过简单的赋值来体会这个逻辑关系。 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是 True，它返回 True，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 1234567891011121314151617181920212223242526272829303132333435363738a = 10b = 20if a and b : #判断a和b是否都为真 print(&quot;a，b均为真&quot;) else: print(&quot;a,b中有一个不为真&quot;)**********************************if a or b : print(&quot;a,b中至少有一个为真&quot;)else: print(&quot;a,b都不为真&quot;) *********************************** #修改变量 a 的值a = 0if a and b : print (&quot;a,b都为真&quot;)else: print(&quot;a,b中有一个不为真&quot;) ***********************************if a or b : print(&quot;a,b中至少有一个为真&quot;) else: print(&quot;a,b都不为真&quot;) ************************************if not( a and b ): print(&quot;a,b中至少有一个为假&quot;)else: print(&quot;a,b都为真&quot;) a，b均为真a,b中至少有一个为真a,b中有一个不为真a,b中至少有一个为真a,b中至少有一个为假 位运算符按位运算符是把数字看作二进制来进行计算的。 ‘&amp;’表示为按位与 ‘|’表示为按位或 ‘^’表示按位异或 ‘~’表示按位取反 ‘&lt;&lt;’表示按位左移 ‘&gt;&gt;’表示按位右移 12345678910111213141516171819202122a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = 0c = a &amp; b; # 12 = 0000 1100print(&quot; c 的值为：&quot;, c)c = a | b; # 61 = 0011 1101 print(&quot;c 的值为：&quot;, c)c = a ^ b; # 49 = 0011 0001print (&quot;c 的值为：&quot;, c)c = ~a; # -61 = -0111101print(&quot;c 的值为：&quot;, c) c = a &lt;&lt; 2; # 240 = 1111 0000print(&quot;c 的值为：&quot;, c) c = a &gt;&gt; 2; # 15 = 0000 1111print(&quot;c 的值为：&quot;, c) 条件(三元)运算符语法： ​ 语句1 if 条件表达式 else 语句2 执行流程： 条件运算符在执行时，会先对条件表达式进行求值判断 如果判断结果为True，则执行语句1，并返回执行结果 如果判断结果为False，则执行语句2，并返回执行结果 例子： 123456789a=10b=5if a&gt;15: c=aelse: c=bprint(c)5 上面的运算可以用三元运算来表示，即： 1234c=a if a&gt;15 else bprint(c)5 今日小作业1、控制台输入半径，计算圆的面积，圆周率取3.14。 输入格式： 系统提示the radius is，输入一个整数 输出格式（以半径2为例）： area=12.56 2、判断字符串”alpha”和”Beta”的大小： A.”alpha” &lt; “Beta” -B.”alpha” &gt; “Beta” 3、如下代码的运算结果是： 121 == 1 and not (&quot;apple&quot; == 1 or 1 == 0) A. True B. False C. 1 D. 0 4、如下代码的运算结果是： 12not 2 &gt; 1 and 3 &lt; 4 or 4 &gt; 5 and 2 &gt; 1 and 9 &gt; 8 or 7 &lt; 6 A. True B. False C. 无法输出 5、控制台输入两个整数，输出两数之和，要求不得使用 “+”、“-”、“*”、“/” 四则运算符号。 6、输入三个整数，用三目运算符输出其中的最大值","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day1.Python基本操作与格式规范","slug":"Python/Python入门/Day1基本操作与格式规范","date":"2020-09-01T01:58:45.000Z","updated":"2020-09-18T02:25:46.974Z","comments":true,"path":"posts/fbd6efa0.html","link":"","permalink":"http://www.a2data.cn/posts/fbd6efa0.html","excerpt":"Python基本操作与格式规范！！！","text":"Python基本操作与格式规范！！！ 在开始学习之前，我们做一道题，来作为大家今天的开场白！！ Q：现有信息学号为u20201111的学生，数学成绩为85，化学成绩为82.46，请按下方格式输出该信息 u20201111 的数学分数是 85 u20201111 的化学分数是 82.46 A: 1234567891011121314uid = &#x27;u20201111&#x27;Math = 85Chemistry = 82.46Sum = Math + Chemistryprint(&quot;%s 的数学成绩是 %d&quot; %(uid,Math))print(&quot;%s 的化学成绩是 %.2f&quot; %(uid,Chemistry))print(&quot;%s 的总成绩是 %d&quot;%(uid,Sum))&#x27;&#x27;&#x27;上面的小例题大家看懂了吗？没看懂的要亲手敲一下哦~&#x27;&#x27;&#x27; 学前引导： 基本操作和格式规范（本文重点） 编码规范 注释 打印 格式化输出 format用法 转义字符 编码规范国际惯例，文件编码和 Python 编码格式全部为 utf-8 例如：在 Python 代码的开头，要统一加上 # – coding: utf-8 –。 命名规范变量和标识符，变量和标识符在命名规则上都遵循以下原则， 只能由字母、数字和下划线组成，且不能以数字开头 命名要做到见名知意：一般来说，只要是自定义的名字都可以被称为标识符，包括变量、函数名、类名、模块名、包名，所以变量其实只是标识符的一个子类。 变量常见的命名风格有三种： 单词全部纯小写，单词之间使用下划线隔开，例如：data_science 小驼峰式命名，第一个单词字母全小写，其他单词首字母大写，例如：dataScience 大驼峰式命名，每个单词的首字母均大写，例如：DataScience 以上这些命名规范不仅仅适用于变量，同时也适用于函数、类等； 在Python中，方法和变量名一般采用第一种方式，类名采用第三种方式，第二种方式在Java声明函数时比较常见。 切记，标识符的名字不能和Python的关键字冲突(可以使用keyword.kwlist查看Python所有的关键字) 注释Python2-3输出区别 Python3 使用 print 必须要以小括号包裹打印内容，比如 print(&#39;hi&#39;) Python2 既可以使用带小括号的方式，也可以使用一个空格来分隔打印内容，比如 print &#39;hi&#39; 现在都是以python3为主 Python中单行注释以 # 开头，实例如下： 123#我的第一行代码print(&#x27;hello world&#x27;) #我的第二个注释hello world 多行注释可以用多个 # 号，还有 ‘’’ 和 *”””*： 12345678910111213&#x27;&#x27;&#x27;我真的可以注释很多行&#x27;&#x27;&#x27;&quot;&quot;&quot;我也能注释很多行&quot;&quot;&quot;print(&#x27;hello world&#x27;)hello world 格式化输出**拼接符 ‘+’ ** print(‘变量名：’+变量) 注意：变量必须为字符串类型 拼接符’,’ print(‘变量名：’，变量) 格式化符号整数输出： %o —— oct 八进制 %d —— dec 十进制 %x —— hex 十六进制 1234567print(&#x27;%o&#x27; % 20) #以八进制输出20print(&#x27;%d&#x27; % 20) #以十进制输出20print(&#x27;%x&#x27; % 20) #以十六进制输出20242014 浮点数输出 %f ——保留小数点后面六位有效数字 %.3f，保留3位小数位 %e ——保留小数点后面六位有效数字，指数形式输出 %.3e，保留3位小数位，使用科学计数法 %g ——在保证六位有效数字的前提下，使用小数方式，否则使用科学计数法 %.3g，保留3位有效数字，使用小数或科学计数法 下面做一系列的演示： 1234567891011121314print(&#x27;%f&#x27; % 1.11) # 默认保留6位小数print(&#x27;%.1f&#x27; % 1.11) # 取1位小数print(&#x27;%e&#x27; % 1.11) # 默认6位小数，用科学计数法print(&#x27;%.3e&#x27; % 1.11) # 取3位小数，用科学计数法print(&#x27;%g&#x27; % 1111.1111) # 默认6位有效数字print(&#x27;%.7g&#x27; % 1111.1111) # 取7位有效数字print(&#x27;%.2g&#x27; % 1111.1111) # 取2位有效数字，自动转换为科学计数法1.1100001.11.110000e+001.110e+001111.111111.1111.1e+03 format的用法format的用法很常见，并且实用，大家可以根据案例多进行模仿与演示。 format就是变量之间的映射，它有三种形式 （1）不带编号，即“{}” （2）带数字编号，可调换顺序，即“{1}”、“{2}” （3）带关键字，即“{a}”、“{tom}” 映射案例如下： 1234567891011print(&#x27;&#123;&#125; &#123;&#125;&#x27;.format(&#x27;hello&#x27;,&#x27;world&#x27;)) # 不带字段print(&#x27;&#123;0&#125; &#123;1&#125;&#x27;.format(&#x27;hello&#x27;,&#x27;world&#x27;)) # 带数字编号print(&#x27;&#123;0&#125; &#123;1&#125; &#123;0&#125;&#x27;.format(&#x27;hello&#x27;,&#x27;world&#x27;)) # 打乱顺序print(&#x27;&#123;1&#125; &#123;1&#125; &#123;0&#125;&#x27;.format(&#x27;hello&#x27;,&#x27;world&#x27;))print(&#x27;&#123;a&#125; &#123;tom&#125; &#123;a&#125;&#x27;.format(tom=&#x27;hello&#x27;,a=&#x27;world&#x27;)) # 带关键字hello worldhello worldhello world helloworld world helloworld hello world 格式化字符串 f-string，亦称为格式化字符串常量（formatted string literals），是Python3.6新引入的一种字符串格式化方法。 f-string在形式上是以 f 或 F 修饰符引领的字符串（f’xxx’ 或 F’xxx’），以大括号 {} 标明被替换的字段； f-string在本质上并不是字符串常量，而是一个在运行时运算求值的表达式。 先尝试一下str、int类型的变量 1234name = &quot;小风&quot;age = 18print(f&quot;姓名：&#123;name&#125;，年龄：&#123;age&#125;&quot;)姓名：小风，年龄：18 再试一下字典 123one_dict = &#123;&quot;name&quot;: &quot;小风&quot;, &quot;age&quot;: 18, &quot;hobby&quot;: [&quot;running&quot;, &quot;singing&quot;]&#125;print(f&quot;姓名：&#123;one_dict[&#x27;name&#x27;]&#125;,爱好：&#123;one_dict[&#x27;hobby&#x27;]&#125;&quot;)姓名：小风,爱好：[&#x27;running&#x27;, &#x27;singing&#x27;] 格式规范：代码块快捷键: CTRL+ALT+L 转义字符转义字符‘\\’可以转义很多字符 ‘\\n’表示换行 ’\\t‘表示制表符 字符’\\‘本身也要转义，所以‘\\’表示的字符就是‘\\’ 下面为‘\\’在输出过程中可能出现的情况; 123456print(&#x27;I\\&#x27;m ok.&#x27;)I&#x27;m ok.print(&#x27;I\\&#x27;m learning\\nPython.&#x27;)I&#x27;m learningPython.print(&#x27;\\\\\\n\\\\&#x27;) 小作业 学号为u20201111的学生，数学成绩为85，化学成绩为82.46，按格式输出： ​ u20201111 的数学分数是 85 ​ u20201111 的化学分数是 82.46 ​ 并且求出该学号学生的总成绩，以及平均分 给定两个整数A和B，输出从A到B的所有整数以及这些数的和。 输入格式： 输入在一行中给出2个整数A和B，其中−100≤A≤B≤100，以空格分隔。 输出格式： 首先顺序输出从A到B的所有整数，每5个数字占一行，每个数字占5个字符宽度，向右对齐。最后在一行中按Sum = X的格式输出全部数字的和X。 给定学生三门成绩 (1)计算该学生的平均成绩并打印平均成绩保留两位小数点 (2)计算该学生语文成绩占总成绩的百分之多少？并打印，百分比也保留两位小数 123Chinese = 92Math = 98.5English = 93 用转义字符，输出一张todo list，包含4条内容并用制表符对齐。格式如下： 12345This is todo list for today: * Meeting at 11:00 * lunch with Mike * buy milk * do yoga 分别用多种格式输出,答案不限,输入参数为like,learning:I like Python, and I’am learning（注意上引号） 进阶题： 编辑完成以下名片的显示： 1234567891011==================================姓名: 努力赚钱的小风 QQ:xxxxxxx手机号:185xxxxxx公司地址:北京市xxxxBlog:www.a2data.cn==================================#思考，如何格式化输出？换行？#进阶思路，如果姓名年龄是否可以是变量传入，或者外部输入呢？","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"2.Git多平台同步","slug":"Git/Git多平台同步","date":"2020-08-31T08:10:46.000Z","updated":"2020-09-18T02:25:45.821Z","comments":true,"path":"posts/88fead8.html","link":"","permalink":"http://www.a2data.cn/posts/88fead8.html","excerpt":"Git 将一个项目同步到多平台上。","text":"Git 将一个项目同步到多平台上。 Git 同时提交到多平台适用背景： 同一项目同步到多个平台上 Github Gitee 项目实战 以MockData项目为例子。 MockData ： 常规操作我们可以先把项目代码 push 到 gitee上。 1、克隆在Gitee创建好的空项目123456# 创建一个文件夹# 再该文件夹下边 使用Git进行如下操作git clone git@github.com:A2Data/mockdata.git 就会得到如图所示: 2、然后我们可以把本地的项目文件放到该目录下 3、使用git上传该项目到 Gitee上123456git add. #添加git commit -m &quot;更新信息&quot;git push # 提交 详细运行过程如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354JackFeng@JackFeng MINGW64 /d/学习/DataDict/mock-data (master)$ lltotal 41drwxr-xr-x 1 JackFeng 197121 0 7月 12 22:09 __pycache__/-rw-r--r-- 1 JackFeng 197121 746 7月 12 22:07 config_all.conf-rwxr-xr-x 1 JackFeng 197121 8779 6月 28 21:15 FakerData.py*-rwxr-xr-x 1 JackFeng 197121 1848 6月 29 14:21 FunctionClassConfig.py*-rw-r--r-- 1 JackFeng 197121 0 8月 31 14:34 LICENSE-rwxr-xr-x 1 JackFeng 197121 168 7月 12 22:00 main.py*-rwxr-xr-x 1 JackFeng 197121 6644 7月 12 22:49 mock.py*-rw-r--r-- 1 JackFeng 197121 3006 7月 12 21:56 Mock数据使用说明.mddrwxr-xr-x 1 JackFeng 197121 0 7月 8 12:26 pools/-rw-r--r-- 1 JackFeng 197121 1008 8月 31 14:34 README.en.md-rw-r--r-- 1 JackFeng 197121 1227 8月 31 14:38 README.mdJackFeng@JackFeng MINGW64 /d/学习/DataDict/mock-data (master)$ git add .JackFeng@JackFeng MINGW64 /d/学习/DataDict/mock-data (master)$ git commit -m &quot;mockdata&quot;[master 8e72f4b] mockdata 16 files changed, 1519 insertions(+) create mode 100644 .idea/inspectionProfiles/profiles_settings.xml create mode 100644 .idea/misc.xml create mode 100644 .idea/mockdata-kath.iml create mode 100644 .idea/modules.xml create mode 100644 .idea/workspace.xml create mode 100644 FakerData.py create mode 100644 FunctionClassConfig.py create mode 100644 &quot;Mock\\346\\225\\260\\346\\215\\256\\344\\275\\277\\347\\224\\250\\350\\257\\264\\346\\230\\216.md&quot; create mode 100644 __pycache__/FakerData.cpython-37.pyc create mode 100644 __pycache__/FunctionClassConfig.cpython-37.pyc create mode 100644 __pycache__/mock.cpython-37.pyc create mode 100644 config_all.conf create mode 100644 main.py create mode 100644 mock.py create mode 100644 pools/majors.csvJackFeng@JackFeng MINGW64 /d/学习/DataDict/mock-data (master)$ git pushEnumerating objects: 24, done.Counting objects: 100% (24/24), done.Delta compression using up to 8 threadsCompressing objects: 100% (20/20), done.Writing objects: 100% (22/22), 21.43 KiB | 1.19 MiB/s, done.Total 22 (delta 1), reused 0 (delta 0)remote: Powered by GITEE.COM [GNK-5.0]To gitee.com:sqlsq_admin/mock-data.git 562b3ee..8e72f4b master -&gt; masterJackFeng@JackFeng MINGW64 /d/学习/DataDict/mock-data (master) 4、查看Gitee提交记录此时发现已经不是空项目了。 Github 创建完成之后的Github项目，也是空项目！ 这边就不演示了。 多平台配置上边只演示 如何项目同步到单个平台，如何同步到多个平台的不同仓库下呢？ Github： &#103;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#x6d;:A2Data/MockData.git Gitee： &#103;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#x65;&#x65;&#46;&#99;&#x6f;&#x6d;:sqlsq_admin/mock-data.git 1、通过命令添加123456789101112131415# 添加第一个仓库git remote add origin git@gitee.com:sqlsq_admin/mock-data.git # 默认情况下 就是origin# 添加第二个仓库git remote set-url --add origin git@github.com:A2Data/MockData.git# 如果还有其他，则可以像添加第二个一样继续添加其他仓库。# 提交git push origin --all 2、仓库状态查看1234git loggit status 3、 .git/config , 配置可以看到目前只有一个！也可以直接打开**.git/config** 这个文件进行配置。 12git remote set-url --add origin git@github.com:A2Data/MockData.git 1234git remotegit remote -v 4、配置方式方法一: 使用 git remote add 命令12345678910111213141516# 1、本地仓库与远程仓库关联起来，再查看一下远程仓库情况git remote add origin git@gitee.com:sqlsq_admin/mock-data.gitgit remote -v# 2、使用如下命令再添加另一个远程仓库git remote add github git@github.com:A2Data/MockData.git# 3、 再次查看远程仓库的情况，可以看到已经有两个远程仓库了。然后再使用相应的命令 push 到对应的仓库就行了。*这种方法的缺点是每次要* push *两次。*git push origin master:mastergit push github master:master 方法二: 使用 git remote set-url 命令123456789101112131415# 1、删除方法一的 sundyn 远程仓库。git remote rm mockdata# 2、使用如下命令添加远程仓库。git remote set-url --add origin git@github.com:A2Data/MockData.git# 3、查看远程仓库情况。可以看到 github 远程仓库有两个 push 地址。*这种方法的好处是每次只需要* push *一次就行了。*git remote -vgit push origin master:master 异常配置的方式就是两种，这个异常的原因 是因为github 和gitee 账号不用。key不同链接失效。 解决方案：123git push origin master:master -f # 强制推。 后续优化之后，再进行升级。","categories":[{"name":"Git","slug":"Git","permalink":"http://www.a2data.cn/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.a2data.cn/tags/Git/"}]},{"title":"Anaconda镜像","slug":"Python/Anaconda/Anaconda镜像源","date":"2020-08-31T03:23:00.000Z","updated":"2020-09-12T04:09:39.839Z","comments":true,"path":"posts/2b36786b.html","link":"","permalink":"http://www.a2data.cn/posts/2b36786b.html","excerpt":"anaconda 镜像源 。","text":"anaconda 镜像源 。 anaconda下载源1.清华源 CMD输入以下命令： 12345678910111213141516171819 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/win-64/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/win-64/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2/win-64/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/mro/win-64/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro/win-64/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r/win-64/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/numba/label/dev/win-64/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/win-64/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/win-64/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/win-64/conda config --set show_channel_urls yes&gt; conda config --set show_channel_urls yes&gt; 删除源&gt; conda config --remove-key $channels 设置搜索时显示通道地址 conda config –set show_channel_urls yes Linux/MAC下 直接修改~/.condaarc文件在”channels”中添加即可 channels: https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ defaultsshow_channel_urls: true","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Anaconda","slug":"Python/Anaconda","permalink":"http://www.a2data.cn/categories/Python/Anaconda/"}],"tags":[{"name":"Anaconda","slug":"Anaconda","permalink":"http://www.a2data.cn/tags/Anaconda/"}]},{"title":"Python环境搭建","slug":"Python/Python环境搭建","date":"2020-08-30T08:28:00.000Z","updated":"2020-09-18T02:25:48.221Z","comments":true,"path":"posts/62910.html","link":"","permalink":"http://www.a2data.cn/posts/62910.html","excerpt":"人生苦短，我用Python。","text":"人生苦短，我用Python。 Python 环境搭建Anaconda这是一个支持 Linux, Mac, Windows系统的python发行版本，占空间约600MB。如对空间要求严格的用户，Miniconda是一种选择。 Windows系统 https://www.anaconda.com/distribution/ 首先打开这个网址 本文以作者系统为例， 双击安装文件 Anaconda3-2019.10-Windows-x86_64.exe，进入安装界面，点击 Next。 点击 I Agree，同意 Anaconda 的协议。 一般选择 Just Me，这也是建议安装选项，当然，选 All Users，为电脑上的所有用户安装也未尝不可。选好了以后点击 Next 继续。 在下图显示的界面选择安装目录，建议不要存C盘，这样以后会更多。 默认第一个勾选框是没有选中的，需要自己点选，这个选项说的是把 Anaconda 添加为 PATH 环境参数 。 后边基本没太多需要注意的。Install 安装到如下界面，可以选择安装，也可以跳过。我这里跳过了。 下一步，Finish 到此，安装完成。其实这个安装很简单。一般都会。 Pycharm开发者最爱之一的编译器。诸多便利之处。等待你 细细体会。 这里作者安装的是最新的IDEA 2019.02 这里不说明，具体安装教程。 主要说破解部分。 https://www.jetbrains.com/pycharm/ 下载之后，双击exe文件。正常安装即可。 划重点，安装完成之后我们选择试用，然后进去Pycharm 进行破解 1、下载补丁文件 jetbrains-agent.jar并将它放置到 pycharm安装目录的\\bin目录下（位置可随意，放这里是怕误操作删除了破解文件）。 2、进入项目界面**“Evaluate for free”免费试用，然后再创建一个空项目，这样就可以进入到pycharm的工作页面 3、配置文件 点击Pycharm最上面的菜单栏中的 “Help” -&gt; “Edit Custom VM Options…”**，如果提示是否要创建文件，点“Create”**。 在打开的vmoptions编辑窗口末行添加：**-javaagent:你pycharm的安装目录\\jetbrains-agent.jar** （注：请仔细检查补丁路径是否正确，如果错误则会出现Pycharm打不开的情况，这时候可以删除用户配置目录下的pycharm）windwos：C:\\Users\\用户名\\ 修改完配置文件之后重启Pycharm修改完配置文件之后重启Pycharm修改完配置文件之后重启Pycharm （重要事情说三遍） 4、输入激活码重启pycharm之后，点击菜单栏中的 “Help” -&gt; “Register …”，这里有两种激活方式： 一、选择最后一种License server激活方式，地址填入：http://jetbrains-license-server （应该会自动填上），或者点击按钮：**”Discover Server”** 来自动填充地址，完成激活 二、如果服务器激活方式无法激活，还可以选择Activation code方式激活，复制下面激活码即可 重启Pycharm，选择自动激活，会自动识别网址进行激活。没有出现日期，就说明永久了。（激活码以及激活插件，请在公号内联系小编获取！） 划重点—- 本教程适用于所有idea，不仅限pycharm哦 – 看到就是赚到，转发一波吧！ Python,你好！ 也许会迟到，但绝对不会缺席！ Anaconda12print(&quot;Hello world&quot;) 全宇宙最亲近一行代码 没有之一 这里我们通过执行Jupyter notebook ，启动方式有两种！ 1、点击 jupyter botebook 图标运行 2、Win+ R 在命令行中输入 Jupyter notebook 对于小白来说，你可能会遇到这样的问题？ 如图所示 默认进入： 更改工作路径之后的截图 恭喜进入Coding的世界 Pycharm1、使用默认安装的Python 2、 如何更改可以调用anaconda解释器呢？ 添加对应的路径即可。 因为anaconda 集成了很多库，不用再安装了。 注意事项： python需要选择 pythonw.exe Jupyter 高级配置Anaconda 配置 Flie：文件 Edit：编辑 View：视图 Cell： 单元格工具栏 Kernel 更改jupyter notebook工作空间方式1： 不是每次都好使 123456789101112131415在其配置文件ipython_notebook_config.py中，有如下一句# The directorytousefornotebooksandkernels.# c.NotebookApp.notebook_dir = u&#x27;&#x27;该句就是用来指定其工作空间的，例如，默认的工作空间是：用户名文件夹，例如，现在想要将工作空间变为D:\\DataScience\\Jupyter，那么，需要做如下更改(要记得删掉注释#)# The directory to use for notebooks and kernels.c.NotebookApp.notebook_dir =u&#x27;\\DataScience\\Jupyte&#x27;注意：路径最后一级后面不要加符号“\\” 如何找到该配置文件？ 1.在cmd中输入jupyter notebook –generate-config 如果该配置文件已经存在，那么，会出现如下信息,从中可以见到配置文件存在的位置，注意，此时，输入N，不要overwrite 如果该配置文件不存在，那么，将会初始化产生一个配置文件 在cmd中输入：ipython profile create 2.打开 jupyter_notebook_config.py 文件，找到 1234## The directory to use for notebooks and kernels.#c.NotebookApp.notebook_dir = &#x27;&#x27; 将要指定的路径填入 #c.NotebookApp.notebook_dir = ‘ ‘ 中的 ‘ ‘ 中即可，同时注意将 #c 中的 # 删去，： 123c.NotebookApp.notebook_dir = &#x27;D:\\DataScience\\Jupyte&#x27; 3.保存，在命令行中再次输入 jupyter notebook 指令即可在指定的文件夹下启动。 方式2(绝招)： 进入工作目录文件夹 键盘Shift+鼠标右键-&gt;在此处打开命令窗口-&gt; 在弹出的命令窗口中输入：Jupyter Notebook 利用jupyter的cell是可以运行python文件的，即在cell中运行如下代码：%runfile.py 1 file.py为要运行的python程序，结果会显示在该cell中 为Jupyter Notebook添加目录功能利用Anaconda安装Jupyter Notebook extensions conda install -c conda-forge jupyter_contrib_nbextensions Jupyter notebook工具栏隐藏和jupyter notebook主题更改 注：有时候jupyter输出后，需要滚动条才能看全，执行下列命令，修改输出段的字号大小，就不需要滚动条了。 在cmd 命令行执行！！！ 1234567891011121314151617181920212223242526272829#jt -t monokai -f fira -fs 13 -cellw 90% -ofs 11 -dfs 11 -T -N#-f(字体) -fs(字体大小) -cellw(占屏比或宽度) -ofs(输出段的字号) -T(显示工具栏) -N(显示自己主机名) jt -t gruvboxl -f fira -fs 13 -cellw 90% -ofs 11 -dfs 11 -T -N# 主题更改pip install --upgrade jupyterthemesjt -ljt -t chesterish -T# 主题列表 chesterish grade3 gruvboxd gruvboxl monokai oceans16 onedork solarizedd solarizedl 恢复默认主题,只需执行代码：jt -r，即可恢复至原来的白色背景。 Jupyter Notebook 的快捷键 Jupyter 编辑模式 命令模式 Jupyter Notebook 有两种键盘输入模式。编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。命令模式，键盘输入运行程序命令；这时的单元框线是灰色。 命令模式 (按键 Esc 开启) Enter : 转入编辑模式 Shift-Enter : 运行本单元，选中下个单元 Ctrl-Enter : 运行本单元 Alt-Enter : 运行本单元，在其下插入新单元 Y : 单元转入代码状态 M :单元转入markdown状态 R : 单元转入raw状态 1 : 设定 1 级标题 2 : 设定 2 级标题 3 : 设定 3 级标题 4 : 设定 4 级标题 5 : 设定 5 级标题 6 : 设定 6 级标题 Up : 选中上方单元 K : 选中上方单元 Down : 选中下方单元 J : 选中下方单元 Shift-K : 扩大选中上方单元 Shift-J : 扩大选中下方单元 A : 在上方插入新单元 B : 在下方插入新单元 X : 剪切选中的单元 C : 复制选中的单元 Shift-V : 粘贴到上方单元 V : 粘贴到下方单元 Z : 恢复删除的最后一个单元 D,D : 删除选中的单元 Shift-M : 合并选中的单元 Ctrl-S : 文件存盘 S : 文件存盘 L : 转换行号 O : 转换输出 Shift-O : 转换输出滚动 Esc : 关闭页面 Q : 关闭页面 H : 显示快捷键帮助 I,I : 中断Notebook内核 0,0 : 重启Notebook内核 Shift : 忽略 Shift-Space : 向上滚动 Space : 向下滚动 编辑模式 ( Enter 键启动) Tab : 代码补全或缩进 Shift-Tab : 提示 Ctrl-] : 缩进 Ctrl-[ : 解除缩进 Ctrl-A : 全选 Ctrl-Z : 复原 Ctrl-Shift-Z : 再做 Ctrl-Y : 再做 Ctrl-Home : 跳到单元开头 Ctrl-Up : 跳到单元开头 Ctrl-End : 跳到单元末尾 Ctrl-Down : 跳到单元末尾 Ctrl-Left : 跳到左边一个字首 Ctrl-Right : 跳到右边一个字首 Ctrl-Backspace : 删除前面一个字 Ctrl-Delete : 删除后面一个字 Esc : 进入命令模式 Ctrl-M : 进入命令模式 Shift-Enter : 运行本单元，选中下一单元 Ctrl-Enter : 运行本单元 Alt-Enter : 运行本单元，在下面插入一单元 Ctrl-Shift– : 分割单元 Ctrl-Shift-Subtract : 分割单元 Ctrl-S : 文件存盘 Shift : 忽略 Up : 光标上移或转入上一单元 Down :光标下移或转入下一单元 Pycharm 常用配置1、Anaconda 和Python环境点击File，选择Settings/Preferences 选择如图： 2、字体大小调整pycharm在安装后，默认的字体很小，为了方便编写代码，都会调的大一些。 调整方式： Windows: File - Settings - Editor - Font Mac: Pycharm - Preferences - Editor - Font 3、常用快捷键 注释(取消注释)选择的行：ctrl + / 2）缩进/取消缩进选择的行： shift + Tab 3）在下方新建行并移到新行行首：Shift + Enter 查看选中函数/类的源码：ctrl + B 更多的快捷键使用可在网上搜索。也可以在pycharm的快捷键说明中查找。 4、设置代码模板在pycharm当中创建某些文件时，可以设置模板。 比如，创建python文件 ，在头部自带 作者/时间/文件名称等信息。 创建unittest文件，生成unittest用例模板。 配置路径： windows: Settings - Editor - File and Code Templates Mac: Preferences - Editor - File and Code Templates Pycharm 如何设置代码作者信息Pycharm 中 File -》Settings -》File and Code Templates》Python Script 123456789101112131415161718192021222324252627282930313233343536373839404142434445### 版本1# -*- coding: utf-8 -*-&quot;&quot;&quot;-------------------------------------------------# @Project :$&#123;PROJECT_NAME&#125;# @File :$&#123;NAME&#125;# @Date :$&#123;DATE&#125; $&#123;TIME&#125;# @Author :作者名# @Email :QQ号# @Software :$&#123;PRODUCT_NAME&#125;# @Blog : www.a2data.cn-------------------------------------------------&quot;&quot;&quot;### 版本2#!/usr/bin/env python# -*- coding: utf-8 -*-&quot;&quot;&quot;__title__ = &#x27;$Package_name&#x27;__author__ = &#x27;$USER&#x27;__mtime__ = &#x27;$DATE&#x27;——blog__ = &#x27;www.a2data.cn&#x27;# 多做多看多想。I love DataScience！ へ ／| /＼7 ∠＿/ / │ ／ ／ │ Z ＿,＜ ／ /`ヽ │ ヽ / 〉 Y ` / / ｲ● ､ ● ⊂⊃〈 / () へ | ＼〈 &gt;ｰ ､_ ィ │ ／／ / へ / ﾉ＜| ＼＼ ヽ_ﾉ (_／ │／／ 7 |／ ＞―r￣￣`ｰ―＿====== Start Succeed =====&quot;&quot;&quot; 5、文件默认编码File Encodings&gt; IDE Encoding: UTF-8;Project Encoding: UTF-8; 6. 设置缩进符为制表符“Tab” File -&gt; Default Settings -&gt; Code Style -&gt; General -&gt; 勾选“Use tab character” -&gt; Python -&gt; 勾选“Use tab character” -&gt; 其他的语言代码同理设置 7、设置Python自动引入包先在 &gt;general &gt; autoimport -&gt; python :show popup 快捷键：Alt + Enter: 自动添加包 8. 代码自动整理设置原图： 去掉之后： 这里line breaks去掉√，否则bar, 和baz会分开在不同行，不好看。","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.a2data.cn/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"Hexo命令","slug":"Hexo/Hexo","date":"2020-08-01T02:45:51.000Z","updated":"2020-08-31T08:16:14.759Z","comments":true,"path":"posts/47ce27c8.html","link":"","permalink":"http://www.a2data.cn/posts/47ce27c8.html","excerpt":"Hexo 常用基本命令","text":"Hexo 常用基本命令 Hexo语法 Hexo 12345678910111213141516hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo new post --p 文件夹名/文件名 &quot;title&quot;hexo new post --p Hexo/hexo &quot;title&quot;hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写1234567hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令123hexo s -g #生成并本地预览hexo d -g #生成并上传 上传插件1234# 在生成以及部署文章之前，需要安装一个扩展： 如下图# mac 用户 需要加 `sudo`npm install hexo-deployer-git --save CheckBox 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 + 默认选中 黄色 + 默认选中 青色 + 默认选中 蓝色 + 默认选中 增加 减少 叉 Radio 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 黄色 青色 蓝色 密码验证码：这里没有验证码验证码：DataScience","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/tags/Hexo/"}]},{"title":"Hello World","slug":"Hexo/hello-world","date":"2020-07-31T11:54:58.992Z","updated":"2020-09-11T08:29:48.927Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"http://www.a2data.cn/posts/4a17b156.html","excerpt":"Hexo 初始页面。","text":"Hexo 初始页面。 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/tags/Hexo/"}]},{"title":"4.数据库操作-DCL","slug":"DataBase/Mysql/4、数据库操作-DCL","date":"2020-06-15T16:16:16.000Z","updated":"2020-09-18T02:25:43.831Z","comments":true,"path":"posts/f8d580eb.html","link":"","permalink":"http://www.a2data.cn/posts/f8d580eb.html","excerpt":"数据库操作DCL","text":"数据库操作DCL DCL DCL（Data Control Language），数据库控制语言。 主要用途：对数据库访问权限进行控制的指令。 操纵命令：GRANT、REVOKE GRANT：对用户进行赋权。 REVOKE：对用户权限进行回收。 用户管理MYSQL8.0后版本不支持grant语句直接创建用户，因此需要先创建用户，再进行赋权。 创建用户12345CREATE USER &#x27;username&#x27;@&#x27;hostname&#x27; IDENTIFIED BY &#x27;密码&#x27;;案例：create user &#x27;csg1&#x27; identified by &#x27;123&#x27;; 用Create创建的用户仅有系统默认权限usage，无其他权限。 删除用户1234DROP USER &#x27;username&#x27;@&#x27;hostname&#x27;;案例：drop user csg1; 权限管理赋权123456GRANT priviledge_name[(list_name1,list?_name2)] ON dbname.table_name FROM &#x27;username&#x27;@&#x27;hostname&#x27;;案例：对账号&#x27;csg1&#x27;添加数据库&#x27;mysqlpractice&#x27;所有表的&#x27;select&#x27;权限。grant select on mysqlpractice.* to csg1; 1234案例：对全库全表赋权所有权限。grant all on *.* to dba@localhost; 查看权限12345查看指定账号权限：SHOW GRANTS FOR &#x27;username&#x27;@&#x27;hostname&#x27;;查看当前用户自身权限：SHOW GRANTS; 回收权限1234REVOKE priviledge_name[(list_name1,list?_name2)] FROM dbname.table_name FROM &#x27;username&#x27;@&#x27;hostname&#x27;;案例：revoke select on mysqlpractice.* from csg1;","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.a2data.cn/categories/DataBase/"},{"name":"Mysql","slug":"DataBase/Mysql","permalink":"http://www.a2data.cn/categories/DataBase/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.a2data.cn/tags/Mysql/"}]},{"title":"2.数据库操作-DDL","slug":"DataBase/Mysql/2、数据库操作-DDL","date":"2020-06-15T16:16:16.000Z","updated":"2020-09-18T02:25:55.228Z","comments":true,"path":"posts/b794162c.html","link":"","permalink":"http://www.a2data.cn/posts/b794162c.html","excerpt":"数据库操作DDL","text":"数据库操作DDL DDL DDL（Data Definition Language）是连接存储世界与现实世界的高铁！ 主要用途： 对数据库对象进行创建、修改、删除等操作。 操作对象： 数据库、数据表、列、索引等。 定义命令： CREATE：创建数据库或表的命令。 DROP：删除已建数据库或表。 ALTER： 添加、修改或删除列，更新表名，字段类型等。 数据库操作1、创建数据库1234-- IF NOT EXISTS --- 不存在则创建，存在则不创建CREATE DATABASE IF NOT EXISTS DataScience; 2、删除数据库1234561、查看所有数据库SHOW DATABASES;2、删除指定数据库DROP DATABASE IF EXISTS DataScience; 3、修改数据库字符集1234561、查看数据库字符集SHOW VARIABLES LIKE&#x27;character_set_database&#x27;;2、修改数据库字符集ALTER DATABASE DataScience character SET &#x27;gbk&#x27;; 4、进入数据库123456USE DataSciecne;mysql&gt; use -&gt; datascience;Query OK, 0 rows affected (0.00 sec) 数据表操作1、创建表语法 123456789CREATE TABLE tab_name(column_name1 type[len],column_name2 type[len],......column_nameN type[len])PRIMARY KEY (`id`)[ ENGINE=InnoDB #存储引擎DEFAULT CHARSET=utf8]; #字符集 创建用户表 123456789CREATE TABLE FansUser(user_id int not null comment &#x27;用户ID&#x27;,user_name varchar(30) not null comment &#x27;名称&#x27;,age int,tel int not null comment &#x27;电话&#x27;,sex bit default 1) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2、删除表12345671、查看目前所有数据表SHOW TABLES;2、删除指定数据表DROP TABLE IF EXISTS FansUser; 3、修改表3.0、表名1234567alter table FansUser rename FansUser1; --修改表名 ALTER TABLE FansUser RENAME User;||ALTER TABLE User RENAME To FansUser; 3.1、列名12345ALTER TABLE FansUser CHANGE COLUMN old_column_name new_column_name varchar(30);--修改表列名ALTER TABLE User change COLUMN sex status bit(1); 3.2、列的类型和约束12345alter table User modify status char(10) --修改表列类型 alter table User change status sex bit(1) -- 修改类型及列名 3.3、新增列 注意：添加新列如无特殊约束条件，则默认添加到最后一列；如果添加到指定位置，则需要注意约束条件的正确使用。 FIRST 表示添加到列表的第一列 AFTER 表示添加到某个列之后 12345678-- 指定位置ALTER TABLE user ADD COLUMN remove bit(1) AFTER age;-- 默认添加alter table user add column name1 varchar(10); --添加表列 3.4、删除列123ALTER TABLE user DROP column_name1; 4、复制表 user 表存在，user1 不存在。 4.0、结构1234567891011-- 要复制的表 在后边。 # like 只是复制表结构CREATE TABLE user1 LIKE user;||-- 通过关键字ascreate table user1 as select * from user limit 0;||create table user1 select * from user limit 0; 4.1、数据及内容1234--通过关键字as通过复制另一张表的表结构和数据创建新表create table user1 as select * from user; 4.2、部分数据1234# 根据条件创建表，并且将查询出来得数，存入表中create table user1 as selecet * from user where age&lt;25; 4.3、部分字段1234# 查询部分字段数据create table user1 as select age,name form user; 索引索引相当于数据表的目录，其优点是可以提高检索数据的速度，但同时也增加了系统维护工作，以及会减慢写入速度。 索引不适用场景 数据较少的表或列 查询频率较低的列 数据类型为 TEXT 、IMAGE、BIT 的数据 字段经常性修改 不常出现在 WHERE 子句及排序的字段 索引选取类型 占用空间较少的数据型优选 简单的整型数据优于字符型 避开存在 NULL 以及 NOT NULL的字段 索引选取字段 数据表的主键、外键 常与其他数据表进行连接的字段 常出现在 WHERE 子句中的字段 常用于排序的字段 1、创建索引方法一：在创建表时创建索引 123456CREATE TABLE table_namecolumn_name1 type[len],column_name2 type[len],......column_nameN type[len])[UNIQUE/FULLTEXT/SPATIAL] INDEX [index_name](column_name[(length)]) 方法二：在已存在的表中创建索引 12CREATE [UNIQUE/FULLTEXT/SPATIAL] INDEX index_nameON table_name(column_name[(length)]) 关于length参数：如果是 CHAR，VARCHAR 类型，length 可以小于字段实际长度；如果是 BLOB 和 TEXT 类型，必须指定length。 2、查看索引&amp;删除索引索引不能修改，想更改索引只能删除后重新创建。 1234查看：SHOW INDEX FROM table_name;删除：DROP INDEX index_name ON table_name;","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.a2data.cn/categories/DataBase/"},{"name":"Mysql","slug":"DataBase/Mysql","permalink":"http://www.a2data.cn/categories/DataBase/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.a2data.cn/tags/Mysql/"}]},{"title":"3.数据库操作-DML","slug":"DataBase/Mysql/3、数据库操作-DML","date":"2020-06-15T16:16:16.000Z","updated":"2020-09-18T02:25:54.305Z","comments":true,"path":"posts/6656ad65.html","link":"","permalink":"http://www.a2data.cn/posts/6656ad65.html","excerpt":"数据库操作DML","text":"数据库操作DML DML DML（Data Manipulation Language），是通过对表中数据的插入、删除和修改等操作，实现对数据库的基本操作。 主要用途：对数据表进行数据插入、删除、修改、排序或检索操作。 操纵命令：INSERT、UPDATE、DELETE INSERT：把数据插入到数据表中。 UPDATE：修改数据记录。 DELETE：删除数据库中不必再继续保留的记录。 1、插入数据形式一1234567INSERT INTO TABLE_NAME (字段名1,字段名2,.....) VALUES(数值1,数值2,....);案例：INSERT INTO user(user_id,user_name,age,remove,tel,sex)VALUES(001,&quot;A2Data&quot;,22,0,18511990011,0); 形式二123456INSERT INTO TABLE_NAME SET 字段名1 = 数值1, 字段名2 = 数值2,....;案例：INSERT INTO user SET user_id=001,user_name=&quot;A2Data&quot;,age=22,remove=0,tel=18511990011,sex=0; 2、修改数据1234UPDATE TABLE_NAME SET 字段名1 = 新数值1,字段名2 = 新数值2;案例：UPDATE USER SET age = 25 , sex = 1; 3、解决重复记录的更新使用on duplicate key update可以解决插入或更改重复主键，即当insert内容和原表内容存在重复记录时，执行update操作。 1INSERT INTO table_name1 SELECT * FROM table_name2 ON DUPLICATE KEY UPDATE column_name = VALUES(column_name); 注意：在使用on duplicate key update时，表中必须要存在至少一个unique key或者primary key。 案例：现有表v1和v2如下： v1表与v2表同时存在id为005的行，且name字段值不一致。 我们使用on duplicate key update对v1表插入v2内容： 1insert into v1 select name,tel,remove from v2 on duplicate key update name = values(name); 查看执行后的v1表内容，可以看到id为005的记录，其name字段值已修改为v2的相应记录： 4、删除数据方法一：DELETE123456DELETE FROM TABLE_NAME[WHERE 子句]如不加WHERE子句则表中数据全部删除案例：DELETE FROM user; 方法二：TRUNCATETRUNCATE优势：作为DDL语句，比DELETE运行速度更快，且使用资源更少 1234TRUNCATE TABLE TABLE_NAME案例：TRUNCATE TABLE user; 5、数据库查询5.1、基本查询语句123SELECT column_name FROM table_nameWHERE 条件语句[LIMIT 限制行数] WHERE限制条件一览表： 限制条件类别 对应标识 备注 比较 &gt;、&lt;、=、&gt;=、&lt;=、&lt;&gt; 集合 in、not in 无法获取null值 指定范围 between and 使用时需注意其结果包含边界值 空值判断 is null、is not null 且 and 或 or 12345案例：SELECT user_id,user_name FROM userWHERE age &gt; 20 and tel IS NOT NULLLIMIT 10; 别名 1234column_name AS 别名table_name AS 别名 *注:*WHERE子句中不可使用别名 GROUP BY：用于对查询结果进行数据分组 HAVING：用于对分组后的结果进行统计，其后可以跟聚合函数 1234567案例：user表记录了用户所在部门user_dept，筛选出部门平均年龄大于25的结果。SELECT user_dept,AVG(age) as &#x27;年龄&#x27; FROM `user`GROUP BY user_deptHAVING AVG(age)&gt;25; HAVING语句用于对分组后的结果进行统计 ORDER BY：对查询结果进行排序,默认为ASC升序，DESC为降序 1234案例：SELECT user_id,user_name FROM `user`ORDER BY user_name ; DISTINCT：取消重复的结果 123案例：SELECT DISTINCT user_dept FROM `user`; 5.2、模糊查询LIKE12SELECT column_name FROM table_nameWHERE column_name LIKE 模式字符串 通配符 含义 % 匹配任意长度（0或多个）字符串，不能匹配空值 _ 匹配任意单个字符串，_表示1个长度 123456案例：查询user表中所有姓名为A开头的人员信息。SELECT * FROM userWHERE user_name like &#x27;A%&#x27;; RLIKE、REGEXP这两个主要用于在MYSQL中进行正则表达式的书写。 12SELECT column_name FROM table_nameWHERE column_name REGEXP/RLIKE 模式字符串; 通配符 含义 . 匹配任意单个字符 * 匹配0个或多个前一个得到的字符 ^ 匹配开头，如^s匹配以s或者S开头的字符串。 $ 匹配结尾，如s$匹配以s结尾的字符串。 {n} 匹配前一个字符反复n次。 ｜ 多个条件间的“或”连接 123456789案例：查询user表中姓名存在字段bb的人员。select * from user where user_name regexp &#x27;b&#123;2&#125;&#x27;;查询user表中姓名为n结尾的人员。select * from user where user_name rlike &#x27;n$&#x27;;查询user表中姓名存在an字段的人员。select * from user where user_name rlike &#x27;an&#x27;; 5.3、存储过程存储过程基本结构12345678构造存储过程：CREATE PROCEDURE 存储体名称(IN/OUT 参数名 参数类型)BEGIN存储内容END;调用存储过程：CALL 存储体名称(参数) 终端运行存储过程12345678910111213141516案例：构造存储体u1，筛选所有部门为R&amp;D的员工。首先将MYSQL默认结束符进行修改：DELIMITER //构造存储过程：CREATE PROCEDURE U1()BEGINSELECT * FROM user WHERE user_dept = &#x27;R&amp;D&#x27;;END//调用存储体：CALL u1()// 5.4、多表查询内连接12SELECT * FROM TABLE_A INNER JOIN TABLE_B ON TABLE_A.COLUMN 比较运算符 TABLE_B.COLUMN; 内连接用于比较并返回满足连接条件的数据行，结果取交集。 inner join示意图： 注意：如果两边的表行数不一致，可能会出现丢失数据。 外连接12SELECT * FROM TABLE_A LEFT|RIGHT|FULL JOIN TABLE_BON TABLE_A.COLUMN 比较运算符 TABLE_B.COLUMN; 外连接的两个表有主从之分，主表全部保存，从表适配保存。 full outer join示意图： left/right outer join示意图： 6、锁表12345锁表；LOCK TABLES table_name LOCK_TYPE解锁：UNLOCK TABLES; Lock_type包含read和write等。 锁为read类型的表，可读但不可写；其他会话对该表可读，但写入需要等到解锁后： 锁为write类型的表，可读也可写；但其他会话对该表的读或写需要等到解锁以后： 7、MYSQL慢查询：EXPLAINexplain语句用于分析MYSQL的查询性能，可以显示MySQL如何使用索引等来处理select语句以及连接表。 1234567用explain查看查询是否使用索引：EXPLAIN SELECT * FROM table_name WHERE 查询条件；案例：对表Sheet1建立索引i1后，用explain查看任意查询情况：explain select * from Sheet1 where number = 1601; explain查询结果type为ref，即使用了索引查询，而非全表遍历查询all；所使用的索引(possible keys/key)为i1：","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.a2data.cn/categories/DataBase/"},{"name":"Mysql","slug":"DataBase/Mysql","permalink":"http://www.a2data.cn/categories/DataBase/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.a2data.cn/tags/Mysql/"}]},{"title":"5.数据库操作-TCL","slug":"DataBase/Mysql/5、数据库操作-TCL","date":"2020-06-15T16:16:16.000Z","updated":"2020-09-18T02:25:54.218Z","comments":true,"path":"posts/e4f3239b.html","link":"","permalink":"http://www.a2data.cn/posts/e4f3239b.html","excerpt":"数据库操作TCL","text":"数据库操作TCL TCL TCL（Transaction Control Language），事务控制语言。 主要用途：对数据库进行事务控制的指令。 操纵命令：COMMIT、ROLLBACK、SAVEPOINT、SET TRANSACTION COMMIT：提交事务。 ROLLBACK：回滚操作。 SAVEPOINT：设置保存点。 SET TRANSACTION：改变事务选项。 1、什么是事务？事务是数据库操作的逻辑单元，包含一系列数据操作，是一个不可分割的整体。 事务的特性——ACID： 原子性(Atomicity)，其包含的所有数据库操作指令要么都执行，如有执行失败会回滚为全都不执行。 一致性(Consistency)，执行前后的数据库有效性是一致的。 隔离性(lsolation)，一个事务不受其他事务的干扰，在多用户并发访问时相互不受干扰。 持久性(Durability)，一旦提交了事务，数据的改变永久保存本地。 2、事务的提交：COMMIT事务的执行内容只有使用commit进行提交后，其中的修改操作才可以成为永久性操作。 1234567891011121314151617181920212223242526先转换MYSQL结束符：DELIMITER //事务结构：START TRANSACTION｜BEGIN:查询主体;COMMIT;//案例：对user表进行如下事务操作：1. 姓名为Olivia的人员年龄修改为402. 插入新记录user_id为018的男性在职人员Ian，年龄23，电话13173629832，部门为CS3. 删除原表中user_id为017的记录4. 查询上述修改结果start transaction;update user set age = &#x27;40&#x27; where user_name = &#x27;Olivia&#x27;;insert user values(&#x27;018&#x27;,&#x27;Ian&#x27;,&#x27;23&#x27;,&#x27;0&#x27;,&#x27;13173629832&#x27;,&#x27;0&#x27;,&#x27;CS&#x27;);delete from user where user_id = &#x27;017&#x27;;select * from user where user_dept = &#x27;CS&#x27; or user_name = &#x27;Olivia&#x27;;commit;// 我们先查询事务执行前的相关表内容： 执行事务： 3、事务的自动提交：AUTOCOMMITautocommit参数记录了数据库是否为自动提交模式，默认状态为on： 案例： 对user表中user_id为018的人员修改姓名为Peter，年龄为50。 我们开启两个终端，并仅将终端一的autocommit参数修改为OFF： 1set autocommit = 0// 在终端一进行姓名的修改操作，不执行commit。 我们可以在终端一中查询到修改后的记录： 而在终端二中，则姓名字段为修改前的记录： 若此时在终端二对user表进行年龄的修改操作，会因为正在进行的事务而报错： 将终端一中的事务提交后，我们完成终端二中的修改并查询结果： 4、事务的回滚：ROLLBACK事务在没有使用commit提交时，使用rollback可以将数据库恢复到事务提交前的状态。 案例： 对user表user_id为016的人员remove信息进行修改，并进行回滚操作。 修改前我们查询该条记录如下： 执行事务后并回滚，可以看到数据修改成功后又回滚到修改前状态： 5、设置保存点：SAVEPOINT在事务中设置savepoint，可以将事务回滚到savepoint前。 1234567891011121314151617设置保存点：SAVEPOINT savepoint_name;回滚到保存点：ROLLBACK TO SAVEPOINT savepoint_name;解除保存点：RELEASE SAVEPOINT savepoint_name;案例：start transaction;update user set remove = 1 where user_id = &#x27;016&#x27;;savepoint s1;delete from user where user_id = &#x27;016&#x27;;rollback to savepoint s1;release savepoint s1;// 6、事物隔离级别：SET TRANSACTION事务的隔离级别可用于防止事务的并发性问题。 事务有如下隔离级别： ​ read uncommitted 读未提交，该模式会出现脏读 ​ read committed 读已提交，该模式不支持重复读 ​ repeatable read 可重复读，也是MYSQL中默认隔离级别 ​ serializable 串行化，不允许读写并发操作 6.1、查看当前的事务隔离级别：1SHOW VARIABLES LIKE &#x27;TRANSACTION ISOLATION&#x27;; 6.2、修改事务隔离级别：1SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL READ 新的事务隔离级别; global：设置全局默认隔离级别 session：设置本次会话隔离级别 如果二者均不写：仅设置本次事务命令的隔离级别，下一个事务将回到默认隔离级别 123案例：将当前会话的隔离级别修改为read committed。set session transaction isolation level read committed; 当前会话隔离级别已更改为read committed： 新开终端再次查询隔离级别，其又回到了默认值repeatable read：","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.a2data.cn/categories/DataBase/"},{"name":"Mysql","slug":"DataBase/Mysql","permalink":"http://www.a2data.cn/categories/DataBase/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.a2data.cn/tags/Mysql/"}]},{"title":"1.认识Mysql","slug":"DataBase/Mysql/1、认识Mysql","date":"2020-06-15T16:16:16.000Z","updated":"2020-09-18T02:25:50.288Z","comments":true,"path":"posts/4354b039.html","link":"","permalink":"http://www.a2data.cn/posts/4354b039.html","excerpt":"认识mysql！","text":"认识mysql！ 背景介绍 数据库，就是数据的仓库。它是长期存储在计算机内，有组织、可共享的数据的集合。简而言之，即放置信息的文件柜。 数据库分类 当今互联网中，最常见的数据库模型主要为两种，即关系型数据库（SQL）和非关系型数据库（NoSQL 、Not Only SQL)。 关系型数据库 1、定义：指采用了关系模型来组织数据的数据库，其以行和列的形式存储数据，以便于用户理解，关系型数据库这一系列的行和列被称为表，一组表组成了数据库。 2、特点 （1）存储方式：以行和列的方式组成表格进行存储。 （2）扩展方式：只具备纵向扩展能力。 （3）查询方式：采用结构化查询语言（即SQL）进行查询。 （4）原子性：记录之前的版本，允许回滚。 （5）一致性：事务开始和结束之间的中间状态不会被其他事务看到。 （6）隔离性：适当的破坏一致性来提升性能与并行度。 （7）持久性：每一次的事务提交后就会保证不会丢失。 3、缺点：性能没有非关系型数据库好，一旦想更改存储结构，面对海量数据，操作起来会很复杂。 非关系型数据库 1、定义：数据存储不需要固定的表结构，通常也不存在连接操作。 2、特点 （1）不需要预定义模式：不需要事先定义数据模式，预定义表结构。 （2）无共享架构：相对于将所有数据存储的存储区域网络中的全共享架构。 （3）弹性可扩展：可以在系统运行的时候，动态增加或者删除结点。 （4）分区：相对于将数据存放于同一个节点，NoSQL数据库需要将数据进行分区，将记录分散在多个节点上面。 （5）异步复制：和RAID存储系统不同的是，NoSQL中的复制，往往是基于日志的异步复制。 （6）BASE：相对于事务严格的ACID特性，NoSQL数据库保证的是BASE特性。 3、适用场景 （1）数据模型比较简单。 （2）需要灵活性更强的IT系统。 （3）对数据库性能要求较高。 （4）不需要高度的数据一致性。 （5）对于给定key，比较容易映射复杂值的环境。 数据库管理系统 这又是啥？ 面对不同种类的数据库，如何精准获取数据库中的数据？智慧的人类创造了一个神奇的产品！！！ 数据库管理系统。数据库管理系统是为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能。 MySQL 江湖地位！ MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。它是最流行的关系型数据库管理系统之一，它也是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 为啥选 MySQL ? MySQL由于其体积小、速度快、总体拥有成本低，尤其是具有开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。 MAC安装MYSQL：下载安装包：点击链接下载MYSQL安装包： https://dev.mysql.com/downloads/mysql/ 终端输入mysql,发现提示command not found，需要先设置环境路径； 终端输入*/user/local/mysql/bin*，查看mysql是否安装成功： 在终端加入环境路径：如果是bash,执行open ~/.bash_profile；如果是zsh,执行open ~/.zshrc； 在bash_profile或zshrc文件中添加语句PATH=$PATH:/usr/local/mysql/bin,并保存； 将更改立即生效：终端输入source ~/.bash_profile 或 source ~/.zshrc 注：如果没有zshrc文件，需要先创建空白文件，再将bash_profile的内容复制粘贴过来，包括上述语句，最后输入上述语句使修改生效 登录和退出MYSQL：登陆：终端输入mysql -uroot -p，输入密码 -u后是用户名，-p后是密码（如不是登陆本机的MYSQL，还有 -h后面加服务器主机地址）。 退出MYSQL：终端输入\\q; 或 quit; 或 exit;","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.a2data.cn/categories/DataBase/"},{"name":"Mysql","slug":"DataBase/Mysql","permalink":"http://www.a2data.cn/categories/DataBase/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.a2data.cn/tags/Mysql/"}]},{"title":"Anaconda闪退","slug":"Python/Anaconda/Anaconda闪退","date":"2020-05-13T02:00:30.000Z","updated":"2020-09-11T07:22:18.035Z","comments":true,"path":"posts/4136.html","link":"","permalink":"http://www.a2data.cn/posts/4136.html","excerpt":"anaconda Windows闪退解决方案 。","text":"anaconda Windows闪退解决方案 。 anaconda 打开闪退 记录windwos 系统下 anaconda 打开闪退修复方式。 解决方式 1、 管理员模式运行 conda prompt 2、执行命令1234conda update anaconda-navigator# 片刻之后 会遇到如下 输入y 即可 3、 重启服务执行anaconda-navigator –reset 12anaconda-navigator --reset 4、更新客户端执行conda update anaconda-client 1234conda update anaconda-clientconda update -f anaconda-client 5、 启动运行 以管理员身份运行 anaconda","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Anaconda","slug":"Python/Anaconda","permalink":"http://www.a2data.cn/categories/Python/Anaconda/"}],"tags":[{"name":"Anaconda","slug":"Anaconda","permalink":"http://www.a2data.cn/tags/Anaconda/"}]},{"title":"2.Python的基础语法","slug":"Python/数据可视化/2、Python基础语法","date":"2020-05-12T13:12:00.000Z","updated":"2020-09-11T08:28:50.284Z","comments":true,"path":"posts/64528.html","link":"","permalink":"http://www.a2data.cn/posts/64528.html","excerpt":"数据可视化，基础语法。","text":"数据可视化，基础语法。 Day2. Python基础语法基础语法想学好数据分析，最好掌握Python语言。Python语言简洁，有大量的第三方库，功能强大，能解决数据分析的大部分问题。在数据科学领域，Python有许多非常著名的工具库：比如科学 计算工具Numpy和Pandas库，深度学习⼯具Keras和TensorFlow，以及机器学习工具Scikit-learn，使用率都非常高。总之，在数字化时代掌握⼀门编程语言，尤其是Python语言的使用是⾮常有必要的。相信使用Python的流行，不必多说，接下来我们一起学习基础语法。需要注意编程中除了文字部分可以使用中文，标点符号一定要使用英文输入法否则会报错。 输入与输出1234name=input(&quot;What&#x27;s your name?&quot;) sum= 100+100 print(&#x27;hello, %s&#x27; %name) print(&#x27;sum= %d&#x27; %sum) input是输入函数，input（）括号中存放的是提示文，双引号里面存放字符串类型数据。在Jupyter Notebook 中运行后会出现一个输入框。将内容输入对话框中，内容会被赋值给变量name。 print是输出函数，括号里是输出的内容，第一个print函数，打印出字符串。%name代表变量name的数值，因为是字符串类型，所以在前面加上%s作为代替。第二个print函数中，%sum代表变量sum的数值，是数值型，在前面加上%d作为代替。 运行结果如下： 123What&#x27;s your name?DataSciencehello, DataSciencesum= 200 判断语句: if … else …**if … else … **是经典的判断语句，需要注意的是在if 后有个冒号，同样在else后⾯也存在冒号。 另外需要注意的是，Python采用代码缩进和冒号的方式来区分代码之间的层次关系。所以代码缩进在Python中是一种语法，如果代码缩进不统一，比如有的是tab有的是空格，会怎样呢？会产生错误或者异常。相同层次的代码⼀定要采用相同层次的缩进。 12345678score = int(input(&#x27;请输入你的成绩&#x27;))if score &gt;= 90: print(&#x27;优秀&#x27;)else: if score &lt; 60: print(&#x27;不及格&#x27;) else: print(&#x27;及格&#x27;) 代码中实现输入分数，判断是否优秀和及格。score后面加上int()作用是将input函数中获得的字符串数值转换为整数integer. 运行结果： 12请输入你的成绩: 58不及格 循环语句：for … in1234sum = 0 for number in range(11): sum = sum + number print(sum) 运行结果 155 for循环是⼀种迭代循环机制，迭代即重复相同的逻辑操作。如果规定循环的次数，我们可以使用range函数，它在for循环中比较常用。range(11)代表从数字0到10，不包括末尾11，也相当于range(0,11)，range里面还可以增加步长，比如range(1,11,2)代表的是数组[1,3,5,7,9] 循环语句: while123456sum = 0 number = 1while number &lt; 11: sum = sum + number number = number + 1print(sum) 运行结果： 155 1到10的求和也可以⽤while循环来写，这里while控制了循环的次数。while循环是条件循环，在while循环中对于变量的计算方式更加灵活。因此while循环适合循环次数不确定的循环，⽽for循环的条件相对确定，适合固定次数的循环。 注释：#注释在python中使用#，也可使用快捷键 ”Ctrl“ 和 ”/“。 如果是多行注释，使用三个单引号，或者三个双引号，比如： 12345678910111213#单行注释&#x27;&#x27;&#x27; 这是多⾏注释，⽤三个单引号 这是多⾏注释，⽤三个单引号这是多⾏注释，⽤三个单引号 &#x27;&#x27;&#x27;”””这是多⾏注释，⽤三个双引号这是多⾏注释，⽤三个双引号这是多⾏注释，⽤三个双引号””” 数据类型：列表、元组、字典、集合Python3 中有六个标准的数据类型： Number（数字） String（字符串） List（列表） Tuple（元组） Set（集合） Dictionary（字典） 列表：[list]1234567lists=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;] lists.append(&#x27;d&#x27;) print(lists)print(len(lists)) lists.insert(0,&#x27;mm&#x27;) lists.pop() print(lists) 运行结果： 123[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]4[&#x27;mm&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] 列表是Python中常用的数据结构，相当于数组，具有增删改查的功能，我们可以使用len()即英文length长度，函数获得lists中元素的个数；使⽤ append()在尾部添加元素，使用insert()在列表中插⼊元素，使用pop()删除尾部元素。 元组 (tuple)12tuples = (&#x27;tupleA&#x27;,&#x27;tupleB&#x27;)print(tuples[0]) 运行结果： 1tupleA 元组tuple和list⾮常类似，但是tuple⼀旦初始化就不能修改。因为不能修改所以没有append(), insert() 这样的⽅法，可以像访问数组⼀样进⾏访问，⽐如tuples[0]，但不能赋值。 字典 {dictionary}12345678910#定义⼀个dictionary score = &#123;&#x27;小李&#x27;:95,&#x27;小王&#x27;:96&#125; #添加⼀个元素 score[&#x27;小张&#x27;]=98 print(score)#删除⼀个元素 score.pop(&#x27;小王&#x27;) print(score)#查看⼀个key对应的值 print(score[&#x27;小李&#x27;]) 运行结果： 123&#123;&#x27;小李&#x27;: 95, &#x27;小王&#x27;: 96, &#x27;小张&#x27;: 98&#125;&#123;&#x27;小李&#x27;: 95, &#x27;小张&#x27;: 98&#125;95 字典其实就是{key, value}键值对，多次对同⼀个key放入value，后面的值会把前面的值覆盖，同样字典也有增删改查。增加字典的元素相当于赋值，比如score[‘小张’] = 98，删除⼀个元素使⽤pop，字典不支持直接修改元素中的key，可将旧元素删除后添加一个元素。 集合：set123456s = set([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;])# 创建集合也可使用花括号&#123;&#125; s = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;s.add(&#x27;d&#x27;)s.remove(&#x27;b&#x27;)print(s)&#x27;c&#x27; in s 运行结果： 12&#123;&#39;c&#39;, &#39;d&#39;, &#39;a&#39;&#125;True 集合set和字典dictionary类似，不过它只是key的集合，不存储value。同样可以增删查，增加使⽤add，删除使⽤remove，查询看某个元素是否在这个集合里，使用in。 引⽤模块/包：import12345678导⼊⼀个模块 import model_name #导⼊多个模块 import module_name1,module_name2 #导⼊包中指定模块from package_name import moudule_name #导⼊包中所有模块 from package_name import * Python语言中import的使用很简单，直接使用import module_name语句导入即可。这里import的本质是什么呢？import的本质路径搜索。import引用可以是模块module，或者包package。 针对module，实际上是引⽤⼀个.py ⽂件。而针对package，可以采⽤from … import …的方式，这里实际上是从⼀个目录中引用模块，这时目录结构中必须带有⼀个_ init_.py⽂件。 函数：def123def addone(score): return score + 1 print(addone(99)) 运行结果： 1100 def是函数装饰器，将函数代码块打包。函数代码块以def关键词开头，后接函数名和圆括号，在圆括号里是传进来的参数，然后通过return进行函数结果得反馈。 课程讲到这里，只是基础的部分，更多需要用到的内容，可以再补充学习，或者做题练习。学习最好的方式是做中学”learning by doing”，建议小伙伴们把以上代码自己动手敲一遍，并提问自己问题，以检验是否掌握以上知识点。 小作业1、如果我想在Python中引⽤matplotlib库该如何引⽤？ 没有matplotib包的话 1pip install matplotlib 已安装直接引入即可 1import matplotlib 2、求1+3+5+7+…+99的求和，⽤Python该如何写？ 1234sum = 0for number in range(1,100,2): sum = sum + numberprint(sum)","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"数据可视化","slug":"Python/数据可视化","permalink":"http://www.a2data.cn/categories/Python/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"1.数据可视化概述","slug":"Python/数据可视化/1、数据可视化概述","date":"2020-05-12T13:11:39.000Z","updated":"2020-09-18T02:25:54.015Z","comments":true,"path":"posts/5590.html","link":"","permalink":"http://www.a2data.cn/posts/5590.html","excerpt":"数据可视化，基础概述。","text":"数据可视化，基础概述。 Day1. 概述Python数据可视化介绍做为⼀名数据分析师，掌握可视化技能是必不可少的。大部分情况下，上级更关心呈现的结果。当可视化的结果呈现在你眼前时，你才能直观地体会到“数据之美”。图片在内容表达上，要远胜于文字，它不仅能体现数据真实性，还能给人很大的想象空间。 我们经常听到的Tableau 和 PowerBI 是商业可视化工具，在可视化灵活分析上功能强⼤，主要目标用户是较专业的数据分析师。同时在工作场景中使用率高，因此掌握对于晋升和求职都很有帮助，之后DataScience也会推出相关培训。 Python是数据分析的首选语言，如果我们的学习目标是数据挖掘工程师，或者算法工程师，那么最重要的就是要了解，并且熟练掌握Python的数据可视化，在校学生以及科研人员也可使用Python进行可视化。此外当我们在使用Python与数据库交互时，获取数据后直接在Python进行分析和观察会更为方便。 Python里包括了众多可视化库，比如：Matplotlib、Seaborn、Bokeh、Plotly、Pyecharts、Mapbox和Geoplotlib。其中使用频率，最需要掌握的就是Matplotlib和Seaborn。 Matplotlib是Python的可视化基础库，作图风格和MATLAB类似，所以称为Matplotlib。⼀般学习Python数据可视化，都会从 Matplotlib⼊⼿，然后再学习其他的Python可视化库。 Seaborn是⼀个基于Matplotlib的⾼级可视化效果库，针对Matplotlib做了更⾼级的封装，让作图变得更加容易 本次课程的内容包含有Python安装，语言基础，绘图基础，和使用Matplotlib和Seaborn库绘制十个常用的可视化试图，如：折线图，直方图，箱线图等，并掌握试图在不同的情况下的适用场景。 安装与环境搭建Python主要有两个版本： 2.7.x和 3.X。 有部分旧的项目使用的包是基于2.7版本的，如果是这样只能使用2.7，目前我们只需要使用新的3.X版本。对于基础的同学，推荐使用Anaconda方式安装Python环境。 Anaconda下载下载地址：https://www.anaconda.com/products/individual 打开页面后，点击下载，根据操作系统选择下载Python3.7版本，分为64为和32位版本，查看操作系统可知下载64或是32，如果计算机设备不是很旧，通常是下载64位。 Anaconda安装打开下载好的安装包，点击”Next” 下一页 ： “I Agree”— 下一页： Install For: Just Me 如果只有一个用户 All User 如果电脑有多个用户选择All User，我这里选择All User，继续点击”Next” 下一页： 选择目标文件夹：如果C盘空间充裕，可选择默认地址； 点击“Next” 下一页： 高级选项： 第一个是加入环境变量，第二个是默认使用Python2.7 ；两个都勾选，点击”Next” 等待安装完成后，点击”FInish“完成安装 启动Jupyter NotebookJupyter Notebook是一个开源的Web应用程序，允许用户创建和共享包含代码、方程式、可视化和文本的文档。使用Jupyter Notebook可以让我们在网页中编辑，运行和调试代码，使用起来非常方便。 Aanconda安装好后，找到菜单目录，找到Anaconda Navigtor图标，双击打开，出现以下界面： 选择Jupyter Notebook，点击“Launch”。启动Jupyter Notebook，此时网页浏览器会打开File，文件界面。 我们可以在桌面建立一个文件，命名为“数据可视化”，来保存代码文件。 在Jupyter Notebook中，选择路径：Desktop/数据可视化/，在右上角处点击New，新建一个Python3文件： 文件建好后，我们在文本框中编辑代码，点击按钮“运行”可以进行调试并出结果。 有关于Jupyter Notebook的更多使用方法，可以在网上搜索相关文档进行学习。","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"数据可视化","slug":"Python/数据可视化","permalink":"http://www.a2data.cn/categories/Python/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Java 集合体系","slug":"Java/JavaSE/Java-集合体系","date":"2020-05-07T15:56:08.000Z","updated":"2020-09-18T02:25:49.891Z","comments":true,"path":"posts/9618.html","link":"","permalink":"http://www.a2data.cn/posts/9618.html","excerpt":"Java集合体系","text":"Java集合体系 1、集合体系0、Collection 集合的体系结构： ​ 有不同的数据结构(数据的组织，存储方式) 学习方式： 最顶层 实现： 最底层 Collection—-&gt; List—&gt; ArrayList 常用： add 添加 clear 清空 contains 是否包含指定元素 isEmpty 是否为空 remove 删除 size 返回集合中的元素个数 toArray 返回包含此集合中所有元素的数组。(遍历数组即可) Modifier and Type Method and Description boolean add(E e) 确保此集合包含指定的元素（可选操作）。 boolean addAll(Collection c) 将指定集合中的所有元素添加到这个集合（可选操作）。 void clear() 从这个集合中移除所有的元素（可选操作）。 boolean contains(Object o) 返回 true如果集合包含指定元素。 boolean containsAll(Collection c) 返回 true如果这个集合包含指定集合的所有元素。 boolean equals(Object o) 将指定的对象与此集合进行比较，以进行相等性。 int hashCode() 返回此集合的哈希代码值。 boolean isEmpty() 返回 true如果集合不包含任何元素。 Iterator iterator() 返回此集合中的元素的迭代器。 default Stream parallelStream() 返回一个可能并行 Stream与集合的来源。 boolean remove(Object o) 从这个集合中移除指定元素的一个实例，如果它是存在的（可选操作）。 boolean removeAll(Collection c) 删除此集合中包含的所有元素（可选操作）的所有元素（可选操作）。 default boolean removeIf(Predicate filter) 删除满足给定谓词的这个集合的所有元素。 boolean retainAll(Collection c) 仅保留包含在指定集合中的这个集合中的元素（可选操作）。 int size() 返回此集合中的元素的数目。 default Spliterator spliterator() 创建此集合中的元素的 Spliterator。 default Stream stream() 返回一个序列 Stream与集合的来源。 Object[] toArray() 返回包含此集合中所有元素的数组。 T[] toArray(T[] a) 返回包含此集合中所有元素的数组；返回数组的运行时类型是指定的数组的运行时类型。 1、Iterator 集合的遍历方式： 1、toArray(),可以把集合转换成数组,然后遍历数组即可 【有序】 2、iterator(),返回迭代器对象，可以通过迭代器对象来迭代集合 next() : 返回下一个元素。 hasNext() : 判断是否有元素可以获取 注意： 迭代器是依赖于集合的，相当于集合的一个副本,但迭代器在操作的时候，如果发现和集合不一样，则抛出异常。 Exception in thread “main ” java.util.ConcurrentModificationExeption 解决方案： 使用迭代器遍历时，用迭代器本身修改。 List.listIterator() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package learn;import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;/** * * @author JackFeng * @date 2020/3/25 */public class IteratorDemo &#123; public static void main(String[] args) &#123;// method(); // 创建集合对象 Collection c = new ArrayList(); //添加元素 c.add(&quot;hello&quot;); c.add(&quot;2020&quot;); c.add(&quot;你好啊&quot;); //获取数组 使用迭代器 Iterator it = c.iterator(); while (it.hasNext())&#123; System.out.println(it.next()); &#125; &#125; private static void method() &#123; //快捷键：CTRL + ALT + M 将代码封装成方法 // 创建集合对象 Collection c = new ArrayList(); //添加元素 c.add(&quot;hello&quot;); c.add(&quot;2020&quot;); c.add(&quot;你好啊&quot;); //获取数组 Object[] objects = c.toArray(); // 遍历数组 for (int i = 0; i &lt;objects.length ; i++) &#123; System.out.println(objects[i]); &#125; &#125;&#125; 2、迭代并发修改 判断集合中是否有 “hello ” 如果有，则添加元素 “wolrd” 异常： 1Exception in thread &quot;main&quot; java.util.ConcurrentModificationException 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package learn;import java.util.*;/** * * @author JackFeng * @date 2020/3/25 */public class ListIteratorDemo &#123; public static void main(String[] args) &#123;// mothod(); //创建集合对象// Collection c = new ArrayList(); List c = new ArrayList(); // 添加元素 c.add(&quot;hello&quot;); c.add(&quot;2020您好&quot;); //迭代器遍历/* Iterator it = c.iterator(); while (it.hasNext())&#123; String s = (String) it.next(); if (s.equals(&quot;hello&quot;)) &#123; c.add(&quot;world&quot;); &#125; &#125;*/ ListIterator lit = c.listIterator(); while (lit.hasNext()) &#123; String s = (String) lit.next(); if (s.equals(&quot;hello&quot;)) &#123; // 注意 使用迭代器添加，不可使用集合添加，迭代器就会同步集合 lit.add(&quot;world&quot;); &#125; &#125; System.out.println(c); &#125; private static void mothod() &#123; //创建集合对象 Collection c = new ArrayList(); // 添加元素 c.add(&quot;hello&quot;); c.add(&quot;2020您好&quot;); if (c.contains(&quot;hello&quot;))&#123; c.add(&quot;world&quot;); &#125; System.out.println(c); &#125;&#125; 3、泛型 泛型：是一种广泛的类型 优点： 避免类型转换的问题 减少黄色警告线 简化代码书写 什么情况使用泛型—— ** ** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package learn;import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;/** * * @author JackFeng * @date 2020/3/25 */public class GenericDemo &#123; public static void main(String[] args) &#123; // 创建集合对象// Collection c = new ArrayList(); Collection&lt;Student&gt; c = new ArrayList&lt;Student&gt;(); //创建元素对象 Student s = new Student(&quot;Jack&quot;, 22); Student s1 = new Student(&quot;Jack1&quot;, 25); // 添加元素 c.add(s); c.add(s1); //遍历集合对象// Iterator ir = c.iterator(); Iterator&lt;Student&gt; ir = c.iterator(); while (ir.hasNext()) &#123; // 转换出错// Exception in thread &quot;main&quot; java.lang.ClassCastException: learn.Student cannot be cast to java.lang.String// String str = (String) ir.next();// System.out.println(str); Student stu = ir.next(); System.out.println(stu.name); &#125; &#125;&#125;class Student&#123; String name; int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 4、foreache 增强for循环，一般用于遍历集合或者数组 格式： for（元素的类型 变量： 集合或者数组对象) { 可以使用变量； } 123456789101112131415161718192021222324252627282930313233343536373839404142434445package learn;import java.util.ArrayList;import java.util.Collection;/** * * @author JackFeng * @date 2020/3/25 */public class ForEachDemo &#123; public static void main(String[] args) &#123; //创建集合对象// Collection c = new ArrayList(); Collection&lt;String&gt; c = new ArrayList&lt;String&gt;(); //添加集合元素 c.add(&quot;hello&quot;); c.add(&quot;20200325&quot;); //增强for循环/* for (Object obj:c ) &#123; System.out.println(obj); &#125;*/ for (String string:c ) &#123; // 在增强for循环中不可修改集合 否则会出现 并发修改错误// c.add(&quot;123&quot;); System.out.println(string.toUpperCase()); &#125; &#125;&#125; 2、数据结构0、数组 数组： int [] arr = { 11,12,13,14}; 查找快，增删慢 1、链表 链表： 由链子连接起来的一堆结点 结点： 地址值，值，下一个结点地址值 获取x结点 方式： 遍历查找 x结点的后边添加新的结点： x结点的下一个结点地址值修改为新的地址值，把新结点的下一个地址值改为 x+1 查询慢，增删快 2、栈&amp;队列 栈：先进后出 堆：先进先出 3、集合List 序列： 指哪插哪 特点： 有序（存储和读取顺序一样） 整数索引 允许重复的 功能： 增 add(int index, E element) —– 在指定索引位置添加指定元素 删 remove(int index) —– 删除指定元素并返回 改 set(int index, E element) —- 将指定索引位置的元素替换为指定元素，并将原来的元素返回。 查 get(int index) —– 根据索引返回元素(防止越界(不存在)) 常用子类 ArrayList： 底层是数组结构，查询快，增删慢 LinkedList: 底层结构是链表，查询慢，增删快 常用 void addLast getFirst getLast removeFirst removeLast Modifier and Type Method and Description boolean add(E e) 将指定的元素列表的结束。 void add(int index, E element) 在列表中指定的位置上插入指定的元素。 boolean addAll(Collection c) 追加指定集合的所有元素到这个列表的末尾，按他们的指定集合的迭代器返回。 boolean addAll(int index, Collection c) 将指定集合中的所有元素插入到该列表中，从指定位置开始。 void addFirst(E e) 在此列表的开始处插入指定的元素。 void addLast(E e) 将指定的元素列表的结束。 void clear() 从这个列表中移除所有的元素。 Object clone() 返回该 LinkedList浅拷贝。 boolean contains(Object o) 返回 true如果这个列表包含指定元素。 Iterator descendingIterator() 返回在反向顺序在deque容器元素的迭代器。 E element() 检索，但不删除，此列表的头（第一个元素）。 E get(int index) 返回此列表中指定位置的元素。 E getFirst() 返回此列表中的第一个元素。 E getLast() 返回此列表中的最后一个元素。 int indexOf(Object o) 返回此列表中指定元素的第一个出现的索引，或-如果此列表不包含元素，或- 1。 int lastIndexOf(Object o) 返回此列表中指定元素的最后一个发生的索引，或-如果此列表不包含元素，或- 1。 ListIterator listIterator(int index) 返回此列表中元素的列表迭代器（在适当的顺序），从列表中的指定位置开始。 boolean offer(E e) 将指定的元素添加到列表的尾部（最后一个元素）。 boolean offerFirst(E e) 在列表的前面插入指定的元素。 boolean offerLast(E e) 在列表的结尾插入指定的元素。 E peek() 检索，但不删除，此列表的头（第一个元素）。 E peekFirst() 检索，但不删除该列表的第一个元素，或返回 null如果这个列表是空的。 E peekLast() 检索，但不删除该列表的最后一个元素，或返回 null如果这个列表是空的。 E poll() 检索并删除此列表的头（第一个元素）。 E pollFirst() 检索并移除此列表的第一个元素，或返回 null如果这个列表是空的。 E pollLast() 检索并移除此列表的最后一个元素，或返回 null如果这个列表是空的。 E pop() 从这个列表所表示的堆栈中弹出一个元素。 void push(E e) 将一个元素推到由该列表所表示的堆栈上。 E remove() 检索并删除此列表的头（第一个元素）。 E remove(int index) 移除此列表中指定位置的元素。 boolean remove(Object o) 从该列表中移除指定元素的第一个发生，如果它是存在的。 E removeFirst() 移除并返回此列表中的第一个元素。 boolean removeFirstOccurrence(Object o) 删除此列表中指定元素的第一个出现（当遍历从头到尾的列表）。 E removeLast() 移除并返回此列表中的最后一个元素。 boolean removeLastOccurrence(Object o) 删除此列表中指定元素的最后一次（当遍历从头到尾的列表时）。 E set(int index, E element) 用指定元素替换此列表中指定位置的元素。 int size() 返回此列表中元素的数目。 Spliterator spliterator() 创建一个后期绑定和快速失败 Spliterator超过此列表中的元素。 Object[] toArray() 返回一个数组，包含在这个列表中的所有元素在适当的顺序（从第一个到最后一个元素）。 T[] toArray(T[] a) 返回一个数组，包含在这个列表中的所有元素在适当的顺序（从第一到最后一个元素）；返回数组的运行时类型是指定的数组的运行时类型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package learn;import java.util.ArrayList;import java.util.List;/** * * @author JackFeng * @date 2020/3/26 *//** 定义一个方法，返回指定列表中指定元素的索引位置*** 升级* */public class ListedListDemo &#123; public static void main(String[] args) &#123; List list = new ArrayList(); list.add(&quot;hello&quot;); list.add(&quot;A2Data&quot;); list.add(&quot;scala&quot;); int index = index(list, &quot;python&quot;); System.out.println(index); boolean flag = contains(list, &quot;scala&quot;); System.out.println(flag); boolean flag1 = list.contains(&quot;java&quot;); System.out.println(flag1); &#125; public static int index(List list, Object object) &#123; // 索引遍历方式 for (int i = 0; i &lt;list.size() ; i++) &#123; // 获取列表中的元素 Object o = list.get(i); // 判断列表中的元素和指定元素是否相等 // 如果使用 == 是拿地址值去比较的 if (o.equals(object))&#123; return i; &#125; &#125; // 查找不到指定元素 return -1; &#125; public static boolean contains(List list, Object o) &#123; // 获取指定元素在指定列表中的索引位置 int index = index(list, o); // 判断是否村子 if (index &gt;= 0) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; 4、集合Set 特点： 无序（存储和读取顺序有可能不一样） 不允许重复（要求元素唯一） 没有索引 HashSet的add() 方法流程： 首先会使用当前集合中的每一个元素和新添加的元素进行hash值比较 如果hash值不同，则直接添加新的元素 如果hash值相同，比较地址值，或使用 equals方法进行比较 比较结果一样，则认为是重复不添加 所有结果都不一样则添加 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package learn;import java.util.HashSet;import java.util.Iterator;/** * Created by JackFeng on 2020/3/26. *//**使用HashSet存储字符串 并且遍历** */public class HashSetDemo &#123; public static void main(String[] args) &#123; // 创建集合对象// HashSet&lt;String&gt; hs = new HashSet&lt;&gt;(); HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); //添加元素对象 set.add(&quot;hello&quot;); set.add(&quot;2020&quot;); set.add(&quot;您好啊&quot;); //遍历集合// mothod(set);// method1(set);// method2(set); &#125; private static void method2(HashSet&lt;String&gt; set) &#123; //增强for for (String s:set ) &#123; System.out.println(s); &#125; &#125; private static void method1(HashSet&lt;String&gt; set) &#123; //迭代器 Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()) &#123; String s = it.next(); System.out.println(s); &#125; &#125; private static void mothod(HashSet&lt;String&gt; set) &#123; //数组 Object[] objects = set.toArray(); for (int i = 0; i &lt;objects.length ; i++) &#123; System.out.println(objects[i]); &#125; &#125;&#125; HashSet方法优化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package learn;import java.util.HashSet;import java.util.Objects;/** * * @author JackFeng * @date 2020/3/26 */public class HashSetDemoTo &#123; public static void main(String[] args) &#123; //创建集合对象 HashSet&lt;Students&gt; hs = new HashSet&lt;Students&gt;(); //创建元素对象 Students s = new Students(&quot;JackFeng&quot;, 22); Students s1 = new Students(&quot;JackFeng&quot;, 22); Students s2 = new Students(&quot;Jack&quot;, 25); //添加元素 hs.add(s); hs.add(s1); hs.add(s2); //遍历集合对象 for (Students students:hs ) &#123; System.out.println(students); &#125; &#125;&#125;class Students&#123; String name; int age; public Students(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Students&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Students students = (Students) o; return age == students.age &amp;&amp; Objects.equals(name, students.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; Collections 面试题：Collection和collections 有何区别？ collection 是集合体系的最顶层，包含了集合体系的共性 collections 是一个工具类，方法都是用于操作collection 常用方法： binarySearch ——- 二分查找(元素有序) copy —— 源列表覆盖目标列表（目标》=源列表） fill —— 使用指定的对象填充指定列表的所有元素 reverse —– 反转 shuffle —– 随机置换 sort —– 排序 （自然顺序排序） swap —- 指定列表中的两个索引位置互换 Modifier and Type Method and Description static boolean addAll(Collection c, T... elements) 将所有指定的元素添加到指定的集合中。 static Queue asLifoQueue(Deque deque) 返回一个 Deque视图为后进先出（LIFO） Queue。 static int binarySearch(List&gt; list, T key) 使用二进制搜索算法搜索指定对象的指定列表。 static int binarySearch(List list, T key, Comparator c) 使用二进制搜索算法搜索指定对象的指定列表。 static Collection checkedCollection(Collection c, 类 type) 返回一个指定集合的动态类型安全的观点。 static List checkedList(List list, 类 type) 返回一个动态类型安全的查看指定的列表。 static Map checkedMap(Map m, 类 keyType, 类 valueType) 返回一个动态类型安全的查看指定的Map。 static NavigableMap checkedNavigableMap(NavigableMap m, 类 keyType, 类 valueType) 返回一个动态类型安全的查看指定的导航电子Map。 static NavigableSet checkedNavigableSet(NavigableSet s, 类 type) 返回一个动态类型安全的集合视图指定通航。 static Queue checkedQueue(Queue queue, 类 type) 返回一个动态类型安全的查看指定队列。 static Set checkedSet(Set s, 类 type) 返回一个指定的动态类型安全的观点。 static SortedMap checkedSortedMap(SortedMap m, 类 keyType, 类 valueType) 返回一个动态类型安全的查看指定的排序图。 static SortedSet checkedSortedSet(SortedSet s, 类 type) 返回一个动态类型安全的查看指定的排序设置。 static void copy(List dest, List src) 将所有的元素从一个列表复制到另一个列表中。 static boolean disjoint(Collection c1, Collection c2) 返回 true如果两个指定集合没有共同的元素。 static Enumeration emptyEnumeration() 返回一个没有元素的枚举。 static Iterator emptyIterator() 返回一个没有元素的迭代器。 static List emptyList() 返回一个空列表（不可变）。 static ListIterator emptyListIterator() 返回一个没有元素的列表迭代器。 static Map emptyMap() 返回一个空Map（不可变）。 static NavigableMap emptyNavigableMap() 返回一个空的导航Map（不可变）。 static NavigableSet emptyNavigableSet() 返回一个空的导航集（不可变）。 static Set emptySet() 返回一个空集（不可变）。 static SortedMap emptySortedMap() 返回一个空的排序映射（不可变）。 static SortedSet emptySortedSet() 返回一个空的排序集（不可变）。 static Enumeration enumeration(Collection c) 返回指定集合的枚举数。 static void fill(List list, T obj) 用指定元素替换指定列表的所有元素。 static int frequency(Collection c, Object o) 返回指定集合中等于指定对象的元素的数目。 static int indexOfSubList(List source, List target) 返回指定的源列表中指定的目标列表的第一个发生的起始位置，或-如果没有这样的发生，则- 1。 static int lastIndexOfSubList(List source, List target) 返回指定的源列表中指定的目标列表的最后一个发生的起始位置，或-如果没有这样的发生，则- 1。 static ArrayList list(Enumeration e) 返回一个数组列表，该列表包含在返回的顺序中由枚举返回的元素的元素。 static &gt;T max(Collection coll) 返回最大元素的集合，根据其元素的自然排序。 static T max(Collection coll, Comparator comp) 返回给定集合的最大元素，根据指定的比较器诱导的顺序。 static &gt;T min(Collection coll) 返回最小的元素的集合，根据其元素的自然排序。 static T min(Collection coll, Comparator comp) 返回给定集合的最小元素，根据指定的比较器诱导的顺序。 static List nCopies(int n, T o) 返回一个不可变列表包含指定对象的 n副本。 static Set newSetFromMap(Map map) 返回一个由指定的映射支持的集合。 static boolean replaceAll(List list, T oldVal, T newVal) 将列表中的某一特定值的所有出现替换为另一个。 static void reverse(List list) 反转指定列表中元素的顺序。 static Comparator reverseOrder() 返回一个比较器，对一系列的实施 Comparable界面对象的自然顺序相反。 static Comparator reverseOrder(Comparator cmp) 返回一个对指定比较器的反向排序的比较器。 static void rotate(List list, int distance) 按指定的距离旋转指定列表中的元素。 static void shuffle(List list) 随机置换指定列表使用随机默认源。 static void shuffle(List list, Random rnd) 随机排列指定列表使用指定的随机源。 static Set singleton(T o) 返回只包含指定对象的不可改变的集合。 static List singletonList(T o) 返回只包含指定对象的不可改变的列表。 static Map singletonMap(K key, V value) 返回一个不可改变的Map，只将指定的指定的键映射到指定的值。 static &gt;void sort(List list) 指定列表为升序排序，根据其元素的 natural ordering。 static void sort(List list, Comparator c) 根据指定的比较器指定的顺序对指定的列表进行排序。 static void swap(List list, int i, int j) 在指定的列表中的指定位置上交换元素。 static Collection synchronizedCollection(Collection c) 返回由指定集合支持的同步（线程安全）集合。 static List synchronizedList(List list) 返回由指定列表支持的同步（线程安全）列表。 static Map synchronizedMap(Map m) 返回由指定的Map支持的同步（线程安全）Map。 static NavigableMap synchronizedNavigableMap(NavigableMap m) 返回指定的导航Map支持的同步（线程安全）导航Map。 static NavigableSet synchronizedNavigableSet(NavigableSet s) 返回由指定的导航集支持的同步（线程安全）导航集。 static Set synchronizedSet(Set s) 返回一个由指定集合支持的同步（线程安全）集。 static SortedMap synchronizedSortedMap(SortedMap m) 返回一个由指定的排序映射支持的同步（线程安全）排序的Map。 static SortedSet synchronizedSortedSet(SortedSet s) 返回一个由指定的排序集支持的同步（线程安全）排序集。 static Collection unmodifiableCollection(Collection c) 返回指定集合的一个不可修改的视图。 static List unmodifiableList(List list) 返回指定列表中的一个不可修改的视图。 static Map unmodifiableMap(Map m) 返回指定映射的一个不可修改的视图。 static NavigableMap unmodifiableNavigableMap(NavigableMap m) 返回指定的导航电子Map的一个不可修改的视图。 static NavigableSet unmodifiableNavigableSet(NavigableSet s) 返回指定通航设置不可修改的视图。 static Set unmodifiableSet(Set s) 返回指定的设置不可修改的视图。 static SortedMap unmodifiableSortedMap(SortedMap m) 返回指定的排序图上一个不可修改的视图。 static SortedSet unmodifiableSortedSet(SortedSet s) 返回指定的排序设置不可修改的视图。 模拟斗地主发牌12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package learn;import java.util.ArrayList;import java.util.Collections;/** * Created by JackFeng on 2020/3/26. *//*** 模拟斗地主发牌* */public class CollectionsTest &#123; public static void main(String[] args) &#123; //创作扑克牌 //花色 String[] color = &#123;&quot;黑桃&quot;, &quot;红桃&quot;, &quot;梅花&quot;, &quot;方片&quot;&#125;; //数字 String[] nums = &#123;&quot;A&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;&#125;; //牌盒 ArrayList&lt;String&gt; box = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt;color.length ; i++) &#123; // 得到每一个花色的牌 for (int j = 0; j &lt;nums.length ; j++) &#123; // 得到每一个数字 box.add(color[i] + nums[j]); &#125; &#125; box.add(&quot;大王&quot;); box.add(&quot;小王&quot;);// System.out.println(box.size()); // 洗牌 使用置换方法 Collections.shuffle(box);// System.out.println(box); // 牌友分牌 54-3 /3 = 17张 3张底牌 ArrayList&lt;String&gt; A = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; B = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; C = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt;box.size() -3; i++) &#123; /* * i = 0; i % 3 = 0; * i = 1; i % 3 = 1; * i = 2; i % 3 = 2; * */ if (i % 3 == 0) &#123; A.add(box.get(i)); &#125; else if (i % 3 == 1) &#123; B.add(box.get(i)); &#125; else if (i % 3 == 2) &#123; C.add(box.get(i)); &#125; &#125; System.out.println(A); //底牌 for (int i = box.size()-3; i &lt; box.size() ; i++) &#123; System.out.println(box.get(i)); &#125; System.out.println(); &#125;&#125; 5、集合MapInterface Map&lt;K,V&gt; 参数类型 K -钥匙的Map保持型 V -映射的值的类型 public interface Map&lt;K,V&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122 映射键到值的对象。一张Map不能包含重复的键，每个键可以映射到至多一个值。 Map 和 Collection 的区别?- Map: 双列集合,常用于处理有对应关系的数据，key是不可以重复的- Collection： 单列集合，collection有不同的子体系，有的允许重复有索引有序，有的不允许重复且无序。Map常用功能：- 映射功能 - &#96;put&#96; key映射到value,若key存在，则覆盖value，并且返回原来的value；不存在则返回为null- 获取功能 - &#96;get&#96; 根据指定的key 返回对应的value - &#96;Set&#96; 获取所有的Key - &#96;Collection values&#96; 获取所有的Value - &#96;size&#96; 返回对应关系的个数- 删除功能 - &#96;clear&#96; 清空所有对应关系 - &#96;remove&#96; 根据指定的key删除对应关系，并返回对应的value值，如果没有删除成功，返回null- 判断功能 - &#96;containsKey&#96; 判断指定的key是否存在，存在返回True 否则返回False - &#96;containsValue&#96; 判断指定的value是否存在 - &#96;isEmpty&#96; 判断是否有对应关系- 遍历功能： - &#96;Set&#96;| Modifier and Type | Method and Description || ----------------- | ------------------------------------------------------------ || &#96;void&#96; | &#96;clear()&#96; 从这个映射中移除所有的映射（可选操作）。 || &#96;default V&#96; | &#96;compute(K key, BiFunction remappingFunction)&#96; 试图计算出指定键和当前的映射值的映射（或 &#96;null&#96;如果没有当前映射）。 || &#96;default V&#96; | &#96;computeIfAbsent(K key, Function mappingFunction)&#96; 如果指定的键是不是已经与价值相关的（或映射到 &#96;null&#96;），尝试使用给定的映射功能，进入到这个Map除非 &#96;null&#96;计算其价值。 || &#96;default V&#96; | &#96;computeIfPresent(K key, BiFunction remappingFunction)&#96; 如果指定键的值是存在和非空的，尝试计算一个新的映射，给出了键和它当前的映射值。 || &#96;boolean&#96; | &#96;containsKey(Object key)&#96; 返回 &#96;true&#96;如果这Map包含一个指定的键映射。 || &#96;boolean&#96; | &#96;containsValue(Object value)&#96; 返回 &#96;true&#96;如果映射到指定的值的一个或多个键。 || &#96;Set&gt;&#96; | &#96;entrySet()&#96; 返回一个 [&#96;Set&#96;](..&#x2F;..&#x2F;java&#x2F;util&#x2F;Set.html)视图的映射包含在这个Map。 || &#96;boolean&#96; | &#96;equals(Object o)&#96; 将指定的对象与此映射的相等性进行比较。 || &#96;default void&#96; | &#96;forEach(BiConsumer action)&#96; 在该映射中的每个条目执行给定的操作，直到所有的条目被处理或操作抛出异常。 || &#96;V&#96; | &#96;get(Object key)&#96; 返回指定的键映射的值，或 &#96;null&#96;如果这个Map不包含的键映射。 || &#96;default V&#96; | &#96;getOrDefault(Object key, V defaultValue)&#96; 返回指定的键映射的值，或 &#96;defaultValue&#96;如果这个Map不包含的键映射。 || &#96;int&#96; | &#96;hashCode()&#96; 返回此映射的哈希代码值。 || &#96;boolean&#96; | &#96;isEmpty()&#96; 返回 &#96;true&#96;如果这个Map不包含键值的映射。 || &#96;Set&#96; | &#96;keySet()&#96; 返回一个 [&#96;Set&#96;](..&#x2F;..&#x2F;java&#x2F;util&#x2F;Set.html)的关键视图包含在这个Map。 || &#96;default V&#96; | &#96;merge(K key, V value, BiFunction remappingFunction)&#96; 如果指定的键已与值相关联的值或与空值相关联的，则将其与给定的非空值关联。 || &#96;V&#96; | &#96;put(K key, V value)&#96; 将指定的值与此映射中的指定键关联（可选操作）。 || &#96;void&#96; | &#96;putAll(Map m)&#96; 从指定的映射到这个Map（可选操作）复制所有的映射。 || &#96;default V&#96; | &#96;putIfAbsent(K key, V value)&#96; 如果指定的键是不是已经与价值相关的（或映射到 &#96;null&#96;）将其与给定的值并返回 &#96;null&#96;，否则返回当前值。 || &#96;V&#96; | &#96;remove(Object key)&#96; 如果存在（可选操作），则从该Map中移除一个键的映射。 || &#96;default boolean&#96; | &#96;remove(Object key, Object value)&#96; 仅当它当前映射到指定的值时，为指定的键移除条目。 || &#96;default V&#96; | &#96;replace(K key, V value)&#96; 仅当它当前映射到某一值时，替换指定的键的条目。 || &#96;default boolean&#96; | &#96;replace(K key, V oldValue, V newValue)&#96; 仅当当前映射到指定的值时，替换指定的键的条目。 || &#96;default void&#96; | &#96;replaceAll(BiFunction function)&#96; 将每个条目的值替换为在该项上调用给定函数的结果，直到所有的条目都被处理或函数抛出异常。 || &#96;int&#96; | &#96;size()&#96; 返回这个映射中的键值映射的数目。 || &#96;Collection&#96; | &#96;values()&#96; 返回一个 [&#96;Collection&#96;](..&#x2F;..&#x2F;java&#x2F;util&#x2F;Collection.html)视图的值包含在这个Map。 |## Tips方法实例&#96;&#96;&#96;javapackage learn;import java.util.Collection;import java.util.HashMap;import java.util.Set;&#x2F;**** @author JackFeng* @date 2020&#x2F;3&#x2F;27*&#x2F;public class MapDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建Map对象 HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;(); &#x2F;&#x2F; put 映射关系 System.out.println(map.put(&quot;001&quot;, &quot;Jack&quot;)); &#x2F;&#x2F; 输出为null System.out.println(map.put(&quot;002&quot;, &quot;Jack Jie&quot;)); &#x2F;&#x2F; 输出为null System.out.println(map.put(&quot;001&quot;, &quot;Jack Feng&quot;)); &#x2F;&#x2F; 输出为Jack System.out.println(map); &#x2F;&#x2F;&#123;001&#x3D;Jack Feng&#125; &#x2F;&#x2F;&#96;containsKey&#96; System.out.println(map.containsKey(&quot;001&quot;)); &#x2F;&#x2F;containsValue System.out.println(map.containsValue(&quot;Jack Feng&quot;)); &#x2F;&#x2F; clear()&#x2F;&#x2F; map.clear(); &#x2F;&#x2F;isEmpty&#x2F;&#x2F; System.out.println(map.isEmpty());&#x2F;&#x2F; method(map); &#x2F;&#x2F; Collection Collection&lt;String&gt; values &#x3D; map.values(); for (String key:values ) &#123; System.out.println(key); &#125; &#125; private static void method(HashMap&lt;String, String&gt; map) &#123; &#x2F;&#x2F;set 不允许重复 Set&lt;String&gt; keys&#x3D; map.keySet(); for (String key:keys ) &#123; System.out.println(key); &#125; &#125;&#125; Map遍历 遍历方式： A(比较繁琐)： 获取所有的key，遍历得到每一个key，让每个key去找对应的value B： entrySet() 使用HashMap存储数据（可以自定义对象作为Key） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package learn;import java.util.HashMap;import java.util.Map;import java.util.Set;/** * * @author JackFeng * @date 2020/3/27 */public class MapTest &#123; public static void main(String[] args) &#123; // 创建map对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // 映射关系 map.put(&quot;001&quot;, &quot;A&quot;); map.put(&quot;002&quot;, &quot;B&quot;); map.put(&quot;003&quot;, &quot;a2data.cn&quot;); // 第一种遍历方式 // 方式1 获取所有的key 用过key 来获取value method(map); // 第二种遍历方式 System.out.println(&quot;第二种遍历方式&quot;); Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet(); // 遍历集合 // 需要用map 去修饰 Ectry ，因为是map的内部类 // 方式2 获取entry对象 ，通过entry 对象来获取 key value for (Map.Entry&lt;String, String&gt; entry:entries ) &#123; // 获取 key value String key = entry.getKey(); String value = entry.getValue(); System.out.println(&quot;key:&quot;+key + &quot;-----&quot; + &quot;value:&quot;+value); &#125; &#125; private static void method(HashMap&lt;String, String&gt; map) &#123; System.out.println(&quot;第一种遍历方式&quot;); // 召集所有key Set&lt;String&gt; keys = map.keySet(); //遍历map对象 for (String key:keys ) &#123; // 每个key 找到value String value = map.get(key); System.out.println(&quot;key:&quot;+key + &quot;-----&quot; + &quot;value:&quot;+value); &#125; &#125;&#125; Key：自定义对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package learn;import java.util.HashMap;import java.util.Map;import java.util.Objects;import java.util.Set;/** * * @author JackFeng * @date 2020/3/27 */public class HashMapTest &#123; public static void main(String[] args) &#123; // 创建Map对象 HashMap&lt;Message, String&gt; hashMap = new HashMap&lt;Message,String&gt;(); // 创建Key对象 Message ms = new Message(&quot;未读消息&quot;,12); Message ms1 = new Message(&quot;已读消息&quot;,22); Message ms2 = new Message(&quot;已读消息&quot;,22); // 如果想要这个不添加 重写 hashcode 和 equals // 添加映射关系 hashMap.put(ms, &quot;001&quot;); hashMap.put(ms1, &quot;002&quot;); hashMap.put(ms2, &quot;002&quot;); // 遍历 我们使用 Entry 使用entrySet Set&lt;Map.Entry&lt;Message, String&gt;&gt; entrys = hashMap.entrySet(); for (Map.Entry&lt;Message, String&gt; entry:entrys ) &#123; Message key = entry.getKey(); String value = entry.getValue(); System.out.println( key + value ); // 发现输出是如下 是因为少写了 toString 方法 //learn.Message@74a14482002 //learn.Message@4554617c001 &#125; &#125;&#125;class Message&#123; String name; int nums; public Message(String name, int nums) &#123; this.name = name; this.nums = nums; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getNums() &#123; return nums; &#125; public void setNums(int nums) &#123; this.nums = nums; &#125; // 解决输出 是地址值 @Override public String toString() &#123; return &quot;Message&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, nums=&quot; + nums + &#x27;&#125;&#x27;; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Message message = (Message) o; return nums == message.nums &amp;&amp; Objects.equals(name, message.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, nums); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"}]},{"title":"Java 常用API-II","slug":"Java/JavaSE/Java-常用API-II","date":"2020-05-07T15:55:37.000Z","updated":"2020-09-18T02:25:54.222Z","comments":true,"path":"posts/2834.html","link":"","permalink":"http://www.a2data.cn/posts/2834.html","excerpt":"JavaAPP-II","text":"JavaAPP-II 5、API-II5.0、常用类1、Object String toString() : 返回对象得字符串表示 ​ return getClass().getName() + “@” +Integer.toHexString(hashCode()) getClass(): 返回一个字节码对象 Integer.toHexString(): 返回指定参数的十六进制字符串形式 **hashCode():**返回该对象的哈希码值（内存地址） 12345678910111213141516171819202122232425262728293031323334353637383940414243package api;/** * * @author JackFeng * @date 2020/3/24 */public class ObjectDemo &#123; public static void main(String[] args) throws ClassNotFoundException &#123; // 获取对象字节码的方式 ----- 应用层 反射 //方式1 通过Object类的getClass()方法获取 Teacher t = new Teacher(); Class clazz = t.getClass(); System.out.println(clazz); //方式2 通过类名调用熟悉class来获取 Class&lt;Teacher&gt; clazz1 = Teacher.class; // 方式3 通过class类的静态方法 forName() 来获取 此时需要跑异常，例如输入错误 Class clazz2 = Class.forName(&quot;api.Teacher&quot;); // true System.out.println(clazz == clazz1); // true System.out.println(clazz1 == clazz2); &#125;&#125; 2、Object-equals == : 比较两个对象是否相等 i基本类型比值，引用类型比地址值。（需要重写） 12345678@Overridepublic boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name);&#125; 3、System Modifier and Type Method and Description static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 从指定的源数组中复制一个数组，开始在指定的位置，到目标数组的指定位置。 复制数组： 1、源数组 2、源数组的起始索引位置 3、目标数组 4、目标数组的起始索引位置 5、指定接受的元素个数 currentTimeMillis() 返回当前时间以毫秒为单位。 gc() 运行垃圾收集器。 exit(int status) 终止当前正在运行的java虚拟机。 4、Date java.util.Date 根据“指定时间” 创建Date对象 常用方法： 毫秒值 —- Date 返回值 void ，参数Long 获取 —-Date 返回值long 无参数 getTime setTime Date(long date) 分配一个 Date对象并将它初始化为代表指定的毫秒数自基准时间被称为“时代”，即1970年1月1日，00:00:00 GMT。 5、SimpleDateFormat DataFormat 解析日期或时间 SimpleDateFormat是格式和语言环境敏感的方式解析一个类的具体日期。可以格式化（日期→文本），分析（文本→日期），和归一化。 String format(Date date) 将日期格式化为日期/时间字符串。 2020-03-25 2020年3月25日 SimpleDateFormat() 使用默认的 FORMAT现场默认模式和日期格式的符号构建了一个 SimpleDateFormat。 SimpleDateFormat(String pattern) 使用给定的模式和默认的日期格式符号默认 FORMAT现场构建了一个 SimpleDateFormat。 12345678910111213141516171819202122232425262728293031package learn;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/** * * @author JackFeng * @date 2020/3/25 */public class SimpleDateFormatDemo &#123; public static void main(String[] args) throws ParseException &#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;); //格式化 Date date = new Date(); String s = sdf.format(date); // 2020年03月25日 System.out.println(s); //解析 Date d = sdf.parse(&quot;2020年3月25日&quot;); System.out.println(d.toLocaleString()); &#125;&#125; 6、Calendar 日历，提供操作年月日时的方法。 获取，月是 从 0开始。 所以 一般情况下 要 +1 12int month = c.get(Calendar.MONTH) +1 7、包装类 包装类：封装了基本数据类型的类，Java 为我们提供了更多复杂的方法和一些变量 7.1 String 转IntInterger 1、int intValue（） 2、static int parseInt( String s) 7.2 Int 转 StringString 1、 + “ ” 2、 String toString() —- 无参 3、 static toString() 类似 8、自动装箱和拆箱123456789101112131415161718192021222324252627282930313233343536373839package learn;import java.util.ArrayList;/** * * @author JackFeng * @date 2020/3/25 */public class IntegerDemo &#123; public static void main(String[] args) &#123; // 自动装箱 // 相当于 Integer i = new Integer(10); Integer i1 = 10; // 自动拆箱 // 相当于 int a = i.intValue(); Integer i2 = 10; int a = i2; // Integer i3 = new Integer(i1.intValue() + i2.intValue()); Integer i3 = i1 + i2; // 应用场景 ArrayList arrayList = new ArrayList(); // 自动装箱 ,arrayList.add(new Integer(1)) arrayList.add(1); &#125;&#125; 5.1、正则表达式 正则表达式： ​ 规则规范，用于匹配字符串 boolean matcher( String regex) ：判断当前字符串是否匹配指定的正则表达式。 常用正则表达式字符 一、校验数字的表达式 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$ 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]$ 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\\d$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0$ 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d*[1-9]\\d*))|0?.0+|0$ 正浮点数：^[1-9]\\d.\\d|0.\\d*[1-9]\\d*$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 负浮点数：^-([1-9]\\d.\\d|0.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0)$ 二、校验字符的表达式 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$&quot;等字符：[^%&amp;’,;=?$\\x22]+ 禁止输入含有的字符：[^\\x22]+ 三、特殊需求表达式 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+).\\w+([-.]\\w+)$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]&gt;.?&lt;/\\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用) IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 校验QQ号： 必须0-15 位 不能以0 开头 必须是数字 123456789101112131415161718192021222324package learn;/** * * @author JackFeng * @date 2020/3/25 */public class RegexDemo &#123; public static void main(String[] args) &#123; String qq = &quot;66860619&quot;; boolean matches = qq.matches(&quot;[1-9][0-9]&#123;4,14&#125;&quot;); System.out.println(matches); String a1 = &quot;00001&quot;; boolean matches1 = a1.matches(&quot;[1-9][0-9]&#123;4,14&#125;&quot;); System.out.println(matches1); &#125;&#125; 正则判断元音 aeiou AEIOU 123456public static boolean check(String s)&#123; // 转换成小写 s = s.toLowerCase(); return s.matches(&quot;\\\\w[aeiou]\\\\w&quot;);&#125; Split12345678910111213141516171819202122232425262728293031323334353637package learn;/** * * @author JackFeng * @date 2020/3/25 */public class SplitDemo &#123; public static void main(String[] args) &#123; String s = &quot; -1 2 22 123 88&quot;; System.out.println(&quot;正常分割&quot;); String[] arr = s.split(&quot; &quot;); print(arr); // 正则分割 String[] arr1 = s.split(&quot; +&quot;); System.out.println(&quot;正则分割&quot;); print(arr1); &#125; public static void print(String[] arr)&#123; for (int i = 0; i &lt;arr.length ; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"}]},{"title":"Java面向对象 (继承、多态)","slug":"Java/JavaSE/Java面向对象-继承、多态","date":"2020-05-07T15:55:15.000Z","updated":"2020-09-18T02:25:45.771Z","comments":true,"path":"posts/43249.html","link":"","permalink":"http://www.a2data.cn/posts/43249.html","excerpt":"Java面向对象 继承 多态","text":"Java面向对象 继承 多态 面向对象 (继承、多态)1、static静态 static（静态） 关键字 用于修饰成员变量和成员方法 特点： 被所有的对象所共享 可以使用类名调用 静态加载优先于对象 随着类的加载而加载 注意事项： 静态方法只能访问静态成员 非静态方法既可以访问静态也可以访问非静态 非静态方法中不可以定义静态变量 静态方法中不可以定义this，super关键字 优缺点： 优点 对对象的共享数据提供单独的存储空间，节省空间 直接被类名调用，不用在堆内存创建对象 缺点 访问出现局限性（只能访问静态） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package one;/** * Created by JackFeng on 2020/3/8. */public class StaticDemo &#123; public static void main(String[] args) &#123; /* * Math 主要的数学运算方法 * */// static double abs ( double a) : 返回绝对值 System.out.println(Math.abs(15)); System.out.println(Math.abs(-10)); System.out.println(&quot;----------&quot;); // ceil 天花板 向上取整 System.out.println(Math.ceil(1.2)); System.out.println(Math.ceil(1.6)); System.out.println(&quot;----------&quot;); // floor 向下取整 System.out.println(Math.floor(1.2)); System.out.println(Math.floor(1.8)); System.out.println(&quot;==========&quot;); // round 四舍五入 System.out.println(Math.round(1.2)); System.out.println(Math.round(1.6)); System.out.println(&quot;---------&quot;); // max min System.out.println(Math.max(3,8)); // pow 次幂 第一个参数的第二个参数次幂 System.out.println(&quot;2 的3 次方&quot;); System.out.println(Math.pow(2,3)); // random 随机数 大于0 &lt;1 System.out.println(Math.random()); &#125;&#125; 2、代码块 写一个数据操作的工具类，取最大值，已经取数组中指定索引的值 MyArray 工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.a2data;/** * Created by JackFeng on 2020/3/13. */public class MyArrays &#123; // 数组操作 有关的工具类 ，不需要创建对象，所以 可以私有他的构造方法 private MyArrays()&#123;&#125; // 取最大值 public static int getMax(int[] arr)&#123; // 定义参照物 int max = arr[0]; for (int i = 1; i &lt;arr.length ; i++) &#123; if (max&lt;arr[i])&#123; // 替换参照物 max = arr[i]; &#125; &#125; return max; &#125; // 获取指定数组中指定元素的索引位置 public static int getIndex(int[] arr,int a)&#123; for (int i = 0; i &lt;arr.length ; i++) &#123; if (arr[i]== a) return i; &#125; return -1; &#125;&#125; MyArrayDemo 工具类使用 123456789101112131415161718192021package com.a2data;/** * Created by JackFeng on 2020/3/13. */public class MyArrayDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 3, 4, 5, 21&#125;; int max = MyArrays.getMax(arr); System.out.println(max); int index = MyArrays.getIndex(arr, 3); int index1 = MyArrays.getIndex(arr, 6); System.out.println(index); System.out.println(index1); &#125;&#125; 局部代码块： ​ 存在于方法中，控制变量的生命周期（作用域） 构造代码块： ​ 去构造方法中的共性，每次创建对象都会执行，并且在构造方法执行之前执行。 静态代码块： ​ 随着类的加载而加载，只加载一次，加载类时需要加载的驱动 3、继承 继承：Extends ​ 多个类有共同的成员变量和成员方法，抽取到另外一个类中（父类） 只能继承一个父类。 — 只有一个亲爹 只能继承父类非私有成员 支持多层继承 — 还可以有一个亲爷爷 super 与this相似，获取父类的成员和方法。 就近原则！ 方法重写： ​ 在子父类当中,子类的方法和父类的方法完全一样，子类重写了父类的方法(覆盖)。并且super 调用父类的方法即可。 注意事项： 不能重写父类私有的方法 必须大于等于父类方法的权限 注解：@ @Override 继承中构造方法的执行顺序： 子父类继承关系 创建了子类的对象，就会调用子类的构造方法 子类构造方法第一行没有调用父类构造方法，默认调用父类无参构造 肯定先执行父类方法，因为要先给父类的成员变量进行初始化，子类可能会用到。 super() 在子类构造方法的第一行中调用父类的构造方法 继承优缺点 优点： 提高代码的复用性，可维护性 缺点： 耦合性的影响。 开发原则： 高内聚低耦合 内聚：自己完成某件事的能力 耦合：类与类的关系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.a2data;/** * Created by JackFeng on 2020/3/13. */public class ExtendsDemo &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); zi.function(); &#125; static class Die &#123; int num = 11; Die()&#123; System.out.println(&quot;我是父类无参构造&quot;); &#125; public Die(int num)&#123; System.out.println(&quot;我是父类有参构造&quot;); &#125; public void method()&#123; System.out.println(&quot;我是父类的方法&quot;); &#125; &#125; static class Zi extends Die&#123; int num = 2020; Zi()&#123; this(1); // 第一行不调用子类，或者其他方法，默认调用父类 System.out.println(&quot;我是子类无参构造&quot;); &#125; Zi(int num)&#123; System.out.println(&quot;我是子类有参构造&quot;); &#125; public void method()&#123; System.out.println(&quot;我是子类的方法&quot;); &#125; void function()&#123;// this.method(); this.num = 20; &#125; &#125;&#125; this和super的区别 this和super的区别： this： 当前对象的引用 调用子类的成员变量 调用子类的成员方法 在子类的构造方法第一行调用子类其他构造方法 super ： 子类对象的父类引用 调用父类的成员变量 调用父类的成员方法 在子类的构造方法第一行调用父类的构造方法 4、匿名对象&amp;final 匿名对象：没有名字的对象 场景： ​ 当方法只是使用一次的时候，可以使用匿名对象 ​ 可以当做参数传递，但无法进行操作 注意： ​ 匿名对象可以调用成员对象，并赋值，但是并没有意义，因为只调用一次 1234567891011121314151617181920212223242526package com.a2data;/** * Created by JackFeng on 2020/3/13. */public class AnonyDemo &#123; public static void main(String[] args) &#123;// Student s = new Student();// s.study(); new Student(); // 匿名对象，没有变量名引用的对象 &#125;&#125;class Student&#123; String name; int age; public void study()&#123; System.out.println(&quot;加油提升自己&quot;); &#125;&#125; Final 修饰符： 可以用于修饰类，成员方法和成员变量 final所修饰的类，不可被继承，不能有子类 final所修饰的方法，不能被重写。 final所修饰的变量，是不可修改的，是常量 常量： 字面值常量： 1,2,3 自定义常量：被final所修饰的成员变量，一旦初始化则不可改变 注意： 自定义常量必须初始化，可以选择显示初始化或者构造初始化 5、抽象类 abstract: 关键字，用于修饰方法和类 抽象方法： ​ 不同类的方法是相似的，但是具体内容又不太一样，所以我们智能抽取它的申明，没有具体的方法体，没有具体方法体的方法就是抽象方法 抽象类： ​ 有抽象方法的类必须是抽象类 ​ 特点： 抽象方法只能在抽象类里边 抽象类和抽象方法必须被abstract修饰 抽象类不能创建对象（不能实例化） 抽象类中可以有非抽象的方法 抽象类和类的关系也是继承 抽象类的成员特点 成员变量 可以有成员变量 可以有常量 成员方法 可以有抽象方法 可以有非抽象方法 构造方法 可以有构造方法的，需要对抽象类的成员变量进行初始化 注意： ​ 一个类继承了抽象类需要重写他所有的抽象方法,否则这个类就得是抽象类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.a2data;import sun.plugin2.message.JavaReplyMessage;/** * Created by JackFeng on 2020/3/15. *//*** 普通教练，高级教练*** 共性：* 属性 姓名 年龄 性别* 行为 教学** */public class AbastractTest &#123; public static void main(String[] args) &#123; BasicTeacher bt = new BasicTeacher(); bt.name = &quot;小白教练&quot;; bt.teach(); JobTeacher jt = new JobTeacher(); jt.name = &quot;小灰教练&quot;; jt.teach(); &#125;&#125;abstract class Teacher&#123; String name; // 姓名 int age; // 年龄 String gender; public abstract void teach();&#125;class BasicTeacher extends Teacher&#123; @Override public void teach() &#123; System.out.println(name + &quot;讲基础内容&quot;); &#125;&#125;class JobTeacher extends Teacher&#123; @Override public void teach() &#123; System.out.println(name+ &quot;讲高级实战内容&quot;); &#125;&#125; 6、接口 interface: 接口是一个比抽象类还抽象的类，接口里所有的方法全是抽象方法,接口和类的关系是实现，implements 格式： interface 接口名 { ​ } 特点： 只能有抽象方法 只能有常量 只能用 publie&amp;abstract 方法 默认使用public static final 来修饰成员变量 建议 手动输入默认修饰符（public&amp;abstract），虽然不输入也会是默认的。 注意： 接口不能创建对象（不能实例化） 类与接口的关系是实现关系，一个类实现一个接口必须实现它的所有方法 类与类：继承关系，单一继承，多层继承 类与接口：实现关系，多实现 接口与接口关系： 继承关系，多层继承 接口优点： 1、类与接口的关系，实现关系，而且是多实现，一个类可以实现多个接口，类与类之间是继承关系，java中的继承是单一继承，一个类只能有一个父类，打破了继承的局限性 2、对外提供规则（统一要求，例如Use接口,充电器接口） 3、降低程序的耦合性 定义规则，模块化开发 高内聚低耦合，提高开发效率 接口和抽象类的区别： 共性： 抽取出抽象的概念 区别1：与类的关系 类与接口是实现关系，多实现 类与抽象类是继承关系，Java中的继承是单一继承，一个类只能有一个父类，java中的继承是多层继承 区别2：成员 成员变量： 抽象类可以有成员变量，也可以有常量 接口只能有常量 成员方法： 抽象类可以有抽象方法，也有非抽象方法 接口只能有抽象方法，默认修饰符 public abstract 构造方法： 抽象类有构造方法的 接口没有构造方法 接口开发的思路 分析： ​ 由下至上 不断向上抽取 实现： ​ 由上至下 先实现共性 应用： ​ 使用具体的子类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150package com.a2data;/** * Created by JackFeng on 2020/3/15. *//*** 篮球运动员和教练* 乒乓球运动员和教练* 篮球运动员和教练要出国访问，需要学习英语**** */public class InterfaceTest &#123; public static void main(String[] args) &#123; //篮球运动员对象 BasketBallPlayer bp = new BasketBallPlayer(); bp.name = &quot;姚明&quot;; bp.age = 35; bp.gender = &quot;男&quot;; bp.sleep(); bp.study(); bp.speak(); System.out.println(&quot;------------&quot;); //乒乓球教练对象 PingpangCoache pp = new PingpangCoache(); pp.name = &quot;刘教练&quot;; pp.age = 40; pp.gender = &quot;男&quot;; pp.sleep(); pp.teach();// pp.speak() &#125;&#125;class Person&#123; String name; int age; String gender; public Person() &#123; &#125; public Person(String name, int age, String gender) &#123; // 成员变量初始化 this.name = name; this.age = age; this.gender = gender; &#125; public void eat()&#123; System.out.println(&quot;吃饭&quot;); &#125; public void sleep()&#123; System.out.println(&quot;睡觉&quot;); &#125;&#125;interface SpeakEnglish &#123; public abstract void speak();&#125;// 运动员abstract class Player extends Person&#123; //学习 public abstract void study();&#125;// 教练abstract class Coach extends Person&#123; // 教 public abstract void teach();&#125;//篮球运动员class BasketBallPlayer extends Player implements SpeakEnglish&#123; @Override public void study() &#123; System.out.println(&quot;学扣篮&quot;); &#125; @Override public void speak() &#123; System.out.println(&quot;说英语&quot;); &#125;&#125;//乒乓球运动员class PingpangPlayer extends Player&#123; @Override public void study() &#123; System.out.println(&quot;学颠球&quot;); &#125;&#125;//篮球教练class BasketBallCoach extends Coach implements SpeakEnglish&#123; @Override public void teach() &#123; System.out.println(&quot;教扣篮&quot;); &#125; @Override public void speak() &#123; System.out.println(&quot;说英语&quot;); &#125;&#125;//乒乓球教练class PingpangCoache extends Coach&#123; @Override public void teach() &#123; System.out.println(&quot;教颠球&quot;); &#125;&#125; 7、多态前提 多态的前提： 子父类继承关系 方法的重写 父类引用指向子类对象 动态绑定：运行期间调用的方法，是根据具体的类型，具体的方法 优缺点： 优点： 可以提高可维护性(多态前提所保证的)，提高代码的可扩展性 缺点： 无法直接访问子类特有的成员 1234567891011121314151617181920212223242526272829303132333435363738package com.a2data;/** * Created by JackFeng on 2020/3/15. */public class PoymorphicDemo &#123; public static void main(String[] args) &#123;// Cat cat = new Cat();// cat.eat(); // 父类引用 Animal a // 指向 = // 子类对象 new Cat() // 动态绑定 Animal a = new Cat(); a.eat(); &#125;&#125;class Animal &#123; public void eat()&#123; System.out.println(&quot;c吃东西&quot;); &#125;&#125;class Cat extends Animal&#123; public void eat()&#123; System.out.println(&quot;猫吃鱼&quot;); &#125;&#125; 特点 多态的成员特点： 成员变量 编译时看的是左边，运行时看的是左边 成员方法 编译时看的是左边，运行时看的是右边 静态方法 编译时看的是左边，运行时看的是左边 编译时看的都是左边，运行时成员方法看的是右边，其他（成员变量和静态方法）看的都是左边 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.java;import java.util.Date;/** * Created by JackFeng on 2020/3/15. */public class PoymorphicDemo &#123; public static void main(String[] args) &#123; // 成员变量 // 在继承中没有被重写的概念，没有动态绑定的概念 // 执行的是父类的 Dad d = new Kid(); System.out.println(d.num); // 成员方法 // 运行看右边 System.out.println(&quot;----------&quot;); d.method(); // 静态方法 d.function(); // 使用变量去调用静态方法，相当于用变量类型的类名去调用 所以输出父类的静态方法 &#125;&#125;class Dad&#123; int num = 1; public void method()&#123; System.out.println(&quot;我是父类的方法&quot;); &#125; public static void function()&#123; System.out.println(&quot;我是父类的静态方法&quot;); &#125;&#125;class Kid extends Dad&#123; int num = 21; public void method()&#123; System.out.println(&quot;我是子类的方法&quot;); &#125; public static void function()&#123; System.out.println(&quot;我是子类的静态方法&quot;); &#125;&#125; 多态转型 多态中的向上转型和向下转型： 引用类型之间的转换 向上转型 由小到大（子类型转换成父类型) 向下转型 由大到小 基本数据类型的转换 自动类型转换 由小到大 byte short char – int — long — float – double 强制类型转换 由大到小 12345678910111213141516171819202122232425262728293031323334353637383940package com.java;/** * Created by JackFeng on 2020/3/15. */public class polymorphicDemo &#123; public static void main(String[] args) &#123; Animal a = new Dog(); // 向上转型 a.eat(); Dog d = (Dog) a; // 向下转型 本身是什么类型 转换成什么类型 d.swim(); &#125;&#125;class Animal&#123; public void eat()&#123; System.out.println(&quot;吃东西&quot;); &#125;&#125;class Dog extends Animal&#123; public void eat()&#123; System.out.println(&quot;啃骨头&quot;); &#125; public void swim()&#123; System.out.println(&quot;狗刨&quot;); &#125;&#125; 8、权限修饰符包 特点：（package） 可以由多层 不同包下的文件名可以重复 包的声明必须在第一行代码 包使用场景类的全名： 包名.类名 同包： ​ 相同包下的类可以直接访问，不需要做其他的操作 异包: ​ 1、使用类的全名 ​ 2、使用关键字import将类导入 注意： ***** 代表的是通配符，代表导入了这个包下所有的类,并没有导入子包下的类 权限修饰符 pubilc —- 访问都是对外的 当前类，相同包下不同的类，不同包下的类 default 当前类，相同包下不同的类 当前包下使用(与protected)区别 private 仅限当前类 protected — 数据保护 当前类，相同包下不同的类 让子类对象使用 9、内部类成员内部类 1、在类的成员位置，和成员变量以及成员方法所在的位置是一样的 2、在内部类当中，可以直接访问外部类的成员，包括私有成员 修饰符： 可以使用权限修饰符修饰成员内部类,但是如果使用私有来修饰，则无法在其他类中访问 可以使用static 修饰成员内部类，不用再创建外部类对象 匿名内部类： 必须在定义匿名内部类得时候创建它得对象 格式： new 类/接口(){ 继承这个类得子类对象，可以重写父类方法 实现这个类得子类对象，必须实现这个接口得所有方法 }； 原理： 创建了继承这个类得子类对象或者创建了实现这个接口得子类对象 应用场景： 作为参数传递 12345678910111213141516171819202122232425262728293031323334package com.java;/** * Created by JackFeng on 2020/3/15. */public class InnerDemo &#123; public static void main(String[] args) &#123; Outer.Inner i = new Outer().new Inner(); i.function(); &#125;&#125;class Outer&#123; private int num = 10; public void method()&#123; Inner i = new Inner(); i.function(); &#125; class Inner&#123; public void function()&#123; // 私有成员 可以i直接访问 System.out.println(num); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"}]},{"title":"Java常用API","slug":"Java/JavaSE/Java常用API","date":"2020-05-07T15:54:55.000Z","updated":"2020-09-18T02:25:51.108Z","comments":true,"path":"posts/32274.html","link":"","permalink":"http://www.a2data.cn/posts/32274.html","excerpt":"Java常用API-I","text":"Java常用API-I 常用API1、String类功能赋值 String S = “hello “ Objcet： 是类层次结构的根类，所有类都直接活间接的继承该类 判断功能 boolean equals(Object obj) —-比较字符串的内容是否相同 boolean equalsIgnoreCase(String str) —- 比较字符串内容是否相同，忽略大小写 boolean startsWith(String str) —- 判断字符串对象是否以指定的str开头 boolean endsWitn(String str) —- 判断字符串对象是否以指定的str结尾 获取功能 int length() —- 获取字符串的长度 char charAt(int index) —- 获取指定索引处的字符 int indexOf(String str) —- 获取str 在字符串对象中第一次出现的索引 String substring(int start) —- 从start开始截取字符串 String substring(int start,int end) — 从s-e 截取，包括s 不包括e 统计录入大小写数字 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package myTest;import java.util.Scanner;/** * Created by JackFeng on 2020/3/2. */public class StringTest &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个字符串数据：&quot;); String s = sc.nextLine(); //定义统计变量 int BigCount = 0; int SmaCount = 0; int numberCount = 0; //遍历字符 for (int i = 0; i &lt;s.length() ; i++) &#123; char ch = s.charAt(i); if (ch &gt;= &#x27;A&#x27; &amp;&amp; ch&lt;= &#x27;Z&#x27;) &#123; BigCount++; &#125;else if(ch &gt;= &#x27;a&#x27; &amp;&amp; ch&lt;= &#x27;z&#x27;)&#123; SmaCount++; &#125;else if (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;)&#123; numberCount++; &#125;else &#123; System.out.println(&quot;该字符&quot;+ch+&quot;非法&quot;); &#125; &#125; System.out.println(&quot;大写字符&quot;+BigCount); System.out.println(&quot;小写字符&quot;+SmaCount); System.out.println(&quot;数字字符&quot;+numberCount); &#125;&#125; 转换功能 char[ ] toCharArray() —- 把字符串转换为字符数组 String toLlowerCase() —- 把字符串转换为小写字符串 String toUpperCase() —- 把字符串转换为大写字符串 字符串的遍历： A：length() 加上charAt() B：字符串转换字符数组，然后遍历数组 空格&amp;分割 去除字符串两端空格： String trim() 按照指定符号分割字符串 String[ ] split (String str) 实现字符串反转 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package myTest;import java.util.Scanner;/** * Created by JackFeng on 2020/3/2. *//** 键盘录入：abc 输出 cba** 反转方法：* A： 把字符串倒着遍历，得到每一个字符拼接成字符串* B： 把字符串转换成字符数组，然后对字符数组进行反转，最后把字符数组转换为字符串** */public class StringTest1 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个字符串：&quot;); String s = sc.nextLine(); // 调用方法A// String result = reverse(s); //调用方法B String result = reFan(s); //输出结果 System.out.println(&quot;result:&quot;+result); &#125; // 方案A public static String reverse (String s)&#123; String ss = &quot;&quot;; // 倒着遍历 for (int i = s.length()-1; i &gt;=0 ; i--) &#123; ss+=s.charAt(i); &#125; return ss; &#125; // 方案B public static String reFan( String s)&#123; // 把字符串转换为字符数组 char[] chs = s.toCharArray(); for (int start = 0,end = chs.length-1; start &lt;=end ; start++,end--) &#123; char temp = chs[start]; chs[start] = chs[end]; chs[end] = temp; &#125; // 把字符数组转换为字符串 String ss = new String(chs); return ss; &#125;&#125; 2、StringBuilder类功能 StringBuilder : 可变的字符串，字符串缓冲区类 String 内容是固定 StringBuider 内容是可变的 构造方法： StringBuilder() 成员方法： public int capacity() :返回当前容量 public int length() :返回长度(字符数) 容量 —- 理论值 长度 —- 实际值 常用方法 添加功能： public StringBuilder append(任意类型) 添加数据，并返回自身对象 链式编程 sb.append(“hello”).append(“world) 反转功能 public StringBuilder reverse() StringBuilder ——&gt;String toString() —— 转成String String ——&gt; StringBuilder StringBuilder (String str) —– 构造方法 键盘录入对称判断1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package myTest;import java.util.Scanner;/** * Created by JackFeng on 2020/3/2. *//** 判断一个字符串是否是对称字符串** 例如 abc 不是 aba abba aaa 是对称字符串** */public class StringBuilderDemo &#123; public static void main(String[] args) &#123; // 键盘录入 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个字符串：&quot;); String s = sc.nextLine(); // 方法实现 // 调用方法 boolean b = isDuiChen(s); System.out.println(&quot;b:&quot;+b); &#125; public static boolean isDuiChen(String s)&#123; StringBuilder sb = new StringBuilder(s); sb.reverse(); String result = sb.toString(); return result.equals(s); &#125;&#125; 3、对象数组 对象数组练习： 定义学生类 创建学生数组 创建学生对象 把学生对象作为元素赋值给学生数组 遍历学生数组 123456789101112131415161718192021222324252627282930313233343536373839package com.datascience.myArray;/** * Created by JackFeng on 2020/3/2. */public class StudentDemo &#123; public static void main(String[] args) &#123; // 创建学生数组 Student[] students = new Student[3]; //创建学生对象 Student s1 = new Student(&quot;荣耀王者&quot;, 50); Student s2 = new Student(&quot;星耀&quot;, 10); Student s3 = new Student(&quot;王者&quot;, 20); //学生对象 作为元素赋值给学生数组 students[0] = s1; students[1] = s2; students[2] = s3; //遍历学生数组 for (int i = 0; i &lt;students.length ; i++) &#123; Student s = students[i]; System.out.println(s); //这样输出的是地址值 System.out.println(s.getName()+&quot;=====&quot;+s.getAge()); &#125; &#125;&#125; 学生类 123456789101112131415161718192021222324252627282930313233343536373839404142package com.datascience.myArray;/** * Created by JackFeng on 2020/3/2. */ // alt + insert 可以快速生成 get/set 方法等public class Student &#123; private String name; private int age; public Student(String name,int age) &#123; this.name = name; this.age = age; &#125; public Student() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 4、集合ArrayList ArrayList： 大小可变数组的实现 : 特殊的数据类型：泛型 构造方法： ArrayList() 添加元素： pubilc boolean add(E e) — 添加元素 public void add (int index, E element) — 指定索引处 添加元素 获取元素： public E get(int index) —- 返回指定索引出的元素 集合长度： public int size() 返回集合中元素的个数 删除元素： public boolean remove(object o) 删除指定的元素，返回删除是否成功 pubilc E remove(int index) 删除指定索引出的元素，返回被删除的元素 修改元素： public E set(int index, E element) 修改指定索引出的元素，返回被修改的元素 AarryList(集合)遍历： size() + get 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.myArray;import java.util.ArrayList;/** * Created by JackFeng on 2020/3/ */public class ArrayListDemo &#123; public static void main(String[] args) &#123; // 创建集合对象 ArrayList&lt;Object&gt; array = new ArrayList&lt;&gt;(); // 这里如果是String 接受就是String Object 接受就是Object // add(E e) 添加元素 array.add(&quot;hello&quot;); array.add(&quot;world&quot;); array.add(&quot;Data&quot;); System.out.println(array); // 在指定索引处添加一个元素 // 第一个位置添加 Science array.add(1,&quot;Science&quot;); System.out.println(&quot;====&quot;); System.out.println(&quot;array&quot;+ array); //获取元素 get System.out.println(array.get(1)); // 集合长度 size System.out.println(&quot;集合的长度：&quot;+array.size()); // 删除元素 remove System.out.println(&quot;remove：&quot;+array.remove(&quot;hello&quot;)); System.out.println(&quot;remove：&quot;+array.remove(&quot;hello&quot;)); // 不存在则失败，这里就是失败了 false //删除指定元素 remove (int index) System.out.println(&quot;remove：&quot;+ array.remove(1)); // 修改元素 set (int index , E element) System.out.println(&quot;set:&quot;+ array.set(1,&quot;hhha&quot;)); // System.out.println(array); // 添加元素 array.add(&quot;aaa&quot;); array.add(&quot;abc&quot;); array.add(&quot;acd&quot;); //遍历集合 System.out.println(&quot;================&quot;); for (int i = 0; i &lt;array.size() ; i++) &#123; System.out.println(array.get(i)); &#125; // 标准遍历 for (int i = 0; i &lt;array.size() ; i++) &#123; // object Object s = array.get(i); System.out.println(s); &#125; &#125;&#125; Test 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.myArray;import java.util.ArrayList;import java.util.Scanner;/** * Created by JackFeng on 2020/3/ *//*** 创建一个集合：存储学生对象，学生对象的数据来自键盘录入，最后遍历集合*** 分析：* A： 定义学生类 String name , String age * B： 创建集合对象* C： 键盘录入数据，创建学生对象，把键盘录入的数据赋值给学生对象的成员变量* D： 把学生对象作为元素存储到集合中* E： 遍历集合** */public class ArrayListTest &#123; public static void main(String[] args) &#123; //创建集合对象 ArrayList&lt;Student&gt; array = new ArrayList&lt;Student&gt;(); //d调用方法 addStudent(array); addStudent(array); addStudent(array); //遍历集合 for (int i = 0; i &lt;array.size() ; i++) &#123; Student s = array.get(i); System.out.println(s.getName() +&quot;-------&quot;+ s.getAge()); &#125; &#125; /* * 提高复用性，键盘录入学生信息 封装成一个方法 * * 两个明确： * 返回值类型： void * 参数列表： ArrayList&lt;Student&gt; * * * */ public static void addStudent (ArrayList&lt;Student&gt; array)&#123; //键盘录入 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入姓名：&quot;); String name = sc.nextLine(); System.out.println(&quot;请输入年龄：&quot;); String age = sc.nextLine(); //赋值给成员变量 Student s = new Student(); s.setName(name); s.setAge(age); //学生对象存储到集合中 array.add(s); &#125;&#125; 简易学生管理系统 步骤： ​ A： 定义学生类 ​ B： 主界面的代码编写 ​ C： 查看所有学生 ​ D： 添加学生 ​ E： 修改学生 ​ F： 删除学生 Student 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package myStudentManager;/** * Created by JackFeng on 2020/3/4. *//*** 学生类* */public class Student &#123; private String id; // 姓名 private String name; // private String age; private String address; public Student() &#123; &#125; public Student(String id, String name, String age, String address) &#123; this.id = id; this.name = name; this.age = age; this.address = address; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; Test 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235package myStudentManager;import java.util.ArrayList;import java.util.Scanner;/** * Created by JackFeng on 2020/3/4. */public class StudentMangerTest &#123; public static void main(String[] args) &#123; //创建集合对象，存储学生数据 ArrayList&lt;Student&gt; array = new ArrayList&lt;&gt;(); while (true) &#123; // 主界面 System.out.println(&quot;---------欢迎来到学生管理系统----------&quot;); System.out.println(&quot;1 查看所有学生&quot;); System.out.println(&quot;2 添加学生&quot;); System.out.println(&quot;3 删除学生&quot;); System.out.println(&quot;4 修改学生&quot;); System.out.println(&quot;5 退出&quot;); System.out.println(&quot;请输入你的选择：&quot;); // 键盘录入 Scanner sc = new Scanner(System.in); String choice = sc.nextLine(); switch (choice) &#123; case &quot;1&quot;: // 查看所有学生 findAllStudent(array); break; case &quot;2&quot;: // 添加学生 addStudent(array); break; case &quot;3&quot;: //删除学生 delStudent(array); break; case &quot;4&quot;: //修改学生 updataStudent(array); break; case &quot;5&quot;: //退出// break; case 穿透 default: System.out.println(&quot;谢谢你的使用！&quot;); System.exit(0); // jvm 退出 break; &#125; &#125; &#125; //1 查看所有学生 public static void findAllStudent(ArrayList&lt;Student&gt; array)&#123; // 判断集合中是否有数据，如果没有数据，给出提示，并让该方法不继续往下执行 if (array.size()==0)&#123; System.out.println(&quot;不好意思，暂无学生信息，请重新选择你的操作&quot;); return;// void 没有返回值 可以直接return &#125; // \\t System.out.println(&quot;学号\\t\\t姓名\\t年龄\\t地址&quot;); for (int i = 0; i &lt; array.size(); i++) &#123; Student s = array.get(i); System.out.println(s.getId()+&quot;--&quot;+s.getName()+&quot;--&quot;+s.getAge()+&quot;---&quot;+s.getAddress()); &#125; &#125; // 添加学生 public static void addStudent(ArrayList&lt;Student&gt; array)&#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); // id 定义在外边 因为下边还要用 String id; // 代码重复使用 while (true)&#123; System.out.println(&quot;请输入 学生ID：&quot;);// String id = sc.nextLine(); id = sc.nextLine(); //判断学号是否存在 // 定义标记默认为false boolean flag = false; for (int i = 0; i &lt;array.size() ; i++) &#123; Student s = array.get(i); if (s.getId().equals(id))&#123; flag = true; // 说明学号被占用 &#125; &#125; if (flag)&#123; System.out.println(&quot;你输入的学号已经被占用&quot;); &#125;else &#123; break; &#125; &#125; System.out.println(&quot;请输入 学生姓名：&quot;); String name = sc.nextLine(); System.out.println(&quot;请输入 学生年龄：&quot;); String age = sc.nextLine(); System.out.println(&quot;请输入 学生地址：&quot;); String address = sc.nextLine(); //创建学生对象 Student s = new Student(); s.setId(id); s.setAge(age); s.setName(name); s.setAddress(address); // 把学生对象添进 集合 array.add(s); System.out.println(&quot;学生信息添加成功====姓名为： &quot;+s.getName()); &#125; public static void delStudent(ArrayList&lt;Student&gt; array)&#123; //根据学号删除 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入要删除学生的学号：&quot;); String id = sc.nextLine(); // 定义一个索引 int index = -1; //遍历集合 for (int i = 0; i &lt;array.size() ; i++) &#123; //获取每个学生的对象 Student s = array.get(i); if (s.getId().equals(id))&#123;// array.remove(i); // 根据索引删除 index = i; break; &#125;// System.out.println(&quot;删除学生成功！&quot;); &#125; if (index == -1)&#123; System.out.println(&quot;不好意思，您输入的学号不存在，请重新输入&quot;); &#125;else &#123; array.remove(index); // 根据索引删除 System.out.println(&quot;删除学生成功&quot;); &#125; &#125; // 修改学生 public static void updataStudent(ArrayList&lt;Student&gt; array)&#123; // 创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入你要修改学生的学号：&quot;); String id = sc.nextLine(); // 定义一个索引 int index = -1; for (int i = 0; i &lt;array.size() ; i++) &#123; //获取每一个学生对象 Student s = array.get(i); if (s.getId().equals(id))&#123; index = i; break; &#125; &#125; if (index == -1)&#123; System.out.println(&quot;不好意思，你要修改的学生信息不存在，请重新你的选择&quot;); &#125;else &#123; System.out.println(&quot;请输入学生新姓名：&quot;); String name = sc.nextLine(); System.out.println(&quot;请输入学生新年龄：&quot;); String age = sc.nextLine(); System.out.println(&quot;请输入学生新住址：&quot;); String address = sc.nextLine(); Student s = new Student(); s.setId(id); s.setName(name); s.setAddress(address); s.setAge(age); // 修改集合中的学生信息 array.set(index, s); System.out.println(&quot;修改学生信息成功&quot;); &#125; &#125;&#125; 5、IO字符流 IO流用来处理设备之间的数据传输 文件复制，上传、下载文件 IO流分类 输出流 FileWriter 输入流 FileReader 常见的换行符： Windows \\r\\n Linux \\n Mac \\r 5.0、写数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package myIo;import java.io.FileWriter;import java.io.IOException;/** * Created by JackFeng on 2020/3/8. *//** 需求： 往文件中写数据** 写数据 -- 输出流 ---FileWriter*** */public class FileWriterDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建输出流对象 // 调用系统资源创建一个文件,创建输出流对象，把输出流对象指向文件 // 不写路径 就会在 在相对路径下创建！// FileWriter fw = new FileWriter(&quot;D:\\\\Practice\\\\Java\\\\JavaSE\\\\a.txt&quot;); // 默认为false FileWriter fw = new FileWriter(&quot;D:\\\\Practice\\\\Java\\\\JavaSE\\\\a.txt&quot;,true); // true 为追加写入 // 写字符串数据// fw.write(&quot;IO你好&quot;); // 数据没有直接写入 到文件中， 其实是写到了内存缓冲区// fw.flush(); // 刷新缓冲区 // 释放资源 通知系统释放和该文件相关的资源 // 写数据的几种方法 /* * 1、write(String str) 写一个字符串数据 * * */ // 1// fw.write(&quot;abcde&quot;); //2// fw.write(&quot;abcd&quot;,1,2); // 3// fw.write(97); // 4 写一个数组// char[] chs = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;// fw.write(chs); // 5// fw.write(chs, 0, 1); // 数据换行 + 数据追加写入 // \\n 可以换行，windows 没有换行 ，\\r\\n for (int i = 0; i &lt; 10 ; i++) &#123; fw.write(&quot;Hi&quot;+i); fw.write(&quot;\\r\\n&quot;); &#125; fw.close(); // 先刷新缓冲区。再通知系统释放资源 &#125;&#125; 5.1、读数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package myIo;import java.io.FileReader;import java.io.IOException;/** * Created by JackFeng on 2020/3/8. */public class FileReaderDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建输入流 对象 FileReader fr = new FileReader(&quot;D:\\\\Practice\\\\Java\\\\JavaSE\\\\a.txt&quot;);/* // 读数据方法 // 1. int read() // 第一次读数据 int ch = fr.read(); System.out.println(ch); System.out.println((char)ch); // 第二次 ch = fr.read(); System.out.println(ch); System.out.println((char)ch); // 如果读取数据的返回值 是 -1的时候 说明结束了*/// 标准代码 // 读取 字符串/* int ch; while ((ch=fr.read())!= -1)&#123;// System.out.println(ch); System.out.print((char)ch); &#125;*/ //第二种读取数据方式 一次读取一个数组的数据 // 标准代码 效率较高// char[] chs = new char[5]; char[] chs = new char[1024]; // 一般写1024 及其整数倍 int len; while ((len= fr.read(chs)) != -1)&#123; System.out.print(new String(chs,0,len)); // 以数组方式读入 &#125; fr.close(); // 释放资源 &#125;&#125; 5.2、文件复制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package myIo;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;/** * Created by JackFeng on 2020/3/8. */public class CopyFileDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建输入刘对象 FileReader fr = new FileReader(&quot;D:\\\\Practice\\\\Java\\\\JavaSE\\\\src\\\\myIo\\\\FileWriterDemo.java&quot;); // 创建输出流对象 FileWriter fw = new FileWriter(&quot;Copy.java&quot;); //读写数据/* int ch; while ((ch=fr.read())!=-1)&#123; fw.write(ch); &#125;*/ char[] chs = new char[1024]; int len; while ((len= fr.read(chs))!= -1)&#123; fw.write(chs,0,len); &#125; fr.close(); fw.close(); &#125;&#125; 5.3、字符缓冲流BufferedWriter —- 高效写入 BufferedReader — 高效读取 不是直接传入文件，而是传入 FileWriter 特殊功能 BufferedWriter Void newLine() —- 写一个换行符，这个换行符由系统决定的 BufferedReader String readLine() —- 一次读取一行数据,但是不读取换行符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package myIo;import java.io.*;/** * Created by JackFeng on 2020/3/8. */public class BufferedDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建输出缓冲流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;a.txt&quot;)); bw.write(&quot;hello world&quot;);// bw.flush(); for (int i = 0; i &lt; 10 ; i++) &#123; bw.write(&quot;Hi&quot;+i);// bw.write(&quot;\\r\\n&quot;); bw.newLine(); // 等同于 bw.write(&quot;\\r\\n&quot;); &#125; bw.close(); // 创建输入缓冲流对象 BufferedReader br = new BufferedReader( new FileReader(&quot;a.txt&quot;)); // 一次写一个字符/* int ch; while ((ch=br.read())!= -1)&#123; System.out.print((char) ch); &#125;*/ // 一次读写一个数组/* char[] chs = new char[1024]; int len; while ((len = br.read(chs))!= -1)// System.out.print(chs,0,len); 这里会报错 需要 new String 构造 System.out.println(new String(chs,0,len)); br.close();*/ String line; // br.readLine while((line= br.readLine())!=null)&#123; System.out.println(line); &#125; br.close(); &#125;&#125; 集合数据写入文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344package myIo;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.util.ArrayList;/** * Created by JackFeng on 2020/3/8. */public class ArrayListToFileTest &#123; public static void main(String[] args) throws IOException &#123; // 创建集合对象 ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;(); // 给集合添加元素 array.add(&quot;hello&quot;); array.add(&quot;world&quot;); array.add(&quot;今天是2020，三八妇女节&quot;); // 创建缓冲流输出对象 BufferedWriter bw = new BufferedWriter( new FileWriter(&quot;array.txt&quot;)); //遍历集合写入到文件 for (int i = 0; i &lt;array.size() ; i++) &#123; String s = array.get(i); bw.write(s); bw.newLine(); // 读取换行 bw.flush(); &#125; bw.close(); &#125;&#125; 文件存入集合 123456789101112131415161718192021222324252627282930313233343536373839404142package myIo;import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;import java.util.ArrayList;/** * Created by JackFeng on 2020/3/8. */public class FileToArrayList &#123; public static void main(String[] args) throws IOException &#123; // 创建输入缓冲流对象 BufferedReader br = new BufferedReader(new FileReader(&quot;array.txt&quot;)); // 创建集合对象 ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); // 读取数据 每次读取一行数据， 把该行数据作为一个元素存储到集合中 String line; while ((line = br.readLine())!= null)&#123; array.add(line); &#125; br.close(); //遍历集合 for (int i = 0; i &lt;array.size() ; i++) &#123; String s = array.get(i); System.out.println(s); &#125; &#125;&#125; 学生管理添加升级版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package myIo;import myStudentManager.Student;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.util.ArrayList;import java.util.Scanner;/** * Created by JackFeng on 2020/3/8. */public class ArratListToFileTest &#123; public static void main(String[] args) throws IOException &#123; ArrayList&lt;Student&gt; array = new ArrayList&lt;&gt;(); // 写方法添加学生对象 addStudent(array); addStudent(array); addStudent(array); // 创建输出缓冲流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;std.txt&quot;)); for (int i = 0; i &lt;array.size() ; i++) &#123; Student s = array.get(i); // 链式编程 /// 姓名,年龄,。。。 采用 StringBuilder StringBuilder sb = new StringBuilder(); sb.append(s.getId()).append(&quot;,&quot;).append(s.getName()).append(&quot;,&quot;).append(s.getAddress()).append(&quot;,&quot;).append(s.getAge()); bw.write(sb.toString()); // 转化为string bw.newLine(); // 换行 bw.flush(); // 刷新 &#125; bw.close(); &#125; // 添加学生 public static void addStudent(ArrayList&lt;Student&gt; array)&#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); // id 定义在外边 因为下边还要用 String id; // 代码重复使用 while (true)&#123; System.out.println(&quot;请输入 学生ID：&quot;);// String id = sc.nextLine(); id = sc.nextLine(); //判断学号是否存在 // 定义标记默认为false boolean flag = false; for (int i = 0; i &lt;array.size() ; i++) &#123; Student s = array.get(i); if (s.getId().equals(id))&#123; flag = true; // 说明学号被占用 &#125; &#125; if (flag)&#123; System.out.println(&quot;你输入的学号已经被占用&quot;); &#125;else &#123; break; &#125; &#125; System.out.println(&quot;请输入 学生姓名：&quot;); String name = sc.nextLine(); System.out.println(&quot;请输入 学生年龄：&quot;); String age = sc.nextLine(); System.out.println(&quot;请输入 学生地址：&quot;); String address = sc.nextLine(); //创建学生对象 Student s = new Student(); s.setId(id); s.setAge(age); s.setName(name); s.setAddress(address); // 把学生对象添进 集合 array.add(s); System.out.println(&quot;学生信息添加成功====姓名为： &quot;+s.getName()); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"}]},{"title":"Java面向对象(封装)","slug":"Java/JavaSE/Java面向对象-封装","date":"2020-05-07T15:54:34.000Z","updated":"2020-09-18T02:25:47.480Z","comments":true,"path":"posts/8589.html","link":"","permalink":"http://www.a2data.cn/posts/8589.html","excerpt":"Java面向对象 封装！","text":"Java面向对象 封装！ 面向对象（封装） 面向对象思想： 面向对象是基于面向过程的编程思想。 面向过程：强调每一个功能的步骤 面向对象：强调的是对象，然后用对象去调用功能 特点 A:符合我们思考习惯的思想 B:可以将复杂的事情简单化 C:执行者—-指挥者 类和对象 A：属性 —- 就是事物的描述信息 B：行为 —- 事物能够做什么 类：一组相关属性和行为的集合 对象： 就是该事物的具体体现 成员变量 位置： 类中，方法外 初始化值：不需要 成员方法 去掉static 关键字 Phone 12345678910111213141516171819202122232425package myTest;/** * Created by JackFeng on 2020/3/2. */public class Phone &#123; String barnd; int price; String color; public void call(String name) &#123; System.out.println(&quot;给&quot; + name + &quot;打电话&quot;); &#125; public void sendMessage()&#123; System.out.println(&quot;给所有人群发短信&quot;); &#125;&#125; PhoneDemo 12345678910111213141516171819202122232425package myTest;/** * Created by JackFeng on 2020/3/2. */public class PhoneDemo &#123; public static void main(String[] args) &#123; Phone p = new Phone(); System.out.println(p.barnd + &quot;---&quot; +p.price+ &quot;----&quot;+p.color); p.barnd = &quot;iphone&quot;; p.price = 8888; p.color = &quot;金色&quot;; System.out.println(p.barnd + &quot;---&quot; +p.price+ &quot;----&quot;+p.color); p.call(&quot;DataScience&quot;); p.sendMessage(); &#125;&#125; 成员变量和局部变量的区别 区别： A: 在类中的位置不同 成员变量：类中，方法外 局部变量：方法中或者方法声明上(形式参数) B：在内存中的位置不同 成员变量：堆内存 局部变量：栈内存 C：生命周期不同 成员变量：随着对象的创建而存在，随着对象的消失而消失 局部变量：随着方法的调用而存在，随着方法调用完毕而消失 D：初始化值的问题 成员变量：有默认值 局部变量：没有默认值，必须先定义，赋值，最后使用 1234567891011121314151617181920212223package myTest;/** * Created by JackFeng on 2020/3/2. */public class Variable &#123; // 成员变量 int x; public void show ()&#123; //局部变量// int y; // 如果y 没有值 就会报错 int y = 1; // 赋值就会不报错 System.out.println(y); // 调用x 有默认值 System.out.println(x); &#125;&#125; 标准学生类代码 12345678910111213141516171819202122232425package myTest;/** * Created by JackFeng on 2020/3/2. */public class StudentDemo &#123; public static void main(String[] args) &#123;// 无参 + set方法 Student s = new Student(); s.setName(&quot;Data&quot;); s.setAge(26); System.out.println(s.getName()+&quot;====&quot;+s.getAge()); // 带参构造 Student s2 = new Student(&quot;DataScinece&quot;, 26); System.out.println(s2.getName()+&quot;====&quot;+s2.getAge()); &#125;&#125; 学生类 1234567891011121314151617181920212223242526272829303132333435363738394041package myTest;/** * Created by JackFeng on 2020/3/2. */public class Student &#123; private String name; private int age; // 构造方法 // 无参数 public Student()&#123;&#125; // 有参数 public Student(String name, int age )&#123; this.name = name; this.age = age; &#125; // get set 方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 类名 如果类名作为形式参数传递 要的是该类的对象 如果类名作为返回值类型 返回的是该类的对象","categories":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"}]},{"title":"Java基础语法","slug":"Java/JavaSE/Java基础语法","date":"2020-05-07T15:54:10.000Z","updated":"2020-09-18T02:25:47.406Z","comments":true,"path":"posts/34708.html","link":"","permalink":"http://www.a2data.cn/posts/34708.html","excerpt":"Java基础语法","text":"Java基础语法 1、基础语法Hello Wolrd 首先定义类 —— public class 类名 在类定义之后加上一对大括号 —— {} 在大括号中间添加一个主(main)方法/函数 —— public static void main(String[] args){} 在主方法的大括号中间添加一行输出语句 —— System.out.println(“Hello World”) 完整代码 public class HelloWorld&#123; public class static void main(String[] args)&#123; System.out.println(&quot;Hello World!&quot;) &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114- Javac —— 编译 javac HelloWorld.java- Java + HelloWorld 运行**初学者注意事项**- 单词拼写问题 — class &gt; Class — String &gt; string — System &gt; system — main &gt; mian- 中文符合问题 — 提示非法字符## 1.1、Java入门### 1.1.0、注释注释&#x2F;&#x2F; #单行注释 &#x2F;\\*...\\*&#x2F; #多行注释&#x2F;\\...\\*&#x2F; #文本注释JAVA 语句用 ； 分号结束。命名A、类：首字母大写B、方法&#x2F;函数：首字母小写第二个单词首字母大写C、变量： 首字母小写第二个单词首字母大写D、常量：全部字母大写###### 标识符程序员对程序中的各个元素加以命名时，使用的命名记号，称为标识符。标识符以字母 下划线（__） 美元符（$）开始的一个字符序列，后可跟 字母，下划线，美元符，数字。### 1.1.1、关键字JAVA关键字(保留字）*| abstract | default | if | private | this || -------- | ------- | ---------- | ------------ | --------- || boolean | do | implements | protected | throw || break | double | impor | public | throws || byte | else | instanceof | return | transient || case | extends | int | short | try || catch | final | interface | statictfp | volatile || char | finally | long | strictfp | volatile || class | float | native | super | while || const | for | new | switch | null || continue | goto | package | synchronized | |### 1.1.2、常量常量：程序执行中，值不可发生改变变量：在程序执行中，值会发生变化- 常量分类 —— A： 字符串常量 &#39;DataScience’ —— B： 整数常量 123 —— C： 小数常量 1.23 —— D： 字符常量 ‘a’,’1’ —— E： 布尔常量 true ,false —— F： 空常量 （null、&#39;’)&#96;&#96;&#96;javapublic class CL&#123; public static void main(String[] args)&#123; &#x2F;&#x2F; 字符串常量 System.out.println(&quot;DataScience&quot;) &#x2F;&#x2F; 整数常量 System.out.println(123) &#x2F;&#x2F; 小数常量 System.out.println(1.23) &#x2F;&#x2F; 字符串量 System.out.println(&quot;Data&quot;) &#x2F;&#x2F; 布尔常量 System.out.println(true) &#125;&#125; 1.1.3、变量 变量的申明： 访问[修饰符] 数据类型 变量名称=初始值 变量的分类：1、按照声明位置： 成员变量： 类的内部，方法的外部定义的变量 局部变量： 方法或代码块的内部定义的变量 区别： 成员变量有默认初始值，局部变量没有 成员变量的作用域在整个类的内部，局部变量在当前方法或代码块中 变量实例： 123456789101112131415161718192021222324252627282930313233343536/** * Created by JackFeng on 2019/8/28. *//** 常量: 在程序的执行过程中，其值不可以发生改变的量** 常量的分类：* A： 字符串常量* B： 整数常量* C： 小数常量* D： 字符常量* E： 布尔常量 true ,false* F： 空常量** */public class Variable &#123; public static void main(String[] args) &#123; // A System.out.println(&quot;欢迎关注公众号DataScience&quot;); // B System.out.println(12); System.out.println(-66); // C System.out.println(23.56); //D System.out.println(&#x27;a&#x27;); // E System.out.println(true); &#125;&#125; 1.1.4、数据类型 数据类型 —— Java是强类型语言，针对每一种数据都给出了明确的数据类型。 数据类型分类： A：基本数据类型 B：引用数据类型 （类、接口、数组） 基本数据类型（以及占用字节数） A、整数 byte 1 short 2 int 4 long 8 B、浮点数 float 4 double 8 C、字符 char 2 D、布尔 boolean 1 注意 A：整数默认是int类型，浮点数默认是double类型 B： 定义long类型数据的时候，要加L或者l，建议加L 定义float类型数据的时候，要加F或者f，建议加F 整型变量 类型 占用储存空间 表数范围 byte 1字节 -128~127 short 2字节 -2^15~2^15-1 int 4字节 -2^31~2^31-1 long 8字节 -2^63~2^63-1 浮点型变量 类型 占用储存空间 表数范围 float 4字节 -3.403E38~3.403E38 double 8字节 -1.798E308~1.798E308 字符型变量： char 一个字符2字节 布尔型变量： true false 符号常量 final 变量类型 变量名=初始化值 值常量整型常量、浮点型常量、符号型常量、字符串常量、布尔型常量（true false） 空常量 转义字符 含义 \\b 退格（backspace） \\t 水平制表（Tab） \\f 走纸换页，只对打印有效 \\n 换行 \\r 回车 \\ 反斜杠字符 &#39; 单引号字符 &quot; 双引号字符 \\ddd 1–3位八进制数所代表的ASCII字符 \\uxxxx 1-4位十六进制数所代表的unicode字符 1.1.5、 计算机存储单元 bit(比特位) —–字节（byte） 单位换算： 1B(字节) = 8it 1KB = 1024B 1MB = 1024KB 1GB = 1024MB 1TB = 1024GB 1PB = 1024TB 1ZB = 1024PB 1.1.6、标识符1234567891011121314151617181920212223242526272829标识符： 包、类、方法、变量 等起名字的符号组成规则： A：unicode 字符 数字字符，英文大小写字母，汉字（不建议使用汉字） B：下划线 _ C：美元符 $注意事项： A: 不能以数字开头 B：不能是Java中的关键字常见命名规则： A：基本要求 见名知意 B：常见的命名 1、包（其实就是文件夹，用于对类进行管理） 全部小写，多级包.隔开 EG: com， com.datascience 2、类 单个单词首字母大写 EG:Dog 多个单词首字母大写 EG:BigDog 3、方法和变量 单个单词首字母小写 EG： dog 多个单词组成第二个开始首字母大写 EG: bigDog,maxAge 1.1.7、运算符优先级 优先级 运算符 结合性 1 （） [ ] . 从左向右 2 ！ +（正） -（负） ~ ++ – 从右向左 3 / * % 从左向右 4 + (加) -（减） 从左向右 5 《 》 &gt;&gt;&gt; 从左向右 6 &lt;&lt;=&gt;&gt; instanceof 从左向右 7 == ！= 从左向右 8 &amp; （按位与） 从左向右 9 ^ 从左向右 10 | 从左向右 11 &amp;&amp; 从左向右 12 || 从左向右 13 ?: 从右向左 14 = += -= *= /= %= &amp;= |= ^= ~= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= 从右向左 1.2、基本类型数据转换1.2.1、定义变量12345变量格式： 数据类型 变量名 = 初始化值数据类型： byte,short,int,long,float,double,char,boolean Demo 12345678910111213141516171819202122232425262728293031323334353637383940414243public class VariableDemo &#123;/** 变量的定义* */public static void main(String[] args)&#123;// 定义byte 类型 byte a = 10; System.out.println(10); System.out.println(a); // 定义 short类型 short b = 11; System.out.println(b);// 定义int类型 int c = 12; System.out.println(c);// 定义long类型 long d = 1231L; System.out.println(d);// 定义float类型 float e = 1.23F; System.out.println(e);// 定义double类型 double f = 1.23; System.out.println(f);// 定义char类型 char g = &#x27;a&#x27;; System.out.println(g);// 定义boolean类型 boolean h = true; System.out.println(h); &#125;&#125; 1.2.2、变量定义的注意事项123456789101112131415161718192021222324252627282930313233343536package one;/** * Created by JackFeng on 2020/2/22. */public class BianLiang &#123; /* * 变量定义的注意事项 * A: 变量未赋值，不能直接使用 * B：变量只在所属的范围内有效（仅在它所在的大括号中有效） * C: 一行可以多个变量（不建议） * */ public static void main(String[] args)&#123;// 定义变量aa、 int aa = 2020; System.out.println(aa); &#123;// 大括号中的就是代码块 int ab = 131; System.out.println(ab); &#125;// 定义多个变量 int a1, a2; a1 =11; a2 = 20; System.out.println(a1); System.out.println(a2); &#125;&#125; 1.2.3、类型转化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package one;/** * Created by JackFeng on 2020/2/25. *//** +: 加法运算符** 运算中，要求参与运算的数据类型必须一致*** 类型转化：* 隐式转化* 强制转化* 隐式转化：* byte,short,char -- int --long --float --double* byte+ int === int 类型* 强制转化：* 目标类型 变量名 = （目标类型）（被转化的数据）* 建议：数据做运算，最好以结果类型为准（不要随意转化，否则可能损失精度）* int a = 10;* byte b = 20;* int c = a+b** byte d = (byte)(a + b)*** */public class TypeCastDemo &#123; public static void main(String[] args) &#123;// 1、 定义同类型变量 int a = 11; int b = 22; int c = a + b; System.out.println(c);// 定义一个 byte 类型 一个int类型 int a1 = 10; byte a2 = 20; System.out.println(a1+a2); &#125;&#125; 1.2.4、运算符1.2.4.1、运算符 运算符： 用于 常量和变量操作的符号 表达式：用运算符号链接起来符合java语法的句子 ​ EG: a,b a+b 1.2.4.2、运算符分类1、算术运算符 +，-，*，/ ，%，++，– *+，-，，/** 12345678910111213 // +,-,*,/ 使用// 定义变量 int a = 3; int b = 4; System.out.println(a+b); System.out.println(a-b); System.out.println(a*b); System.out.println(a/b);// 整数相除 只能得到整数，要想得到小数 必须有浮点数参与运算 System.out.println(3.0/4); System.out.println(3/4.0); % (取余) *%*：用于获取 两个数据相除时候的余数 */*： 用于获取 两个数据相除时候的商 12345int a1=3;int a2=5;System.out.println(a2/a1);System.out.println(a2%a1); + +： 加法运算 正常加法运算 int a =10; int b = 12; 字符参与加法运算，是拿字符在计算机中存储的数据值来参与运算的 “A” 65 ‘a’ 97 ‘0’ 48 字符串参与加法运算，其实不是做加法，而是字符串的拼接 例如： int a =1; int b =2; System.out.println(“hello”+a) hello1 System.out.println(a+b+”hello”) ​ 3hello 注意 执行顺序（会对结果产生影响）： 从左–&gt;右 ++，– ++，– ： 自增自减，用于对变量+1 或 -1 单独使用： 放在变量前后都可以，结果一样 其它操作： ++ 在后边，先拿变量做操作，然后变量再++ ++ 在前边，先变量++，再拿变量做操作 1234567891011121314151617181920212223242526272829package myOperator;/** * Created by JackFeng on 2020/2/25. *//** ++ -- : 自增自减** */public class OpeartorDemo1 &#123; public static void main(String[] args) &#123;// 定义变量 int a = 123; System.out.println(&quot;a:&quot;+a);// ++ int b = a++; System.out.println(&quot;a:&quot;+a); System.out.println(&quot;b:&quot;+b); int c = ++a; System.out.println(&quot;a:&quot;+a); System.out.println(&quot;c:&quot;+c); &#125;&#125; 2、赋值运算符 赋值运算符： 基本赋值运算符：= 扩展赋值运算符：+=，-=，*=，/=,….. 123456789101112131415161718192021222324252627282930313233343536package myOperator;/** * Created by JackFeng on 2020/2/25. *//** 赋值运算符：* 基本的赋值运算符： =* 扩展的赋值运算符： +=，-=，*=，/= ...** */public class OpeartorDemo2 &#123; public static void main(String[] args) &#123;// 定义变量 int a = 25; // 把 25 赋值给int 类型的变量a// += 操作// 拿+= 左边和右边的数据做 加法，然后赋值给左边 a += 5; System.out.println(a);// 注意： 扩展的赋值运算符,隐含了 强制类型转换// 有一个变量 a, a+=5;// 相当于： a=(a的数据类型)(a+5) short s = 1; s += 1; System.out.println(s); &#125;&#125; 3、关系运算符 关系运算符： ==， !=，&gt;,&gt;=,&lt;,&gt;= 关系运算符结果是 boolean类型.（false/true） 注意事项： 不要把两个== 写成 = （除非你赋值） 4、逻辑运算符 逻辑运算符： 释义：用于链接关系表达式 逻辑运算分类： &amp;，|，^,! &amp;&amp;, || &amp;（或） 有false 则false |（与） 有true则true ^（异或） 相同则false，不同则true ！（非） true则false，false 则 true &amp;&amp; &amp;&amp; 和 &amp; 的结果一样 &amp;&amp; 与 &amp; 的区别： &amp;&amp; 有短路效果，左边为false，右边不执行 &amp; 左边无论是什么，右边都会执行 || || 和 | 的结果一样 || 与 | 的区别： || 左边为true ，右边不执行 | 左边无论是啥，右边都执行 5、三元运算符 三元运算符： 关系表达式？表达式1：表达式2 执行流程： A： 计算关系表达式的值（true/false） B: 结果展示 如果是true，表达式1就是结果 如果是false，表达式2就是结果 12345678910111213// 三元运算符 int aa = 10; int bb = 20; int cc = (aa &gt; bb) ? aa : bb; System.out.println(&quot;====&quot;); System.out.println(&quot;cc&quot;+cc); //输出 ==== cc:20 案例：取三个数中的最大值 123456789101112// 获取三个数的最大值int q = 11;int w = 12;int e = 22;// 先获取两个数据的最大值,然后再和第三个数据比较即可int temp = (q &gt; w) ? q : w;int max = (temp &gt; e) ? temp : e;System.out.println(&quot;+++++++++&quot;);System.out.println(&quot;max:&quot;+max); 1.2.5、键盘录入123456789101112131415161718192021222324252627282930313233343536373839404142package myScanner;/** * Created by JackFeng on 2020/2/25. *//*** 键盘录入：* 如何实现？ JDK提供的类Scanner* 使用步骤：* A: 导包* import java.util.Scanner;* 在一个类中顺序： package &gt; import &gt; class* B: 创建键盘录入对象* Scanner sc = new Scanner(System.in)* C: 接受数据* int i = sc.nextInt();**** */import java.util.Scanner;public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入数据： &quot;); int i = sc.nextInt(); System.out.println(&quot;i:&quot;+i); &#125;&#125; 录入数据求和 123456789101112131415161718192021222324252627282930 // 录入数据 并且求和 System.out.println(&quot;请输入第一个数据： &quot;); int aa = sc.nextInt(); System.out.println(&quot;请输入第二个数据： &quot;); int bb = sc.nextInt(); // 数据求和 int sum = aa + bb; System.out.println(&quot;sum:&quot;+sum); // 比较两个数据是否相等// boolean flag = (aa == bb) ? true : false; boolean flag = (aa == bb); System.out.println(flag); // 录入三个数据,三个数据的最大值 System.out.println(&quot;请输入第三个数据： &quot;); int cc = sc.nextInt(); int temp = (aa &gt; bb) ? aa : bb; int max = (temp&gt;cc)?temp:cc; System.out.println(&quot;max:&quot;+max); 1.2.6、流程控制语句顺序结构 从上往下，依次执行！ 选择结构 if语句： if(关系表达式){ ​ 语句体 } 执行流程 A: 首先计算关系表达式的值，看是true/false B: 如果是true，就执行语句体 C: 如果是False，则不执行 1234567891011121314// if 关系表达式 int a = 10; int b = 20; if(a==b)&#123; System.out.print(&quot;a=b&quot;) &#125; int c = 10; if(a==c)&#123; System.out.println(&quot;a=c&quot;) &#125; if(关系表达式){ ​ 语句体1; }else{ ​ 语句体2; } 1234567891011 // 判断一个数 是偶数还是奇数 int a = 100;// 重新给a赋值a = 99; if(a%2 ==0)&#123; System.out.println(&quot;a为偶数&quot;); &#125;else&#123; System.out.println(&quot;a为奇数&quot;); &#125; if(关系表达式1){ ​ 语句体1; }else if(关系表达式2){ ​ 语句体2; } … else{ ​ 语句体n+1; } 123456789101112131415161718192021// 多个if 表达式 int x = 10; int y; if (x &gt;= 3)&#123; y = 2 * x + 1; &#125; else if (x &gt;= -1 &amp;&amp; x&lt;3)&#123; y = 2 * x; &#125;else if (x &lt;= -1)&#123; y = 2 * x - 1; &#125;else &#123; y = 0; System.out.println(&quot;不存在x&quot;); &#125; System.out.println(&quot;y&quot;+y); 键盘录入案例比较 12345678910111213141516171819202122232425262728293031323334// 键盘录入判断最大值 Scanner sc = new Scanner(System.in); System.out.println(&quot;1:&quot;); int a = sc.nextInt(); System.out.println(&quot;2: &quot;); int b = sc.nextInt(); // 常规比较 if (a &gt; b) &#123; System.out.println(&quot;最大值是：&quot;+a); &#125;else &#123; System.out.println(&quot;最大值是：&quot;+b); &#125; // 用一个变量值接受 int max; if (a &gt; b) &#123; max = a; System.out.println(&quot;max：&quot;+max); &#125;else &#123; max = b; System.out.println(&quot;max：&quot;+max); &#125; // 对变量max 做操作 max = max + 100; System.out.println(max); 1.2.7、选择结构语句switch 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package myOperator;import java.util.Scanner;/** * Created by JackFeng on 2020/2/26. *//** switch语句格式：* switch (表达式)&#123;* case 值1：* 语句体1;* case 值2：* 语句体2;* ...* default:* 语句体n+1;* break;** &#125;**** */public class SwitchDemo &#123; public static void main(String[] args) &#123; /* * 格式解释： * 表达式： byte，short，int，char * jdk5 以后 可以是枚举 * jdk7 以后 可以是字符串 * case后边的值：就是用来和表达式的值进行匹配的内容 * break：表示中断的意思 * default： 所有值都不匹配的时候（相当于else） * * */ // 键盘录入 1-7 判断星期几 Scanner sc = new Scanner(System.in); // 接受数据 System.out.println(&quot;请输入数字 1-7:&quot;); int weekday = sc.nextInt(); switch (weekday)&#123; case 1: System.out.println(&quot;星期一&quot;); break; case 2: System.out.println(&quot;星期二&quot;); break; case 3: System.out.println(&quot;星期三&quot;); break; case 4: System.out.println(&quot;星期四&quot;); break; case 5: System.out.println(&quot;星期五&quot;); break; case 6: System.out.println(&quot;星期六&quot;); break; case 7: System.out.println(&quot;星期天&quot;); break; default: System.out.println(&quot;你输入的数据有误&quot;); break; &#125; &#125;&#125; 1.2.8、循环结构语句1.2.8.1、for123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package myOperator;/** * Created by JackFeng on 2020/2/26. *//** for循环语句的格式：* for(初始化语句;判断条件语句;控制条件语句）&#123;* 循环体语句：** &#125;** */public class ForDemo &#123; public static void main(String[] args) &#123;// 输出10次 hello for (int i=1;i&lt;=10;i++)&#123; System.out.println(&quot;hello&quot;+i); &#125; // 获取 1-5 for (int x =1 ;x &lt;=5;x++)&#123; System.out.println(&quot;-----&quot;); System.out.println(x); &#125; // 获取 5-1 for (int x = 5; x &gt;= 1; x--) &#123; System.out.println(&quot;======&quot;); System.out.println(x); &#125; // 1-5 求和 //初始化值为0 int sum = 0; for (int x =1;x&lt;=5;x++)&#123; sum = sum + x;// sum += x; System.out.println(&quot;累加值为:&quot;+sum); &#125; System.out.println(&quot;sum&quot;+sum); &#125;&#125; 1-100 偶数和 12345678 // 结果：2550int s = 0; for (int x =1;x&lt;=100;x++)&#123; if (x%2 ==0)&#123; s += x; &#125; &#125; System.out.println(&quot;1-100偶数求和为：&quot;+s); 水仙花 1234567891011121314151617181920 //经典案例 水仙花数 // EG: 153 // 个位： 153%10 // 十位： 153/10%10 // 百位： 153/10/10%10int count = 0; for (int x=100;x&lt;=999;x++)&#123; int gw =x % 10; int sw =x/10 % 10; int bw =x/10/10 % 10; if ((gw*gw*gw +sw*sw*sw + bw*bw*bw )==x)&#123; System.out.println(x); count++; //统计次数 &#125; &#125;//输出统计值System.out.println(count); 1.2.8.2、while1234567891011121314151617181920212223242526272829package myOperator;/** * Created by JackFeng on 2020/2/26. */public class WhileDemo &#123; public static void main(String[] args) &#123; // 输出10次 你好 // for 实现 for (int i =1;i&lt;=10;i++)&#123; System.out.println(&quot;你好&quot;); &#125; // while 实现 int s = 1; while (s&lt;=10)&#123; System.out.println(&quot;Nihao&quot;); s++; &#125; &#125;&#125; 1.2.8.3、do…while1234567891011121314151617181920212223242526272829303132package myOperator;/** * Created by JackFeng on 2020/2/26. */public class DoWhileDemo &#123; public static void main(String[] args) &#123; // 输出10次 HI for (int i =1;i&lt;=10;i++)&#123; System.out.println(&quot;Hi&quot;); &#125; // do while 改写 int x = 1; do &#123; // 循环体语句 System.out.println(&quot;HI hi&quot;); // 控制条件语句 x++; &#125; // 判断体语句 while (x &lt;= 10); &#125;&#125; 1.2.8.4、 三种循环语句区别 A: do…while 循环至少执行一次循环体 B: for和 while 必须判断条件成立才执行循环体 123456789101112131415161718192021222324package myOperator;/** * Created by JackFeng on 2020/2/26. */public class XunDemo &#123; public static void main(String[] args) &#123; int x = 3; while(x &lt;3)&#123; System.out.println(&quot;while 循环体&quot;); x++; &#125; int y = 3; do &#123; System.out.println(&quot; do while 循环ti &quot;); y++; &#125; while (y &lt; 3); &#125;&#125; for 和 while 区别 for循环结束后，初始化变量不可被使用。 while 循环结束后，初始化变量可以被使用。 推荐使用顺序： for while do…while 12345678910111213141516171819202122 // for 和 while 的区别 public static void main(String[] args) &#123; //for for (int i = 0; i &lt;5 ; i++) &#123; System.out.println(&quot;这里是for循环&quot;); &#125;// System.out.println(&quot;i:&quot;+i); 这里是调用不了的 //while int x =0; while (x&lt;5)&#123; System.out.println(&quot;while循环&quot;); x++; &#125; System.out.println(&quot;x:&quot;+x); &#125; 1.2.9、跳转控制语句Break（中断） break：中断 使用场景： A：switch语句中 B：循环中 注意： 离开场景，将无意义。 作用： 用于结束循环 123456789101112131415161718192021222324252627package com.data.it;/** * Created by JackFeng on 2020/3/1. */public class BreakDemo &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt;4 ; i++) &#123; System.out.println(&quot;这是个正常的循环&quot;); &#125; System.out.println(&quot;============&quot;); for (int i = 0; i &lt;4 ; i++) &#123; if (i==1)&#123; break; &#125; System.out.println(&quot;这是加入break控制的循环&quot;); &#125; &#125;&#125; Continue（继续） continue：继续 使用场景： 循环中 作用： 结束一次循环，进入下一次循环。 123456789101112131415161718192021222324252627282930package com.data.it;import java.sql.SQLOutput;/** * Created by JackFeng on 2020/3/1. */public class BreakAndContinueDemo &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt;=10 ; i++) &#123;// break:结束整个循环 if (i == 2)&#123; break; &#125; System.out.println(&quot;B And C&quot;);// continue 结束本次循环，继续下一次循环 if (i==3)&#123; continue; &#125; System.out.println(&quot;C === A&quot;); &#125; &#125;&#125; 1.3、Random Random：用于产生随机数 使用步骤： A：导包 import java.util.Random; B：创建对象 Random r = new Random(); C：获取随机数 int number = r.nextInt(10) 数据范围：[0,10) 包括0，但不包括10 12345678910111213141516171819202122232425262728293031323334353637383940package com.data.it;import java.util.Random;/** * Created by JackFeng on 2020/3/1. */public class RandomDemo &#123; public static void main(String[] args) &#123; //创建对象 Random r = new Random(); // 获取随机数 int n = r.nextInt(10); System.out.println(&quot;n:&quot;+n); for (int i = 0; i &lt;10 ; i++) &#123; int num = r.nextInt(10); System.out.println(&quot;第&quot;+i+&quot;次随机数结果为：&quot;+num); &#125; // 如何获取100 - 1之间的随机数 int ii = r.nextInt(100);// [0,99] int T = r.nextInt(100)+1;// +1 即可 &#125;&#125; 猜数字游戏 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.data.it;import java.util.Random;import java.util.Scanner;/** * Created by JackFeng on 2020/3/1. *//** 猜数字游戏：* 系统产生一个 1-100 的数字，猜出这个数字是多少** 分析：* A：系统产生一个1-100之间的随机数* Random r = new Random();* int number = r.nextInt(100)+1;* B: 键盘录入要猜的数据* C: 比较这两个数据的大小* 大了：提示大了* 小了：提示小了* 相等：猜中了* D：多次猜数据，而我们不知道猜多少次？* while(true)&#123;循环体语句&#125;;*** */public class RandomNumDemo &#123; public static void main(String[] args) &#123;// 产生1-100随机数 Random r = new Random();// 获取随机数 int i = r.nextInt(100)+1;// 判断是否猜中 多次猜数据 // 录入的数据 要放在判断里 否则永远也猜不中 while (true) &#123; // 键盘录入 Scanner s = new Scanner(System.in);// 获取输入数据 System.out.println(&quot;请输入你要猜的数据：&quot;); int g = s.nextInt(); if (g&gt;i)&#123; System.out.println(&quot;你猜的&quot;+g+&quot;大了&quot;); &#125;else if (g&lt;i)&#123; System.out.println(&quot;你猜的&quot;+g+&quot;小了&quot;); &#125;else &#123; System.out.println(&quot;恭喜你猜中了&quot;); break; &#125; &#125; &#125;&#125; 1.4、数组 数组：存储同一种数据类型的多个元素的容器 取值： 数组名 【索引】 定义格式： A：数据类型[] 数组名；(推荐方式) B：数据类型 数组名[]; 案例： int[] arr; 定义int类型的数组，名称为 arr int arr[]；定义int类型的变量，变量名为arr数组 数组初始化： A：数组开辟内存空间，为数组中的每个元素赋值 B：数组初始的方式： a：动态初始化 只给出长度，系统给初始化值 b：静态初始化 给出初始值，由系统决定长度 动态初始化： 数据类型[] 数组名 = new 数据类型[数组长度]; 静态初始化： 数据类型[] 数组名 = new 数据类型[]{元素1,元素2….}; 简化格式： 数据类型[] 数组名 ={元素1，元素2,…} 动态初始化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.data.it;/** * Created by JackFeng on 2020/3/1. */public class MyArrayDemo &#123; public static void main(String[] args) &#123; //数据类型[] 数组名 = new 数据类型[数组长度]; int[] arr = new int[3]; // 释义 /* * 左边： * int：说明数组中的元素类型是 int 类型 * []: 说明是个数组 * arr： 数组名称 * * 右边： * new ： 为数组申请内存分配空间 * int： 数组中的元素是int类型 * []： 数组 * 3： 数组的长度----数组中元素的个数 * */ //输出数组名 System.out.println(&quot;arr&quot;+arr); //[I@4554617c // 获取的是地址值，如何获取数组中的元素值 // 数组中的元素都是有编号的，从0 开始，最大编号是 数组的长度-1 // 索引 arr[0] // 取值： 数组名 配合 元素编号 // 访问格式：数组名[索引] System.out.println(arr[0]); //0 System.out.println(arr[1]); // 0 System.out.println(arr[2]); //0// 赋值 arr[0] = 100; arr[2] = 200; System.out.println(&quot;=====&quot;); System.out.println(arr); // 001 System.out.println(arr[0]); //100 System.out.println(arr[1]); // 0 System.out.println(arr[2]); //200 // 指向一个数组// arr1 数组 int[] arr1 = new int[3]; System.out.println(arr1); System.out.println(arr1[0]); System.out.println(arr1[1]); System.out.println(arr1[2]); int[] arr2 = arr1; arr1[0] =111; arr1[1] =222; arr1[2] =123; System.out.println(&quot;=============&quot;); System.out.println(arr1); System.out.println(arr1[0]); System.out.println(arr1[1]); System.out.println(arr1[2]); System.out.println(arr2); System.out.println(arr2[0]); System.out.println(arr2[1]); System.out.println(arr2[2]); &#125;&#125; 静态初始化 1234567891011121314151617181920212223242526272829303132package com.data.it;/** * Created by JackFeng on 2020/3/1. */public class ArraryDemo &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;1,2,3&#125;; int[] arr1 = &#123;1, 2, 3&#125;; System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]);// System.out.println(&quot;----------&quot;); System.out.println(arr1); System.out.println(arr1[0]); System.out.println(arr1[1]); System.out.println(arr1[2]); &#125;&#125; 常见小问题 小问题： ArrayIndexOutOfBoundsException: 数组索引越界异常 原因 我们访问了不存在的索引 NullPointerException：空指针异常 原因 数组已经不在指向堆内存的数据了，还使用数组名去访问数组中的数据 数组遍历练习 123456789101112131415161718192021package com.data.it;/** * Created by JackFeng on 2020/3/1. */public class ArrayTest &#123; public static void main(String[] args) &#123; // 定义数组 int[] arr = &#123;1, 2, 3, 4, 5, 6&#125;; // 通过for循环遍历输出 ,调用 数组属性:length // 格式： 数组名.length for (int i = 0; i &lt;arr.length ; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; 取最值 思路： A：先拿数组中的一个元素做参照物 B：遍历数组，让后边所有元素依次和参照物进行比较，如果元素比参照物大，就留下 C：整个循环遍历比较，留下的就是最大值 12345678910111213141516171819202122232425262728package com.data.it;/** * Created by JackFeng on 2020/3/1. */public class ArrayTest1 &#123; public static void main(String[] args) &#123; // 取最大值 int[] arr = &#123;1, 2, 3, 55, 22, 10&#125;; // 定义一个参照值 int max = arr[0]; // 循环遍历整个数组 for (int i = 1; i &lt;arr.length ; i++) &#123; if (arr[i]&gt;max)&#123; max = arr[i]; &#125; &#125; System.out.println(&quot;最大值为：&quot;+max); &#125;&#125; 二维数组12345678910111213141516171819202122232425262728二维数组： 元素为一堆数组的数组定义格式：- A：数据类型[ ] [ ] 数组名; (推荐的方式)- B：数据类型 数组名[ ] [ ]- C：数据类型[ ] 数组名[ ]初始化：- A： 动态初始化 - 数据类型[ ] [ ] 数组名 = new 数据类型[m] [n]; - m 表示的是 二维数组中一维数组的个数 - n 表示的是 一维数组中的元素个数- B： 静态初始化 - 数据类型[ ] [ ] 数组名 = new 数据类型[ ] [ ] &#123;&#123;元素…&#125;,&#123;元素….&#125;&#125; - 简化格式： - 数据类型[ ] [ ] 数组名 = &#123;&#123;1,…&#125;,&#123;2….&#125;,&#123;3….&#125;&#125;取值：- *二维数组名配合索引可以获取到每一个一维数组* 【**arr[索引]**】- *一维数组配合索引名可以获取到数组中的元素*【**arr[索引] [索引]**】 二维数组取值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.data.it;/** * Created by JackFeng on 2020/3/1. */public class Array2Test &#123; public static void main(String[] args) &#123; //数据类型[] [] 数组名 = &#123;&#123;元素..&#125;,&#123;元素...&#125;&#125; int[][] arr = &#123;&#123;1, 2, 3&#125;, &#123;1, 3, 6&#125;, &#123;2, 3, 6&#125;&#125;; //// System.out.println(arr);// System.out.println(arr[0]);// System.out.println(arr[0][0]); // 遍历二维数组 // 第一个数组的元素 for (int i = 0; i &lt;arr[0].length ; i++) &#123; System.out.println(arr[0][i]); &#125; System.out.println(&quot;==========&quot;); // 第二个数组的元素 for (int i = 0; i &lt;arr[2].length ; i++) &#123; System.out.println(arr[0][i]); &#125; // 优化循环二维数组 System.out.println(&quot; -----------&quot;); // 二维数组 arr.length 就是有几个 一维数组 for (int i = 0; i &lt; arr.length ; i++) &#123; for (int j = 0; j &lt;arr[i].length ; j++) &#123; System.out.print(arr[i][j] + &quot; &quot;); &#125; System.out.println(&quot;====&quot;); &#125; &#125;&#125; 1.5、函数方法使用 方法： 特定功能的代码块 方法定义格式： 修饰符 返回值类型 方法名(参数类型 参数名1，参数类型 参数名2 ..){ ​ 方法体; ​ return 返回值; } 格式解释： A：修饰符 public static B：返回值类型 限定返回值的数据类型 C：方法名 方便我们调用方法的名字 D：参数类型 用于限定调用方法时传入数据的类型 E：参数名 用于接收调用方法时传入的数据变量 F： 方法体 完成功能代码 G：return 结束方法，并且把返回值带给调用者 方法明确： A：返回值类型 明确功能结果的数据类型 B：参数列表 明确有几个参数，以及参数的数据类型 方法调用：（有明确返回值的调用） A：单独调用 没有意义 B：输出调用，有意义，但是不够好(因为我想要拿结果进一步操作) C：赋值调用 方法调用：(void修饰的方法) 如果一个方法没有明确的返回值，也不能空开返回值，用void表示该方法无返回值类型 只能输出调用。 求和方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.data.it;/** * Created by JackFeng on 2020/3/1. */public class SumTest &#123; public static void main(String[] args) &#123; //调用sum// 单独调用 无意义// sum(10, 20); // 输出调用，有意义，不完美// System.out.println(sum(10,20)); // 赋值调用，常用操作。 int i = sum(10, 20); System.out.println(i); System.out.println(i+1); // 对i 进行操作 int j = sum(10,20)+10; System.out.println(j); &#125; /* * 两个明确： * 返回值： int * 参数列表： int a , int b * * * */ public static int sum(int a , int b )&#123; int c = a + b; return c; &#125;&#125; 键盘录入两个数据判断是否相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.data.it;import java.util.Scanner;/** * Created by JackFeng on 2020/3/1. */public class MethodTest &#123; public static void main(String[] args) &#123;// 创建键盘录入 Scanner sc = new Scanner(System.in);// 接收数据 System.out.println(&quot;请输入第一个数据：&quot;); int x = sc.nextInt(); System.out.println(&quot;请输入第二个数据：&quot;); int y = sc.nextInt();// 调用方法 boolean b = bijiao(x, y); System.out.println(b); &#125; /* * 求两个值是否相等： * 返回值： boolean * 参数列表： int a,int b * * */ public static boolean bijiao(int a , int b )&#123; if (a==b)&#123; return true; &#125;else &#123; return false; &#125; &#125;&#125; 水仙花数 12345678910111213141516171819202122232425262728293031323334353637383940package com.data.it;/** * Created by JackFeng on 2020/3/1. */public class MethodTest1 &#123; public static void main(String[] args) &#123; //调用方法 printFlower(); &#125; /* * 水仙花数打印到控制台方法 * * 两个参数： * 返回值类型：void * 参数列表： 无参数 * * */ public static void printFlower()&#123; for (int i = 100; i &lt;1000 ; i++) &#123; int g = i%10; int s = i/10%10; int b = i/10/10%10; if (g*g*g + s*s*s + b*b*b == i)&#123; System.out.println(i); &#125; &#125; &#125;&#125; 方法重载 方法重载： 在同一个类中，出现了方法名相同 不能出现参数名以及参数条件一致的方法 特点： 方法名相同，参数不同 参数不同 参数数量不同 参数个数不同 注意：在调用方法的时候，java虚拟机会通过参数列表的不同来区分同名的方法。 比较两个数据是否相等 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.data.it;/** * Created by JackFeng on 2020/3/1. */public class MethodTest2 &#123; public static void main(String[] args) &#123; System.out.println(compare(10,10)); System.out.println(compare(10L,10L)); System.out.println(compare((byte) 10,(byte)20)); System.out.println(compare((short) 10,(short) 20)); &#125; //byte public static boolean compare(byte a , byte b)&#123; System.out.println(&quot;byte&quot;); return a == b; &#125; //short public static boolean compare(short a , short b)&#123; System.out.println(&quot;short&quot;); return a == b; &#125; //int public static boolean compare(int a , int b)&#123; System.out.println(&quot;int&quot;); return a == b; &#125; //long public static boolean compare(long a , long b)&#123; System.out.println(&quot;long&quot;); return a == b; &#125;&#125; 形式参数 如果方法的参数是基本数据类型： ​ 形式参数的改变不影响实际参数 如果方法的参数是引用数据类型： ​ 形式参数的改变直接影响实际参数 数组遍历 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.data.it;/** * Created by JackFeng on 2020/3/1. */public class ArrayDo &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 3, 4, 5&#125;; System.out.println(&quot;第一种方式&quot;); printArray(arr); System.out.println(&quot;第二种方式&quot;); printArray1(arr); &#125; /* * 两个明确： * 返回类型： void * 参数列表： int[] arr * */ public static void printArray(int[] arr)&#123; for (int i = 0; i &lt;arr.length ; i++) &#123; System.out.println(arr[i]); &#125; &#125; public static void printArray1(int[] arr)&#123; // 输出为这样的 [1,2,3,4,5] System.out.print(&quot;[&quot;); for (int i = 0; i &lt;arr.length ; i++) &#123; if (i==arr.length-1)&#123; System.out.println(arr[i]+&quot;]&quot;); &#125;else &#123; System.out.print(arr[i]+&quot;, &quot;); &#125; &#125; &#125;&#125; 1.6、断点调试 断点调试的作用： ​ A： 查看程序的执行流程 ​ B： 调试程序 断点： ​ – 标记 哪里需要点哪里 需加在有效的地方 1.7、基础练习不死神兔计算 123456789101112131415161718192021222324252627package myTest;/** * Created by JackFeng on 2020/3/1. */public class Test &#123; public static void main(String[] args) &#123; // 20个月 兔子的对数 // 1,1,2,3,5....// 定义数组 int[] arr = new int[20]; // 给数组赋值 arr[0] = 1; arr[1] = 1; // 找规律赋值 for (int i = 2; i &lt;arr.length ; i++) &#123; arr[i] = arr[i - 1] + arr[i - 2]; &#125; //输出结果 System.out.println(&quot;第20个月兔子的对数是：&quot;+arr[19]); &#125;&#125; 评委评分 需求： ​ 在编程竞赛中，有6个评委为参赛选手打分，分数为0-100的整数分。 ​ 选手最后的得分为，去掉一个最高分与最低分，剩下4个评委的平均值 分析： A：定义一个长度为6的数组 B：键盘录入评委的分数 C：写方法实现最高分、最低分 D：写方法求评委分数和 E：平均分：（和-最高分-最低分）/（arr.length-2） F：输出平均分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package myTest;import java.util.Scanner;/** * Created by JackFeng on 2020/3/2. */public class Test1 &#123; public static void main(String[] args) &#123; //定义数组 int[] arr = new int[6]; //键盘录入 Scanner sc = new Scanner(System.in); //键盘录入评委分数 for (int i = 0; i &lt;arr.length ; i++) &#123; //接受数据 System.out.println(&quot;请输入第 &quot;+(i+1)+&quot;个评委给出的分数&quot;); int score = sc.nextInt(); arr[i] = score; &#125; //调用方法 int max = getMax(arr); int min = getMin(arr); int sum = sum(arr); // 求平均分 int avg = (sum - max - min) / (arr.length - 2); System.out.println(&quot;该选手的最终得分是：&quot;+avg); &#125; //最高分 /* * 两个明确： * 返回值类型： int * 参数列表： int [] arr * * * */ public static int getMax(int[] arr)&#123; //定义参照物 int max = arr[0]; for (int i = 1; i &lt;arr.length ; i++) &#123; if (arr[i]&gt;max)&#123; max = arr[i]; &#125; &#125; return max; &#125; // 最低分 public static int getMin(int[] arr)&#123; //定义参照物 int min = arr[0]; for (int i = 1; i &lt;arr.length ; i++) &#123; if (arr[i]&lt;min)&#123; min = arr[i]; &#125; &#125; return min; &#125; // 求和 public static int sum(int[] arr)&#123; // 定义求和变量 int sum = 0; for (int i = 0; i &lt;arr.length ; i++) &#123; sum += arr[i]; &#125; return sum; &#125;&#125; 键入数组反转 需求： 1、键盘录入5个int的数据存在arr中 2、定义方法将arr数组中的内容反转 3、定义方法对反转后的数组进行遍历 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package myTest;import java.util.Scanner;/** * Created by JackFeng on 2020/3/2. */public class Test2 &#123; public static void main(String[] args) &#123; int[] arr = new int[5]; Scanner sc = new Scanner(System.in); for (int i = 0; i &lt;arr.length ; i++) &#123; System.out.println(&quot;请输入&quot;+(i+1)+&quot;个元素值：&quot;); int number = sc.nextInt(); arr[i] = number; &#125; printArray(arr); // 反转 arr reverse(arr); System.out.println(&quot;反转后&quot;); printArray(arr); &#125; //遍历数组 public static void printArray(int[] arr)&#123; System.out.print(&quot;[&quot;); for (int i = 0; i &lt;arr.length ; i++) &#123; if (i==arr.length-1)&#123; System.out.println(arr[i]+&quot;]&quot;); &#125;else&#123; System.out.print(arr[i]+&quot;, &quot;); &#125; &#125; &#125; // 反转数组 public static void reverse(int[] arr)&#123; for(int start =0, end= arr.length-1; start&lt;=end;start++,end--)&#123; int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"}]},{"title":"Java环境","slug":"Java/JavaSE/Java环境","date":"2020-05-07T15:53:40.000Z","updated":"2020-09-18T02:25:50.991Z","comments":true,"path":"posts/17415.html","link":"","permalink":"http://www.a2data.cn/posts/17415.html","excerpt":"Java JDK 环境安装","text":"Java JDK 环境安装 Java环境 程序编译和运行需要使用 javaJDK 下的bin目录 环境变量配置： JAVA_HOME —— jdk安装目录 Path环境 —— %JAVA_HOME%\\bin JVM: JAVA虚拟机 JRE: JAVA运行环境 JDK: 开发环境 JDK包含JER包含JVM 1、Win10环境 Win10下 Java环境变量配置 首先，你应该已经安装了 Java 的 JDK 了！！！ 如果没有安装JDK，请跳转到此网址：http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html） 笔者安装的是 jdk-1.8.0_151-windows-x64 接下来主要讲怎么配置 Java 的环境变量，也是为了以后哪天自己忘记了做个备份！！ 注：win10的环境变量配置和其他的windows版本稍有不同 2、环境变量在电脑桌面 右键点击 “此电脑”的“属性”选项 选择“高级系统设置”选项 点击下面的“环境变量”选项 接下来就是具体的配置过程： 点击“系统变量”下面的”新建“选项 在”变量名“处填上”Java_Home“ 变量值“为JDK安装路径，路径自定义: D:\\Program Files\\Java\\jdk1.8.0_151 点击”确定“选项 在”系统变量“中找到”Path“ 选中”Path“点击”编辑“选项 3、添加变量 选择右边的“新建”，将引号里面的分别复制添加“%Java_Home%\\bin;%Java_Home%\\jre\\bin;” 点击“环境变量”最下面的“确定”选项 回到电脑桌面，按快捷键“Win+R”，输入“cmd” 检查Java环境是否配置成功 输入 java -verison 4、环境配置成功 如上图所示，恭喜你，环境变量就配置好了。 为了敏捷开发，小编建议 安装IDEA，并且2020版本支持中文。 有了好的环境，才能更好的学习。小编也会补充上基础得学习教程。 一起加油吧 ！！！","categories":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.a2data.cn/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"}]},{"title":"最快图床搭建","slug":"Tools/最快图床搭建","date":"2020-05-05T17:09:54.000Z","updated":"2020-09-18T02:25:54.725Z","comments":true,"path":"posts/36204.html","link":"","permalink":"http://www.a2data.cn/posts/36204.html","excerpt":"最快的图床搭建，有坑请联系小编。","text":"最快的图床搭建，有坑请联系小编。 PicGo1、安装PicGoGitHub地址 https://github.com/Molunerfinn/PicGo/releases 访问 PicGo选择 PicGo-Setup-XXX.exe下载软件安装包（GitHub直接下载速度会有些慢甚至无法完成下载，可选择使用迅雷下载，亲测有用） 或者联系小编，小编有 微云+ 百度云高效连接。 2、安装选项 安装软件时选择仅为我安装，另外注意不要安装在C盘 安装node.js：点击 nodejs 下载完安装包后进行安装，除了更改安装位置外，一路默认完成安装即可 更换镜像源：进入命令行执行以下命令 npm config set registry https://registry.npm.taobao.org 3、安装完成 Gitee1、打开PicGo运行软件打开插件设置搜索gitHub，安装github-plus插件 2、创建Gitee图床仓库 https://gitee.com/DataITems/cdn.git 创建仓库时务必要勾选一个初始化选项初始化仓库，否则后面上传时会失败 3、创建私人令牌私人令牌：https://gitee.com/profile/personal_access_tokens/new 生成成功如下： 4、 设置GithubPlus返回PicGO，点击图床设置-&gt; githubPlus ，填写repo，token和origin三项，token填写为上一步生成的token，origin选择gitee，repo填写为sqlsq_admin/cdn Typora 熟悉的都知道，这个记事本我推荐了好多次了。 并且也自己魔改了一些css样式。目前小编最钟爱的编辑器。 完成以上操作即可正常使用你的PicGo了，如果你还经常使用typora的话可以继续设置你的typora 1、配置图片 2、上传配置 建议开启 优先使用相对路径。 这样可以预览！ 3、体验极速上传吧 推荐图床： 别问小编为什么，因为我穷付费的都用不起。 Github 免费 有时候容易失败 GithubPlus — Gitee 免费 高效 快捷 上传 上传成功 4、完美 至于图床的更多便捷就不一 一诉说了。","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.a2data.cn/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"图床","slug":"图床","permalink":"http://www.a2data.cn/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"Redis","slug":"DataBase/Redis/Redis","date":"2020-05-05T16:47:18.000Z","updated":"2020-09-11T08:32:25.266Z","comments":true,"path":"posts/bae4ff13.html","link":"","permalink":"http://www.a2data.cn/posts/bae4ff13.html","excerpt":"详细说明Redis的安装。","text":"详细说明Redis的安装。 Redis安装 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 1、下载 1234567windows版本： https://github.com/MSOpenTech/redis/releasesLinux版本： 官网下载： http://www.redis.cn/ git下载 https://github.com/antirez/redis/releases 我们现在讨论的是windows下的安装部署，目前windows下最新版本是：3.2.100。 下载地址，提供多种下载内容，Redis-x64-3.2.100.msi是在windows下，最简单的安装文件，方便，直接会将Redis写入windows服务。Redis-x64-3.2.100.zip是需要解压安装的，接下来讨论的是这种。Source code (zip) 源码的zip压缩版Source code (tar.gz) 源码的tar.gz压缩版 2、安装以 Redis-x64-3.2.100.msi 为例，下载之后运行 3、启动 通过cmd指定到该redis目录。使用命令：redis-server.exe 启动服务 或者到对应目录启动即可。 4、使用 参考安装完之后的生成文档 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071如果您使用MSI包安装了Redis，那么Redis已经作为Windows服务安装了。没有别的事可做。如果您想要更改它的设置，您可以更新Redis .windows-service.conf文件，然后重新启动Redis服务(运行-&gt;服务。msc -&gt; Redis -&gt;重启)。在安装MSI期间，您可以使用安装程序的用户界面来更新Redis监听的端口和防火墙异常，或者在没有UI的情况下静默运行它。下面的例子展示了如何从命令行安装:default install (port 6379 and firewall exception ON): msiexec /i Redis-Windows-x64.msi set port and turn OFF firewall exception: msiexec /i Redis-Windows-x64.msi PORT=1234 ADD_FIREWALL_RULE=&quot;&quot;set port and turn ON firewall exception: msiexec /i Redis-Windows-x64.msi PORT=1234 ADD_FIREWALL_RULE =1install with no user interface: msiexec /quiet /i Redis-Windows-x64.msi如果您没有使用MSI包安装Redis，那么您仍然可以按照以下说明运行Redis作为Windows服务:为了更好地与Windows服务模型集成，在Redis中引入了新的命令行参数。这些服务参数需要一个提升的用户上下文，以便连接到服务控制管理器。如果这些命令是从非提升的上下文调用的，那么Redis将尝试创建一个提升的上下文来执行这些命令。这将导致一个用户帐户控制对话框显示在窗口，并可能需要Admini#安装服务这必须是redis-server命令行的第一个参数。参数按服务启动时发生在Redis中的顺序传递。该服务将被配置为自动启动，并将作为“NT AUTHORITY\\NetworkService”启动。安装成功后，将显示一条成功消息，Redis将退出。此命令不启动服务。#例如：redis-server --service-install redis.windows-service.conf --loglevel verbose#卸载服务--service-uninstall这将从注册表中删除Redis服务配置信息。卸载成功后，将显示一条成功消息，Redis将退出。这并不命令不停止服务。#例如redis-server --service-uninstallStarting the Service--service-start这将启动Redis服务。成功启动后，将显示一条成功消息并开始运行Redis。#例如redis-server --service-startStopping the Service--service-stop这将停止Redis服务。成功终止后，将显示一条成功消息，Redis将退出。#例如redis-server --service-stop#命令服务--service-name name此可选参数可与前面的任何命令一起使用，以设置安装的服务的名称。该参数应该位于service-install、service-start、service-stop或service-uninstall命令之后，并位于通过service-install命令传递给Redis的任何参数之前。下面将安装并启动三个独立的Redis服务实例:redis-server --service-install --service-name redisService1 --port 10001redis-server --service-start --service-name redisService1redis-server --service-install --service-name redisService2 --port 10002redis-server --service-start --service-name redisService2redis-server --service-install --service-name redisService3 --port 10003redis-server --service-start --service-name redisService3# 测试启动服务redis-server --service-start客户端命令：精简模式：redis-cli.exe指定模式：redis-cli.exe -h 127.0.0.1 -p 6379 -a requirepass(-h 服务器地址 -p 指定端口号 -a 连接数据库的密码[可以在redis.windows.conf中配置]，默认无密码) 5、Redis工具 Redis Desktop Manager https://redisdesktop.com/pricing 注意：Redis支持多个数据库，并且每个数据库的数据是隔离的不能共享，并且基于单机才有，如果是集群就没有数据库的概念。 Redis是一个字典结构的存储服务器，而实际上一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。 每个数据库对外都是一个从0开始的递增数字命名，Redis默认支持16个数据库（可以通过配置文件支持更多，无上限），可以通过配置databases来修改这一数字。客户端与Redis建立连接后会自动选择0号数据库，不过可以随时使用SELECT命令更换数据库。","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.a2data.cn/categories/DataBase/"},{"name":"Redis","slug":"DataBase/Redis","permalink":"http://www.a2data.cn/categories/DataBase/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://www.a2data.cn/tags/Redis/"}]},{"title":"1.DBeaver安装","slug":"DataBase/1.DBeaver安装","date":"2020-05-05T16:46:01.000Z","updated":"2020-09-18T02:25:53.512Z","comments":true,"path":"posts/773d5f8c.html","link":"","permalink":"http://www.a2data.cn/posts/773d5f8c.html","excerpt":"DBeaver安装步骤","text":"DBeaver安装步骤 DBeaver1、下载 官方链接：https://dbeaver.io/ 2、安装 双击打开应用程序。只需要更改存储位置即可。 3、新建 4、下载驱动文件 5、 链接数据库 6、测试链接 7、更改主题 根据自己爱好设定。 8、查询数据","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.a2data.cn/categories/DataBase/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.a2data.cn/tags/Mysql/"},{"name":"数据库工具","slug":"数据库工具","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B7%A5%E5%85%B7/"}]},{"title":"大数据集群","slug":"Hadoop/大数据集群","date":"2020-05-05T16:41:07.000Z","updated":"2020-09-18T02:25:54.571Z","comments":true,"path":"posts/9e565f9f.html","link":"","permalink":"http://www.a2data.cn/posts/9e565f9f.html","excerpt":"快速搭建Hadoop集群","text":"快速搭建Hadoop集群 VM安装0、下载 VMware Workstation Pro 确立了在单台 Linux 或 Windows PC 上运行多个操作系统的行业标准。 Workstation 15.5 Pro 通过提供全新的用户界面控件，支持巨型帧以及最新的 Windows 和 Linux 操作系统等，进一步完善了领先的桌面… 链接直达： https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html 1、以管理员身份运行找到下载的程序，右击 2、下一步 3、接收协议 4、更改安装目录 5、安装 点击下一步，点击安装 6、完成 许可证激活密钥 UY758-0RXEQ-M81WP-8ZM7Z-Y3HDA VM使用0、启动 1、更改存储位置 2、更改共享位置 3、虚拟网络 虚拟机网络相关配置 详细设置 cloudera cloudera-quickstart-vm-5.13.0-0-vmware （目前已经不可下载） https://www.cloudera.com/products/open-source/apache-hadoop/key-cdh-components.html VM快速学习 目前最高版本是 5.16 https://docs.cloudera.com/documentation/enterprise/5-16-x/topics/cloudera_quickstart_vm.html 1、导入虚拟机 2、编辑虚拟机设置 最低配置： **4G，4G ，4G **—- 4G 1cores 64GB 小编配置： 8G 2cores 64GB 3、开启虚拟机 4、成功启动 等候片刻，根据机器配置来讲，成功创建。如下图 5、更改IPcentos ip更改 默认值： 12345678910111213DEVICE=&quot;eth0&quot;BOOTPROTO=&quot;dhcp&quot;DHCP_HOSTNAME=&quot;quickstart.cloudera&quot;HOSTNAME=&quot;quickstart.cloudera&quot;HWADDR=&quot;00:0C:29:D3:4D:5C&quot;IPV6INIT=&quot;no&quot;MTU=&quot;1500&quot;NM_CONTROLLED=&quot;yes&quot;ONBOOT=&quot;yes&quot;TYPE=&quot;Ethernet&quot;UUID=&quot;f127faf3-7a1f-4bca-a404-0119665a8459&quot; 注意：使用sudo 12sudo vim /etc/sysconfig/network-scripts/ifcfg-eth0 修改为: 1234567891011121314DEVICE=&quot;eth0&quot;BOOTPROTO=&quot;static&quot;DHCP_HOSTNAME=&quot;quickstart.cloudera&quot;HOSTNAME=&quot;quickstart.cloudera&quot;HWADDR=&quot;00:0C:29:D3:4D:5C&quot;IPV6INIT=&quot;no&quot;MTU=&quot;1500&quot;NM_CONTROLLED=&quot;yes&quot;ONBOOT=&quot;yes&quot;TYPE=&quot;Ethernet&quot;UUID=&quot;f127faf3-7a1f-4bca-a404-0119665a8459&quot;IPADDR=192.168.6.6NETMASK=255.255.255.0 重新启动即可: sudo service network restart 6、启动异常解决方案异常解决 重新添加网卡 复制MAC地址： 更改： DEVICE = eth2 HWADDR —- 为你的地址值 再次重新启动 1234561.重启服务sudo service network restart2.查看ipip addr/ifconfig MobaXterm1、安装MobaXterm https://mobaxterm.mobatek.net/download-home-edition.html 2、启动 3、配置 4、登录 输入密码，保存。 5、查看 相关安装包，请联系小编获取。 欢迎访问 小编博客 ： www.a2data.cn全力打造 SQL社区： www.sqlsq.cn","categories":[{"name":"大数据","slug":"大数据","permalink":"http://www.a2data.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://www.a2data.cn/tags/Hadoop/"}]},{"title":"Linux 正则表达式","slug":"Linux/Linux-正则表达式","date":"2020-04-25T11:14:43.000Z","updated":"2020-09-11T08:45:25.871Z","comments":true,"path":"posts/47985.html","link":"","permalink":"http://www.a2data.cn/posts/47985.html","excerpt":"正则表达式相关","text":"正则表达式相关 正则表达式 是指用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。就是用某种模式去匹配一类字符串的一个公式。 1234touch bb.txtgrep “m*” bb.txt 基本元字符集grep -E = egrep · 匹配任意单个字符。 如：rat、r、t。 ^ 匹配一行的开始 $ 匹配一行的结尾 匹配0个或多个前面的字符 + 匹配1个或者多个+前面的字符（需要\\号，如grep -E “11+” /root/2） ? 匹配0个或1个？之前的字符 \\ 转义 []匹配括号中的任何一个字符。如：[abc] [^] 匹配不在括号中的，表示排除 如[^abc]或者 grep -v [abc] &lt; 匹配词的开始 &gt; 匹配词的结束。 如 &lt;the&gt;\\。 | 或。 例如 （him|her） {m} 前面的表达式重复m次。如：“\\w{2}”相当于“\\w\\w”。 {m,n} 表达式至少重复m次，做多重复n次。如：“ba{1,3}”匹配“ba”或“baa”“baaa” “d{2,3}” {m，} 表达式至少重复m次 \\w 任意一个字母或数字或下划线 \\d 任意一个数字 grep [0-9] bb.txt \\s 空格、制表符、换页符、空白符中的任意的一个。 \\b 匹配一个单词的边界。如：“.\\b.” 以什么开头放后边 以什么结尾放前边 环境支持 命令或环境 · [] ^ $ ( ) { } ? + | ( ) vi × × × × × awk × × × × × × × × sed × × × × × × grep × × × × × × egrep × × × × × × × × × perl × × × × × × × × ×","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux Shell语法","slug":"Linux/Linux-Shell语法","date":"2020-04-25T11:14:22.000Z","updated":"2020-09-11T08:45:25.893Z","comments":true,"path":"posts/64423.html","link":"","permalink":"http://www.a2data.cn/posts/64423.html","excerpt":"Linux Shell 语言得一些基本语法。","text":"Linux Shell 语言得一些基本语法。 Shell语法If语句格式 (number=num) 1234567891011121314151617181920read -p &quot;请输入一个数字&quot; num if [ $num -eq 3 ] （如果）then echo &quot;wo xiang ni&quot;elif [ $num -le 5 ] then （然后） echo &quot;zhen xiang le &quot;else [ $num -ge 6 ] （否则） echo &quot;miss 531&quot;fi （结束） 闰年第一版 123456789101112131415161718192021222324252627282930year=`date +%Y`if [ $[ $year % 400 ] -eq 0 ]thenecho &quot;$year is a leap year.&quot;elif [ $[ $year % 4 ] -eq 0 ]thenif [ $[ $year % 100 ] -ne 0 ]thenecho &quot;$year is a leap year.&quot;elseecho &quot;$year is not a leap year.&quot;fielseecho &quot;$year is not a leap year.&quot;fi 第二版（原版） 123456789101112131415161718192021222324252627282930year=$(date +%Y)if [ $[ $year % 400 ] -eq 0 ]thenecho &quot;$year is a leap year.&quot;elif [ $[ $year % 4 ] -eq 0 ]thenif [ $[ $year % 100 ] -ne 0 ]thenecho &quot;$year is a leap year.&quot;elseecho &quot;$year is not a leap year.&quot;fielseecho &quot;$year is not a leap year.&quot;fi 第三版（查询哪一年是闰年） 123456789101112131415161718192021222324252627282930read -p &quot;shu ru nian fen&quot; yearif [ $[ $year % 400 ] -eq 0 ]thenecho &quot;$year is a leap year.&quot;elif [ $[ $year % 4 ] -eq 0 ]thenif [ $[ $year % 100 ] -ne 0 ]thenecho &quot;$year is a leap year.&quot;elseecho &quot;$year is not a leap year.&quot;fielseecho &quot;$year is not a leap year.&quot;fi FOR 循环 格式语法：for NAME in [ LIST ];do COMMANDS; done ​ 列表 执行命令 结束 LIST用法 直接写 1 2 3 大括号 {1..5} 文件名 /etc/*.conf 命令结果 find /etc/ -name “*.conf” C语言风格 for ((i=0;i&lt;5 i=i+2)) i++ ping网段案例ping.sh 12345678910111213141516171819202122for p in &#123;1..10&#125; p---变量名称do do----执行内容host=(192.168.18.$p)ping -c2 192.168.18.$p &gt;&gt; /root/Desktop/2.txt c2---频率if [ $? == 0 ]thenecho &quot;$host is online.&quot; 在线elseecho &quot;$host is offline.&quot; 不在线fidone while循环123456789101112aa=1while [ $aa -le 10 ]doecho &quot;wo xiang ni le&quot;aa=$[$aa+1]done case 判断123456789101112131415161718aa=3 ( 3 变量值）case &quot;$aa&quot; in 1) echo &quot;haha&quot;;; （1,2,4常量值） 2) echo &quot;heihei&quot;;; 3) echo &quot;nimei&quot;;; （有内容两；没有一个；）esac break 终止当前for循环 12345678910111213141516for n in &#123;1..10&#125;do if [ $n -eq 3 ] then break fi echo $ndone continue 跳出本次循环 12345678910111213141516for n in &#123;1..10&#125;do if [ $n -eq 3 ] then continue fi echo $ndone","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux Shell脚本","slug":"Linux/Linux-Shell脚本","date":"2020-04-25T11:14:07.000Z","updated":"2020-09-11T08:45:25.875Z","comments":true,"path":"posts/43857.html","link":"","permalink":"http://www.a2data.cn/posts/43857.html","excerpt":"Linux Shell脚本相关学习。","text":"Linux Shell脚本相关学习。 Shell:操作系统与用户进行交互操作的界面，提供脚本语言编程环境，方便用户自动批量处理大量的工作任务。 红帽企业版linux一般默认的Shell是bash shell。 shell脚本 Shell:操作系统与用户进行交互操作的界面，提供脚本语言编程环境，方便用户自动批量处理大量的工作任务。 红帽企业版linux一般默认的Shell是bash shell。 123456789101112131415vim aa.sh #编辑aa脚本cd /root/Desktop #切换到root下的桌面mkdir aa #创建aa目录touch aa/aa.txt #在aa目录下创建aa.txtsh aa.sh #运行aa.sh脚本echo $$ 查看当前进程号 bash 进入另一个shellexit 退出 history 历史 语法 替换 ！！ 前一个命令 ！n 命令号n ！-n 倒数第n个命令 ！cmd 最后用来启动cmd的命令 多命令运行123456789#！/bin/sh 注释信息，可写可不写echo $? 返回值：通过$?变量进行查看，返回0成功，不成功则返回非0值！有条件的链接命令&amp;&amp; 把两个命令链接在一起，只有第一个命令成功执行时，才会执行第二个命令。|| 把两个命令链接在一起，只有第一个命令失败时，才会执行第二个命令。 Bash变量123例如：aa=DataScienceecho $aa 则会显示DataScience Shell变量1234567891011121314151617181920212223A和B A=123 B=234echo a:$A b:$B 显示AB变量内容a：123 b：234export A 将A变量提升为环境变量bashpsecho a:$A b:$B---- 启动一个bash ，通过ps运行，确定有俩个shell在运行；父shell（B），子shell（A）由于被提升为一个环境变量，A shell从B shell中继承了它，相反，A shell对B shell的变量B一无所知。Bshell 属于sleep状态。结果如下a：123 ：b：exit echo a:$A b:$B 退出再次查看 a：123 b：234unset A B----- 取消环境变量A和shell变量 B 命令替换 替换 语法 含义 历史（history） ！ 前一个命令行 大括号（Brace） {} 指定的文本 代字号（Tilde） ~username 用户的主目录 变量 $,${…} Shell和环境变量 算数（Arithmetic） $((…)) 算数运算 命令替换 ‘…’，$(…) 运行在字shell中的命令的输出 路径名（Pathname） [^…*]?,[…] 文件系统中匹配的文件名 1234mkdir chap&#123;a1,a2,a3,a4,&#125;/&#123;bb,cc&#125; 需要先创建&#123;a1,a2,a3,a4&#125;mkdir -p &#123;a1,a2,a3,a4,&#125;/&#123;bb,cc&#125; 算法123456789101112a=123 b=234echo $(($a+$b)) ----- a+b357 ---------- 结果2、计算器Scale=2 保留几位小数, %取余。Quit 退出计算器 \\;反斜杠 转义字符 创建时间文档123date +%Y%m%d 语法 作用 \\ 避免下一个字符被shell解释 “” 避免双引号内除了S、！和（反引号）字符以外的其它字符被shell解释 ‘’ 避免单引号内的字符被shell解释 12345678alias 命令 Shell别名可创建扩展（替换）为任意文本的命令alias NAME=aunalias 取消 unalias a 取消a替换NAME的命令 标准输入 标准输出123456789101112131415161718192021222324echo “aaa”&gt; aa.txt 创建aa.txt文档cat aa.txt 查看aa.txt文档设置密码（可批量设置用户密码）useradd u1 创建u1用户passwd u1 设置u1 密码useradd u2 创建u2用户vim bb.txt 新建立一个bb.txt文档123456 将密码输入 bb.txt文档中passwd u2 --stdin &lt; bb.txt 将输入定向到文档中su - u1 切换到u1su - u2 切换到u2输入密码 123456 标准输出和错误输出123456789101112131415161718echo “aaabbccc”&gt;aa.txt&gt;&gt;文件续写echo “aaabbbcc”&gt;&gt;aa.txt意思是用&gt;把内容输入到文档中。head -1 /etc/rc.d/\\* &gt; aa.txt 2&gt;bb.txt 将标准输出和错误输出分别传到aa.txt和bb.txthead -1 /etc/re.d/\\* &gt;aa.txt 2&gt;&amp;1 head -1 /etc/rc.d/\\* &gt;&amp; aa.txt将标准输出和错误输出合并到aa.txt Shell scripts scripts脚本返回值 echo $? 返回值 退出状态 0（Zero） Success Non-zero Failure 2 Incorrect usage 126 Not an executable 127 Command not found 1234567vim aa.sh 编辑aa.sh脚本read -p &quot;qing shu ru yong hu ming cheng &quot; nameecho $namesh aa.sh 运行aa，name脚本 只读变量 变量 含义 ？ 最新执行的命令的退出状态 - 当前启用中的shell选项标记 $ 当前shell的进程id（PID） ！ 最新后台命令的进程ID（pid） _ 前一个命令的最后标记 PPID shell父进程的ID（PID） SHELLOPTS 被冒号隔开的当前启用中的shell选项列表，和set -o命令结果一样 UID 当前用户的用户id 路径替换 ~ */? []/[^] &amp; 比较–针对文件 关于文件类型的判断，如：test -e filename -e 是否存在 -f 是否为文件 -d 是否为目录 -b 是否为block device -c 是否为character device -S 是否为socket -p 是否为pipe文件 -L 是否为链接 比较–权限 关于文件权限的判断，如：test -r filename -r 文件是否可读 -w 文件是否可写 -x 文件是否可执行 -u 文件是否有SUID -g 文件是否有SGID -k 文件是否有Sticky bit -s 文件是否非空 比较–新旧与大小 比较两个文件大小，命令 例如： test A -nt B -nt A是否比B新 -ot A是否比B旧 -ef A是否和B是用一个文件，两个整数之间的判断。 -eq 两个数相等 -ne 两个数不等 -gt A大于B -lt A小于B -ge A大于等于B -le A小于等于B","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux系统监控","slug":"Linux/Linux系统监控","date":"2020-04-25T11:13:45.000Z","updated":"2020-09-11T08:45:25.895Z","comments":true,"path":"posts/10537.html","link":"","permalink":"http://www.a2data.cn/posts/10537.html","excerpt":"Linux 系统监控篇。","text":"Linux 系统监控篇。 系统监控PS 进程监控 ps工具标识进程的5种状态码 D 不可中断 uninterruptible sleep(usually IO) R 运行 runnable (on run queue) S 中断 sleeping T 停止 traced or stopped Z 僵死 a defunct (“zombie”) process 使用方法 ps [options] [–help] ps 的参数 -A 列出所有的行程 -w 显示加宽可以显示较多的资讯 -au 显示较详细的资讯 -aux 显示所有包含其他使用者的行程 总述 标识 释义 USER 行程所拥有者 PID pid %CPU 占用cpu使用率 %MEM 占用的记忆体使用率 VSZ 占用的虚拟机体大小 RSS 占用的记忆体大小 TTY 终端的次要装置号码 COMMAND 所执行的指令 top动态监控系统进程 TOP动态 第一行任务队列信息 - 01:06:08 当前时间 1 user 当前登录用户数 第二、三行 进程和cpu Tasks：158total 进程总数 最后两行为内存信息 Mem：191272k total 物理内存总数 COMMAND 命令名/命令行 SAR 系统活动情况报告 指令软件包：sysstat-7.0.3-3.el5.i386mp sar 命令常用格式 sar [options][-A][-o file]t[n] 其中：t：采样间隔 n 采样次数 默认值为1. options未明朗行选项，sar常用选项如下： -o file 表示将命令结果以二进制格式存放在文件中 -A 所有报告的总和 -u 输出cpu使用情况的统计 -v 输出inode、文件和其他内核表的统计信息 -d 输出每一个块设备的活动信息 -r 输出内存和交换空间的统计信息 -b 显示l/O和传送速率的统计信息 -a 文件读写情况 -c 输出进程统计信息，每秒创建的进程数 -R 输出内存页面的统计信息 -y 终端设备活动情况 -w 输出系统交换活动信息 vmstat监控工具 vmstat 2 10 每隔两秒采集10次 r—表示运行队列 b—表示阻塞的进程 swap—-虚拟内存已经使用的大小 si—-每秒从磁盘读入虚拟内存的大小 sp—每秒虚拟内存写入磁盘的大小 in—-每秒cpu的中断次数 sy—-系统cpu时间 id—-空闲cpu时间 wt—–等等lO cpu 时间 iostat 主要可以显示cpu和1/O系统的负载情况及分区状态信息 直接执行iostat lsof 主要查看端口 lsof -i 22 查看端口为22 的服务 losf -g gid 显示归属gid的进程情况 lsof -i 用以显示符合条件的进程情况 echo $$ 当前进程号 kill -9 5641 杀死（结束）5641进程 strace 跟踪进程执行时的系统调用和所接受的信号。 Find 详解 常见用法 -name filenname #查找名为filename的文档 -perm #按执行权限来查找 -user username #按文档属主来查找 -group groupname #按组来查找 -mtime -n +n #按文档更改时间来查找文档 -n指n天以内，+n指n天以前 -group groupname #按组来查找 -type b/d/c/p/l/f #查是块设备、目录、字符设备、管道、符号链接、普通文档 -size n[C] #查长度为n块[或n字节]的文档 -prune #忽略某个目录","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux NFS网络文件","slug":"Linux/Linux-NFS网络文件","date":"2020-04-25T11:13:31.000Z","updated":"2020-09-11T08:45:25.873Z","comments":true,"path":"posts/10415.html","link":"","permalink":"http://www.a2data.cn/posts/10415.html","excerpt":"Linux 手把手教你搭建NFS网络文件系统。","text":"Linux 手把手教你搭建NFS网络文件系统。 NFS网络文件系统 1.功能：文件共享 2.协议与端口： 需要RPC进行控制 NFS安装12yum install nfs-utils protmap（端口分放） 服务机 ip 2211234567891011121314vim /etc/exports （配置文件）/aa 192.168.18.220/255.255.255.0(rw)根下aa 共享（客户机）ip/子掩网码 rw 读写 ro 只读cd / 切换到根下mkdir aa 创建aa目录touch aa/abc.txt 创建aa下abc文档service nfs restart 重启nfs服务 客户机 ip 220123456789101112131415161718192021222324252627showmount -e 192.168.18.221cd /mkdir pub 创建pub 文件mount 192.168.18.220:/aa pub 挂载到aa/pub切换到服务机 更改权属 ll -d aa 查看aa权限 chmod o+w aa 修改aa权限（o 其他人）service nfs restart 重启服务切换到客户机 cd pub/vim abc.txt 修改touch aa.txt 创建一个文件切换到服务机cd aa ls aa 查看是否有文件 配置Sambasamba 软件包 samba.i386 : The Samba SMB server. samba-client.i386 : Samba (SMB) client programs. samba-common.i386 : Files used by both Samba servers and clients. 安装samba 123456789101112mount /dev/cdrom /mnt 挂载切换到挂载目录进行配置cd /mnt/Server/ vim /etc/yum.repos.d/qq.repor /etc/yum.repos.d/rhel-debuginfo.repoyum -y install samba 编辑文件1234cd /etc/samba/ 切换vim smb.conf 配置文件 1234567vim /etc/samba/smb.confsecurity=share ---共享找见[public] 7yy 复制7行 p 粘贴 修改1234567891011[aa] --- 这是昵称comment = nidaye ---注释信息path = /aa ---要共享的目录public = yes ---公共的匿名用户可以访问的writeable = yes ---可被写browseable = yes ---可被浏览 查看123456cd / ls mdkir qq 返回根下查看 创建qq文件 cd qq touch aa.txt 切换到qq下创建aa文档service smb restart 重启smb服务 修改文件权限12341、 chmod o+w /aa 2、 cd /aa chmod 777\\* Linux客户端 smbclient -L //192.168.18.221—查看共享信息 smbclient //192.168.18.221/share-进入共享目录 ? 查看有哪些命令可以使用 ls 查看共享目录下有哪些内容 windows客户端 \\192.168.18.221 —可以看到共享目录","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux Apache论坛","slug":"Linux/Linux-Apache论坛","date":"2020-04-25T11:13:14.000Z","updated":"2020-09-11T08:45:25.896Z","comments":true,"path":"posts/41055.html","link":"","permalink":"http://www.a2data.cn/posts/41055.html","excerpt":"Linux 手把手教你搭建Apahce论坛","text":"Linux 手把手教你搭建Apahce论坛 搭建一个Apache论坛123456789该论坛是再虚拟机环境下运行，实机一样得操作。 恢复快照，检测是否有 阿帕奇 service httpd restart 源代码安装的 进入apache目录 删除即可 yum源安装的 使用 rmp卸载 一、挂载123456mount /dev/cdrom /mnt 挂载镜像文件到/mntls /mnt/Server/ 查看是否有文件vim /etc/yum.repos.d/aa.repo 配置yum文件 二、安装12345678*【注：\\* 为安装http 下所有包】1.yum -y install http\\* （先装阿帕奇服务）2.yum -y install mysq\\* （数据库）3.yum -y install php\\* （php开发语言） 三、启动123456service httpd restart 启动阿帕奇service mysqld restart 启动mysq再去启动论坛包（Discuz_X2_SC_UTF8）copy到虚拟机 四、解压（zip压缩包）12345678910111213141516171819202122cd /root/Desktop 切换到桌面unzip Discuz_X2_SC_UTF8 解压Discuz到桌面cp -r upload /uar/www/html/ 复制upload文件到htmlcd /dav/www/html ls 切换到html 查看是否有upload文件（恢复快照）重新配置ipvim /etc/sysconfig/network-scripts/ifcfg-eth0ifdown eth0 &amp;&amp; ifup ethoping通（192.168.18.222）--本机使用本机或者虚拟机浏览器进行访问192.168.18.221 Red Hat 192.168.18.221 upload 五、安装123456192.168.18.221/upload进入Dis 安装向导修改阿帕奇权属权限chown apache upload html -R（-R递归修改所有权属） 六、创建数据库123456789101112131415mysql 进入数据库show databases； 显示当前数据库create database hehe; 创建 hehegrant all on hehe.\\* to ‘hh’@‘localhost’ identified by ‘123456’; (密码 ，授权）数据库名：hehe数据库用户名：hh密码：123456 错误情况方案整理：12345678910111213141516171819202122232425261、数据库模版错误 yum -y install php-\\*2、安装http中过程中途停止 yum -y install httpd-devel3、安装mysql时出错 yum -y install mysql-connector-odbc4、想卸载已安装http（apache）时，需在挂载镜像。 yum -y remove http\\*5、配置yum（配置服务器中文包）yum install fonts-chinese.noarchyum install m17n-db-common-cjkyum install m17n-db-chinese","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux 计划任务","slug":"Linux/Linux-计划任务","date":"2020-04-25T11:12:39.000Z","updated":"2020-09-11T08:45:25.876Z","comments":true,"path":"posts/39704.html","link":"","permalink":"http://www.a2data.cn/posts/39704.html","excerpt":"计划任务","text":"计划任务 计划任务12345date----当前时间 ctrl+D 保存 Atq 查看任务列表 Atrm 删除任务 At 一次性计划任务 命令：at + 时间 Crontab 周期性计划任务 服务脚本名称： /etc/init.d/crond 123456crontab -e [-u 用户名] 编辑计划任务crontab -l [-u 用户名] 查看计划任务crontab -r [-u 用户名] 删除计划任务 周期条件 分 时 日 月 周 执行内容 0-59（整数） 0-23（整数） 1-31(整数） 1-12（整数） * run_command 50 3 2 1 * 执行命令或脚本 例如： 30 18 */3 * 1,3，5 /bin/rm-rf /var/ftp/pub/* 30 18 */3 * 1,3,5 /bin/rm -rf /var/ftp/pub/* 每隔3天在周1,3,5来清除FTP服务公共目录. * ， - / 表示该范围内的任意时间 表示间隔的多个不连续时间点 表示一个连续的时间范围 指定间隔的时间频率","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux SSH协议","slug":"Linux/Linux-SSH协议","date":"2020-04-25T11:12:22.000Z","updated":"2020-09-11T08:45:25.869Z","comments":true,"path":"posts/630.html","link":"","permalink":"http://www.a2data.cn/posts/630.html","excerpt":"Linux SSH协议。","text":"Linux SSH协议。 SSH 协议123456789101112131415161718默认端口 ：TCP：22 FTP:21 SSH:22 Apache（阿帕奇）：80步骤1： ping 192.168.18.221 （ping得通）步骤2：ssh [root@192.168.18.221](mailto:root@192.168.18.221) 输入密码 进入服务端步骤3： exit 退出服务端 ssh-keygen -t rsa(或者dsa) 客户机生成密钥 步骤4：ssh-copy-id -i .ssh/id_rsa.pub [root@192.168.18.221](mailto:root@192.168.18.221)将密钥上传输到服务端。步骤5：输入服务端密码 exit 再次输入 ssh [root@192.168.18.221](mailto:root@192.168.18.221)便可直接进入！","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux Mdadm案例","slug":"Linux/Linux-Mdadm案例","date":"2020-04-25T11:12:05.000Z","updated":"2020-09-11T08:45:25.892Z","comments":true,"path":"posts/61794.html","link":"","permalink":"http://www.a2data.cn/posts/61794.html","excerpt":"Linux Mdadm 案例 raid5。","text":"Linux Mdadm 案例 raid5。 Mdadm 案例 raid5一、添加RAID512mdadm -C /dev/md5 -l 5 -n 3 /dev/sd[b,c,d] 二、创建文件系统12格式化：mkfs.ext3 /dev/md5 makir /raid5 三、挂载文件系统123mount /dev/md5 /raid5 挂载文件系统df -hT 查看 RAID容错1234567891011121314151617181920mdadm /dev/md5 -f /dev/sdb 损坏磁盘bmdadm -D /dev/md5 查看mdadm /dev/md5 -a /dev/sdf 增加一块磁盘mdadm /dev/md5 -r /dev/sdb 移除坏磁盘echo &quot;DEVICE /dev/sdc /dev/sdd /dev/sde /dev/sdf&quot; &gt;&gt;（写入到哪） /etc/mdadm.conf 把UUID 写入 /etc/.......文件中mdadm -Ds &gt;&gt; /etc/mdadm.conf 把UUID 读写出来cat /etc/mdadm.confmdadm -S --scan /dev/md5 关闭RAID（需要卸载md5）mdadm -A --scan /dev/md5 开启RAID恢复快照！","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux逻辑卷","slug":"Linux/Linux逻辑卷","date":"2020-04-25T11:11:47.000Z","updated":"2020-09-11T08:45:25.872Z","comments":true,"path":"posts/40711.html","link":"","permalink":"http://www.a2data.cn/posts/40711.html","excerpt":"Linux 逻辑卷得操作指南。","text":"Linux 逻辑卷得操作指南。 LVM逻辑卷 创建lvm 创建物理卷__PV123pvcreate /dev/sdb,c,d,e (创建pv）pvdisplay(显示pv） 创建卷组123vgcreate /dev/feng_vg /dev/sdb,c,d,e(创建vg）vgdisplay (显示vg） 拓展vg123pvcreate /dev/sdf(创建一个新的pv）vgextend feng_vg /dev/sdf (扩展vg) 减少vg1vgreduce feng_vg /dev/sdc,d,e 移除vg1vgremove feng_vg 创建LV lvcreate -L 30G -n feng_lv feng_vg 格式化 mkfs.ext3 /dev/feng_vg/feng_lv 挂载 mount /dev/feng_vg/feng_lv /aa 增加1234567 先卸载 umount /aalvextend -L +10G /dev/feng_vg/feng_lv（检测硬件）resize2fs /dev/feng_vg/feng_lv （重设文件系统大小） 减少LV12345678先卸载 （输入卸载名称或者目录） umount /dev/feng_vg/feng_lv缩小lv先缩小文件系统再缩小lve2fsck -f /dev/feng_vg/feng_lv （检测硬件）resize2fs /dev/feng_vg/feng_lv 9g （将文件系统缩小到9G） 缩小lv1lveduce -L 9G /dev/feng_vg/feng_lv 移除lv1lvremove /dev/feng_vg/feng_lv 移除pv1234567 pvremove /dev/sdb1 /dev/sdb2lv 使用pe（默认4M） 的块 lvcreat -l (小写） 个数 lvcreat -L (大写） 指定容量","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux磁盘管理","slug":"Linux/Linux磁盘管理","date":"2020-04-25T11:11:29.000Z","updated":"2020-09-11T08:45:25.889Z","comments":true,"path":"posts/37426.html","link":"","permalink":"http://www.a2data.cn/posts/37426.html","excerpt":"Linux 磁盘管理。","text":"Linux 磁盘管理。 磁盘管理查看磁盘1234567891011121314151617fdisk -l fdisk /dev/sdb 磁盘分区指令 ml list known partition 列出所有的分区n add a new partition 创建一个新的分区p print the partition table 打印分区内容t change a partition&#x27;s system id 改变分区系统idw write table to disk an exit 保存并退出分区d delete a partition 删除一个分区 查看分区12345678fdisk -l fdisk /dev/sdb 磁盘分区n----创建d----删除 交换分区 1234fdisk /dev/sdb格式化为 swap 命令mkswp /dev/sdb1 设置分区1234567891011mkswap /dev/sdb1 (做成交换文件系统）free 查看一下内存swapon /dev/sdb1 开启交换内存free 查看内存swapoff /dev/sdb1 关闭交换内存free 最后查看 是否存在 文件系统123456789101112131415161718umount 卸载mount 挂载1、创建mkfs - t ext3 /dev/sdb1mkfs ext3/dev/sdb1挂载mount /dev/sdb /mnt查看df -hT","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux系统程序","slug":"Linux/Linux系统程序","date":"2020-04-25T11:11:14.000Z","updated":"2020-09-11T08:45:25.887Z","comments":true,"path":"posts/60364.html","link":"","permalink":"http://www.a2data.cn/posts/60364.html","excerpt":"Linux 系统程序篇。","text":"Linux 系统程序篇。 系统程序 系统程序管理RPM包 （Red Hat） 命名格式 ： bash-3.1-16.1.i386.rpm 软件包名-版本号-发布次数-硬件平台-后缀名 rpm管理命令1234567rpm -q [子选项] 【软件名】rpm -qa 查看系统中已安装的所有rpm软件包列表rpm -qpi 通过.rpm 包文件查看该软件的详细信息rpm -qpl 查看.rpm安装包内所包含的目录.文件列表 安装1234567rpm -i rpm包文件 安装一个新的rpm软件包rpm - U 升级某个rpm软件包，若原本未安装，则进行安装rpm -F 更新某个rpm 软件，若原本未安装，则放弃安装 安装 1234567步骤1： tar 解包步骤2： ./configure 配置步骤3： make 编译步骤4： make instal步骤5: service httpd restart service network restart步骤6: cd /var/www/ Yum本地：Yum(file本地） 1234567891011121314151617181920212223242526272829命令：cd /etc/yum.repos.d/xd挂载：1. 挂载光盘镜像到/mntmount /dev/cdrom /mnt 2. 配置yum源vim /etc/yum.repos.d/xxx.repo[xxx]baseurl=file:///mnt/Server(flie本地)enabled=1(是否启动文件 0否 1是）gpgcheck=03. 安装 yum -y install 软件名称 （vsftpd）4. 重启yum service vsftpd start 服务器Yum 12345678910111213141516171819202122232425262728293031------服务器yum0、命令：cd /etc/yum.repos.d/1、服务器端提供共享-- 服务器安装一个ftp-- 把光盘镜像挂载ftp的共享目录挂载：mount /dev/cdrom /var/ftp/pub必须保证两台机器能够正常通信（能够ping通）2、配置客户端vim /etc/yum.repos.d/xxx.repo[xxx]baseurl=[ftp://192.168.18.221/dev/cdrom](ftp://192.168.18.221/dev/cdrom) /var/ftp/pub 【服务器ip地址及共享目录】enabled=1(是否启动文件 0否 1是）gpgcheck=0开启 service vsftpd start 卸载 rpm -e 软件名 源代码（灵活定制） tarball 封包 tar.gz 或者 tar.bz2 效验工具 1md5 sum","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux网络设置","slug":"Linux/Linux网络设置","date":"2020-04-25T11:10:58.000Z","updated":"2020-09-11T08:45:25.891Z","comments":true,"path":"posts/37390.html","link":"","permalink":"http://www.a2data.cn/posts/37390.html","excerpt":"Linux 网络设置配置。","text":"Linux 网络设置配置。 网络设置 存放位置 —- 以RedHat为例 /etc/sysconfig/network-scripts/ifcfg-etc0 修改ip123setup 交互式图形化工具vim /etc/sysconfig/network-scripts/ifcfg-eth0 修改 DNS12/etc/resolv.conf 修改主机名123vim /etc/sysconfig/network 网卡控制12341.ifdown 关闭网卡 丨 ifup 开启网卡2.service network stop 丨 start 丨restart 停止 开启 重启 开机自启动12chkconfig httpd on 开机自动挂载 设置开机自动挂载的路径这个是当时学习在虚拟机上使用的多。 12/etc/fstab 网络配置123456789101112131415161718192021222324252627282930313233343536IP：是一个逻辑地址，是由32位二进制构成-------------------------------------------------------setupvim /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0 网卡BOOTPROTO=none 是否自动获取IP ---&gt; dhcpHWADDR=00:0c:29:d6:96:fb MAC地址ONBOOT=yes 是否随网络服务启动，eth0生效NETMASK=255.255.255.0 子网掩码IPADDR=192.168.18.76 IP地址TYPE=Ethernet 类型为以太网------------------------------------------------------修改DNSvim /etc/resolv.confsearch localdomainnameserver 192.168.40.2nameserver 202.106.0.20 联通nameserver 114.114.114.114nameserver 8.8.8.8 谷歌nameserver 4.4.4.4 谷歌","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux权限控制","slug":"Linux/Linux权限控制","date":"2020-04-25T11:10:30.000Z","updated":"2020-09-11T08:45:25.898Z","comments":true,"path":"posts/16586.html","link":"","permalink":"http://www.a2data.cn/posts/16586.html","excerpt":"Linux 权限控制详解。","text":"Linux 权限控制详解。 权限控制属组权限 字符制表示八进制 000 - 777 字符表示法 八进制表示法 含义 r 4 读 w 2 写 x 1 执行 修改权限的命令 123456789101112131415【 su - u2 切换用户】 1、 chmod 修改文件权限2、 chown，chgrp 修改文件权属 U----所有者 O----其他人 a-----所有人 g-----所属组chomd a=rwx root 所有都拥有读写执行权限 cat /etc/passwd|grep -v nologin|grep -v halt|grep -v shutdown|awk -F&quot;:&quot; &#x27;&#123; print $1&quot;|&quot;$3&quot;|&quot;$4 &#125;&#x27;|more 用户控制命令 useradd 添加用户 useradd -g 指定用户所属用户组 useradd -G 用户组 指定用户所属的附加组 useradd -u 用户号 指定用户的用户号 命令：指定用户所属组 useradd -g 组名 -u 用户号 用户名 12345678910111213例如useradd -g g3 -u 510 u5指定用户附属组useradd -g 组名 -G 所在组 用户名例如:useradd -g g4 -G g1 u7 修改账户信息 usermod 修改账户信息 usermod -g 用户组指定用户所属的用户组 usermod -l 锁定账号 usermod -u 解锁账号 userdel 删除账户 userdel -r 删除宿主目录 设置密码 passwd 设置密码 passwd -l 锁定账号 passwd -u 解锁账号 passwd -s 查看账号状态 usermod -L u1 u1账号被锁定 usermod -U u1 u1账号被解锁 passwd u1 设置u1 账号密码 linux 组账户 groupadd 添加组成员 groupdel 删除组成员 gpasswd 设置组成员 -a 添加成员 -d 删除成员 -M 定义成员列表 gpasswd -a u1 g1 将u1加入到g1组中 gpasswd -M u1,u2,u3,u4,u5 g2 将u1到u5添加g2组里","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux基本操作","slug":"Linux/Linux基本操作","date":"2020-04-25T11:10:17.000Z","updated":"2020-09-11T08:45:25.867Z","comments":true,"path":"posts/46411.html","link":"","permalink":"http://www.a2data.cn/posts/46411.html","excerpt":"Linux 基本操作。","text":"Linux 基本操作。 本文精心整理，如需转载，请联系小编。谢谢。相关安装包可以加小编获取。 服务器路径 命令符号 释义 / 根目录 /bin 二进制可执行命令 /dev 设备特殊文件 /etc 系统管理和配置文件 /etc/rc.d 启动的配置文件和脚本 /home 用户主目录的基点 /lib 标准程序设计库 /sbin 超级管理命令 /mnt 系统提供这个目录是让用户临时挂载其他的文件系统 /root 系统管理员的主目录 /Lost+found 这个目录平时是空的， 系统非正常关机而留下“无家可归”的文件 /proc 虚拟的目录，是系统内存的映射 /usr 应用程序和文件几乎都在这个目录. /var 某些大文件的溢出区 boot 内核文件 Linux 系统文件（100MB-200MB） 服务器500MB opt 临时文件 常用快捷键1234567891011121314151617181920212223242526272829303132333435图形界面 到 字符界面Ctrl Alt Fn （F1-----F6） init 3字符界面 到 图形界面 Alt F7 init 5Tab键 ：自动补齐反斜杠\\ ：强制换行ctrl+u 清空至行首ctrl+k 清空至行尾ctrl+L 清屏ctrl+c 取消本次命令编辑touch 创建文件mkdir 创建目录 mkdir -p 创建嵌套的多层目录结构cd 切换工作目录 cd - 切换两个目录 cd .. 返回上个目录du 统计目录及文件 du -s 只统计大小 du -a 统计所有文件 du -h 人性化显示du -sh \\* 查看所有文件及大小pwd ------- 查看当前所在位置vim ------查看日志（编辑器）Ls ------ 打印（当前目录下所包含的内容）ls 显示目录内容（ls=ll）./ ------直接运行脚本 查看帮助1234567891011121314help， -help man info （man ls）常用命令 uname 查看系统信息及内核版本（-a 显示主机；-r 显示内核版本）hostname 查看主机名vim /etc/sysconfig/network 更改主机名ifconfig 查看网络信息shutdown -h now | poweroff | init 0 关闭计算机shutdown -r now | reboot | init 6 重启计算机 Ln软链12345678Ln链接文件Ln 要链接的文件 链接到什么地方ln 创建链接文件 ln -s 软链接 ln 硬链 CP 复制12345678cp -r 递归复制整个目录树 cp=cp-i cp -r 递归复制cp -p 保持源文件的属性不变cp -f 强制覆盖目标同名文件或目录cp -i 需要覆盖文件或目录时进行提醒 RM 删除123456789rm -rf 递归强行删除文件或者目录 不进行提醒rm -f 强行删除文件或者目录，不进行提醒rm -r 递归删除整个目录树rm - i 删除文件或者目录时提醒用户确认 MV 移动（改名）1234567891011Cat 查看文件More 分页查看文件 （不可返回）Less 分页查看文件 （可返回）Head 查看文件头（前10行）Tail 查看文件尾 （后10行） WC 统计1234wc -l 统计行数 wc -w 统计单词个数 wc -c 统计字节数 压缩指令 压缩 （仅限文件） gzip bzip2 表示高压缩比： gzip -9 bzip2 -9 解开已经压缩的文件 gzip -d bzip2 -d Tar 归档 口令打包压缩： Tar 要打包压缩到什么地方 要打包压缩的文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546单个解释用法：tar -c 创建 . tar格式的包文件tar -x 解开. tar格式的包文件tar -v 查看详情信息tar -f 表示使用归档文件tar -p 打包时保留原始文件及目录的权限tar -t 列表查看包内文件tar -C 解包时指定释放的目标文件夹tar -z 调用gzip程序进行压缩或者解压tar -j 调用bzip2 程序进行压缩或者解压组合命令：tar -cvf 打包tar -zcvf 打包压缩tar -zcvf XXX.tar.gz XXtar -xvf 解压 tar -xvf xxxx.tar.gz -C aaa 解压到指定目录打包压缩---- tar -zcvf解压 ----- tar -zxvf 指定位置解压--- tar -zxcf -Cxx.bz2用bzip2 -d解压xx.gz用gzip -d解压xx.tar.gz 用-zxvf解压xx.tar.bz2用-jxvf解压 常用 1234567891011打包：1、tar -zcvf a2data.tar.gz ./a2data.cn/*2、tar -zcvf a2data.tar.bz2 ./a2data.cn/* ---- 将a2data.cn文件夹下统一打包 ------解压(万能)：tar -xf a2data.tar.bz2 ./ ---- 解压到当前路径下---- VI 编辑器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950命令模式:vim/vi ESC输出模式:a、i、o等键末行模式：(大写)A键工作模式：命令模式 输入模式 末行模式a #光标后面写i #光标前面写o #下一行写dd #删一行n+dd #删几行d$ #删除光标后面的同一行 （删光标）d^ #删除光标前面的同一行 （不删光标）x #删光标X #删光标前面的yy #复制p #黏黏到下一行P #黏黏到上一行u #撤销上一步U #撤销这一行的所有修改:q! #不保存退出 :w #保存:wq #保存退出:/ #搜索的东西 搜索什么 从上到下搜索% #搜索的东西 搜索什么 从下到上搜索 行号 12345678910111213141516171819202122232425262728:set nu #设置行号:set nonu #不要行号了跳转到首行gg跳转到尾行G\\#G跳转到到第几行：e/etc/passwd 打开新的编辑文件：r/etc/passwd 读入其他文件内容文件内个替换s/old/new 替换行里的一个old换成news/old/new/g 整行替换 old换成new#，#s/old/new/g #到#行替换 old换成new%s/old/new/g 整篇替换 old换成newc 末尾加入c 对每个替换提示用户进行确定","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Hexo博客疑难杂症","slug":"Hexo/Hexo博客疑难杂症","date":"2020-04-19T10:57:28.000Z","updated":"2020-09-11T08:29:56.559Z","comments":true,"path":"posts/f92cb63f.html","link":"","permalink":"http://www.a2data.cn/posts/f92cb63f.html","excerpt":"Hexo 疑难杂症","text":"Hexo 疑难杂症 墙裂推荐Hexo博客前言 www.a2data.cn —– 小编小站 Q: 为什么要搭建一个属于自己的个人博客呢？ 个性化 用自己喜欢的域名，选择自己喜欢的主题，布局，特效等都可以自己编写代码完成，不会的也可以进入对应开源主题交流群, 你会发现这些人更加随和、热心,例如闪烁之狐主题的创作者 — blinkfox 成就感 当网站被搜索引擎收录，输入相应关键字即可，可以小小的炫耀一番 拓展交流圈 如果你对某类感兴趣的话，可以通过个人博客找到一些志同道合的朋友。例如：sitoi 学会坚持 刚开始搭建好属于自己的博客，那真的是三分钟热度，但是真的坚持下来的人很少.很多人就跑个主页,就像很多公众号一样,注册了没创作。小编虽然是体育僧，不论是跨行，还是博客,公众号，都坚持(没发表可能是忙,或者持续充电中)。 简历加分项 当我们苦于该如何写一份个人简历时，当你拿出一个你坚持 3 年、5 年的个人博客时，或许你的机会就比别人大一点。更直观，更好的了解你得技术栈。更有信服力。 个人空间 在这个地方，你可以写一些自己的东西(不管有没有人看)，你可以自己快速定位自己查找过的东西，不用每次都去百度同样的问题，也不用担心每次找不到最优解 以至于很多朋友直接去我的网站找资料 写作水平的提高 坚持写作，你的写作水平会得到很到的提高，对你今后的人生会有很大的帮助。包括语言，架构，排版 。。 总之短期是看不出效果的，只有长期坚持。 好比： 你去学习一个月跆拳道，你说你会，一个练了十年的人，同样是一拳一腿 跟你有可比性吗？ 赚取一点钱 当你的博客足够好，公众号粉丝足够多，内容足够丰富，你可以开始尝试赚钱，当然啦，和坚持是离不开的。 折腾中学会知识，互访中找到友情，写作中读懂人生，坚持中找到方向。 比如 像小编的目标一直没变，用大数据人工智能推动传统行业的发展而奋斗！！！ 心动，为何不动？ 相信大家刚开始都是这么想的,搭建博客？ 需要具备： 网站,域名,备案 服务器 自己写代码(前端+后端+服务器部署) … …… 啊，我太南了 —– 臣妾做不到啊 不要慌，问题不大！没关系,小编一步步带你飞。教你如何从零开始拥有属于自己的博客网站。(仅面向Windows用户,就会有人问Mac 不香吗？ 香，但是太贵，买不起,也不太会用!) 小编推荐： windows神器： utools 生成力工具集:https://www.u.tools/ 环境准备: Node.js Hexo Git GitHub SSH key Coding Typora (Md格式书写工具) idea(就是编辑工具,推荐webstorm) 拓展： 服务器部署 域名配置 PWA离线访问 SEO优化 加速访问 ……… 安装Node.js 中文网：https://nodejs.org/zh-cn/download/ 官方网站：https://nodejs.org/en/ 直接下载对应的安装包，之后一顿操作,跟安装QQ一样。 安装步骤如下： 选择安装 安装完成 查看是否安装成功 启动： win键(就是windows图标得那个按键) + R 输入： cmd 清空： cls 安装hexo 12npm install hexo-cli -g 输入npm install hexo -g，开始安装Hexo 输入 hexo -v 查看是否安装成功 创建博客方式1： 12345# 方式1 一定要是一个空的文件夹mkdir sqlsq.github.iocd sqlsq.github.iohexo init 方式2： 12hexo init sqlsq.github.iocd sqlsq.github.io 本地访问 到此，你已经可以搭建hexo 博客了，恭喜一波。 hexo 命令问题命令找不到解决方案 *首先可以安装一波 配置环境变量 找到这东西就好说了。配置一下环境变量即可。soeazy 设置之后再次查看 安装Git 官网：https://git-scm.com/downloads 下载直接默认下一步即可： 配置自己的ssh 桌面鼠标右键，点击Git Base Here。 12345678910# 设置 git 相关信息git config --global user.name &quot;你得昵称&quot;git config --global user.email &quot;your.email&quot;# 生成密钥ssh-keygen -t rsa -C &quot;youemail&quot; # a2data@vip@qq.com`连续回车 3连击` 即可完成密钥的生成创建。 查看密钥 12cd ~/.ssh输入cd ~/.ssh，检查是否由.ssh的文件夹 ls 查看 备份 单独一个 可以不用这样做 直接看下边快捷操作输入 eval “$(ssh-agent -s)”，添加密钥到ssh-agent 其实就是对ssh做了复制添加 12eval &quot;$(ssh-agent -s)&quot;ssh-add ~/.ssh/id_rsa #添加生成的SSH key到ssh-agent 快捷操作 12# 本部分需要在 github上使用，别着急请往下看。cat id_rsa.pub Git拓展 此部分针对多个博客，多个key的，单独的跟着上边走即可。 参考博文配置：https://www.cnblogs.com/a2data/p/12597940.html 多个账号建议使用局部的。 1234567# 取消全局 用户名/邮箱 配置git config –global –unset user.namegit config –global –unset user.email# 单独设置每个repo 用户名/邮箱git config user.name &quot;用户名&quot; //在config后加上--global即全局git config user.email &quot;邮箱&quot; 如下图： 12345ssh-keygen -t rsa -f ~/.ssh/xxx_id_rsa -C &quot;yourmail@xxx.com&quot;或者ssh-keygen -t rsa -C &quot;yourmail@xxx.com&quot; #第一次时输入名字 注册Github 如果你有Github想体验一波删除，重新创建小编也不介意的。毕竟写教程，我也是操作了一波。 删除github登录github账号 *找到自己的邮件 重新注册 打开github官网：https://github.com 选择你得职业相关信息： 创建并且会给你发邮件激活： 登录邮箱激活： 配置Github 配置key 完成配置 测试配置是否成功1234输入ssh -T git@github.com，测试添加ssh是否成功。输入yes，如果看到Hi后面是你的用户名，就说明成功了 执行git port22 异常解决方案 应该是小编特殊情况导致。解决顺便做个记录。 新手忽略即可。 配置博客到Github 再你博客的根目录中(sqlsq.github.io) 配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） 大概在 98行。 打开推荐方式： sublime text(未破解有广告) webstrom vscode ( 免费) 12345deploy: type: git repository: git@github.com:nianshaofeng/nianshaofeng.github.io.git branch: master 回到你的项目 复制你得repo值 创建文章 如果使用GitBash 请到博客根目录执行。 Hexo命令12345678910111213141516171819202122232425262728293031# 全部命令hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本# 缩写：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy# 组合命令：hexo s -g #生成并本地预览hexo d -g #生成并上传 发布部署12345# 在生成以及部署文章之前，需要安装一个扩展： 如下图# mac 用户 需要加 `sudo`npm install hexo-deployer-git --save npm报错123# 主要是镜像源的问题npm config set registry http://registry.npmjs.org/ 查看部署首先先设置一下你得配置： 之后便会有你的域名： 打开结果一看 卧槽，无情。 这是什么鬼。 怎么跟我想要看的不一样（与本地不一样啊） 不要慌，问题不大。小编告诉你为什么。 重新创建项目，如下图。 我们看看问题在哪 1、https://minesql.github.io/sqlsq.github.io/ 2、https://minesql.github.io/ 我们将config.yml 地址换成第二次创建的项目地址。 再次提交。 我们再次访问看一下效果吧 目前小编博客： https://a2data.github.io/ https://www.a2data.cn/ 应朋友有要求，写了一篇炒鸡详细的，以及遇到的各种坑。 如果有帮助就收藏吧。 拓展内容下期见： 个性化主题 图床(为什么要有图床呢 自己研究) seo 等等","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/tags/Hexo/"}]},{"title":"资料分享","slug":"Tools/资料分享","date":"2020-04-14T02:55:49.000Z","updated":"2020-09-11T09:28:58.963Z","comments":true,"path":"posts/45997.html","link":"","permalink":"http://www.a2data.cn/posts/45997.html","excerpt":"这里是分享资源整理学习资源，分享。","text":"这里是分享资源整理学习资源，分享。 示例 不断更新 本站链接已隐藏，关注公众号获取密码提取 链接: https://pan.baidu.com/s/1bLYT-nJf7UwT2Y_6xzS_5Q 提取码: g4ej 本站下载绝不收费，输入验证码后查看（防止机器采集被和谐）验证码：请关注本站微信公众号，回复“我要学习”，获取验证码。在微信里搜索“DataScience”或者“A2Data”微信扫描右侧二维码 function lock(){ var code =document.getElementById(\"verifycode\"); if(code.value !== '666888'){ alert(\"密码错误，请关注本站公众号获取\"); } else{ $('#link').html($('#link .code').html()); alert(\"密码输入正确，成功获取到链接\"); } } Document .user{ display: flex; background: bisque; padding: 10px; margin-bottom:10px; } .user ul { list-style: none; } document.getElementById(\"btn\").addEventListener(\"click\",Gethubdata); function Gethubdata(){ let her = new XMLHttpRequest(); her.open(\"GET\",'https://api.github.com/users',true);//第三个参数表示是否以异步的方式打开 her.onreadystatechange = function(){ if(this.readyState===4) { let data = JSON.parse(this.responseText); let output = \"\"; for (const key in data) { //下面用的了模板字符串，不了解的参见文末的文章推荐 output+=` id:${data[key].id} login:${data[key].login} type:${data[key].type} ` }; document.getElementById(\"users\").innerHTML = output; } }; her.send(); }; 表格 Document 课程表 星期一 星期二 星期四 星期五 语文 数学 英语 生物 ​","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"资料分享","slug":"资料分享","permalink":"http://www.a2data.cn/tags/%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB/"}]},{"title":"Hexo部署到码云","slug":"Hexo/Hexo部署服务器","date":"2020-04-07T08:15:10.000Z","updated":"2020-08-31T08:16:14.729Z","comments":true,"path":"posts/8f004046.html","link":"","permalink":"http://www.a2data.cn/posts/8f004046.html","excerpt":"Hexo 部署到Gitte","text":"Hexo 部署到Gitte Hexo 部署到码云 其实使用码云和使用github没有太大的区别，最近开始使用码云，为了避免忘记，还是做一下记录吧。 1、注册账号 码云网址：https://gitee.com/。 如果想以http://a2data.gitee.io这种一级域名的形式访问bolg，那么我们需要建立一个与自己个性地址同名的项目，如 https://gitee.com/a2data 这个用户，在创建项目时项目名称应该为A2Data。 2、创建仓库 3、复制项目 4、配置仓库 5、部署到码云1234# 这块会输入账号密码 ，稍后配置以下ssh 以后就不用输入账号密码了hexo d 6、Page服务 启动服务 7、配置SSH 8、成功访问 https://sqlsq_admin.gitee.io/","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/tags/Hexo/"}]},{"title":"手把手教你玩git","slug":"Git/手把手教你玩git","date":"2020-03-31T14:51:33.000Z","updated":"2020-08-07T10:29:00.204Z","comments":true,"path":"posts/47936.html","link":"","permalink":"http://www.a2data.cn/posts/47936.html","excerpt":"Git 深入浅出，史无前例的详细教程。","text":"Git 深入浅出，史无前例的详细教程。 0、查看本机公钥 步骤： 1、进入.ssh目录 cd ~/.ssh 2、找到id_rsa.pub文件 ls / ll 3、查看文件 cat id_rsa.pub 123456789JackFeng@JackFeng MINGW64 ~/Desktop$ cd ~/.sshJackFeng@JackFeng MINGW64 ~/.ssh$ lsconfig id_rsa id_rsa.pub id_rsa_sql id_rsa_sql.pub known_hostsJackFeng@JackFeng MINGW64 ~/.ssh$ cat id_rsa.pub 1、配置多个git仓库123456789101112多仓库之间 &#x27;ssh-key切换&#x27;#1、生成客户端自己的密钥对ssh-keygen ---- 一顿回车即可# 实际操作 换成你的邮箱即可ssh-keygen -t rsa -C &quot;youremail@example.com&quot;可以在客户端的家目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥。 生成新的ssh-key 12#second@mail.com 工作邮箱地址ssh-keygen -t rsa -C &#x27;second@mail.com&#x27; -f id_rsa_second 配置多个仓库 在.ssh目录创建config文本文件并完成相关配置(最核心的地方)每个账号单独配置一个Host，每个Host要取一个别名，每个Host主要配置HostName和IdentityFile两个属性即可 Host的名字可以取为自己喜欢的名字，不过这个会影响git相关命令，例如： HostName 这个是真实的域名地址IdentityFile 这里是id_rsa的地址PreferredAuthentications 配置登录时用什么权限认证–可设为publickey,password publickey,keyboard-interactive等User 配置使用用户名 config 1234567891011121314# 配置github.comHost github.com HostName github.com IdentityFile ~\\.ssh\\id_rsa PreferredAuthentications publickey User yinjie.feng# 配置SQLSQHost SQL HostName github.com IdentityFile ~\\.ssh\\id_rsa_sql PreferredAuthentications publickey User yinjie.feng 测试是否调通 123456789101112131415JackFeng@JackFeng MINGW64 ~/.ssh$ vim configJackFeng@JackFeng MINGW64 ~/.ssh$ ssh -T git@github.comHi A2Data! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.JackFeng@JackFeng MINGW64 ~/.ssh$ vim configJackFeng@JackFeng MINGW64 ~/.ssh$ ssh -T git@SQLHi MineData-SQL! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. git add、git commit、git remote add、git push需要说明的一点，在git commit 时需要一次身份验证，正确输入你的用户名和邮箱就可以了。 另外注意：github根据配置文件的user.email来获取github帐号显示author信息，所以对于多帐号用户一定要记得将user.email改为相应的email(monster@mail.com)。 总结一下:其实建立第二个密钥对的区别就在于对第二密钥对的声明，因此需要在.ssh目录下添加config文件，添加语句dentityFile ~/.ssh/id_rsa_sql声明这是第二个密钥对。这条连接命令就体现出来了。 查看用户名12git config user.namegit config user.email 修改用户名123git config --global user.name &quot;xxx&quot;git config --global user.email &quot;xxx&quot; 2、从远程项目拉取1git clone 项目地址 3、提交代码到远程仓库12345678910111213141516171819常规操作##添加git add . .#查看状态git status# 提交git commit -m &quot;代码描述&quot;# 再次查看状态git status# 拉取最新代码git pull# 提交git push 4、git分支操作Git初始化 解决 fatal: Not a git repository (or any of the parent directories): .git 问题 1git init 12345678910git clone --- 克隆项目JackFeng@JackFeng MINGW64 /d/Practice$ git clone git@github.com:MineData-SQL/SQL.gitCloning into &#x27;SQL&#x27;...remote: Enumerating objects: 3, done.remote: Counting objects: 100% (3/3), done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Receiving objects: 100% (3/3), done. 创建分支12git branch &lt;branch_name&gt; #指定分支名称git checkout -b [&quot;分支名&quot;] 查看分支123git branch # 查看所有分支,* 号所属代表当前分支git branch # 查看分支详情，包括分支指向得commitid及提交信息 切换分支123git checkout &lt;branch_name&gt; #切换到指定分支git checkout -b &lt;branch_name&gt; #创建并切换到指定分支 删除分支12345git branch -d &lt;branch_name&gt;.#删除一个干净的分支(即相对当前分支而言该分支没有新的提交记录)git branch -D &lt;branch_name&gt;.#强制删除一个分支，该分支有没有合并到当前分支的提交记录注意：删除分支前都需要先切换到其他分支才能进行删除操作 分支恢复 思路：对于已经有提交记录的分支删除后，实际上只是删除指针，commit记录还保留，如果想恢复，需要使用git reflog查找该分支指向的 commitId，然后根据commitId创建新的分支 HEAD@&#123;1&#125; 1234git refloggit branch &lt;branch_name&gt; &lt;hash_val&gt; #根据指定commit创建新分支 分支改名1git branch -m &lt;branch_name&gt; newname 123456789JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two)$ git branch -m master-one master-OJackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two)$ git branch master master-O* master-two 分支合并 git merge #将指定分支合并到当前分支如果两个分支没有产生分叉情况，那么会进行快速合并，即fast-forward方式，它并不会产生新的commitId，只是改变了指针的指向，产生分叉合并可能会有冲突情况。 示例： 合并master-O分支到master分支，此时合并为fast-forward方式 分支合并细节 git merge -ff -m &quot;msg&quot; #合并分支时禁用Fast forward模式 如果使用fast-forward方式进行分支合并，只是简单改变了分支指针，而不会产生新的commit记录。 为了保证合并数据的完整性，我们也可以在合并时指定不使用fast-forward方式，使用 --ff 选项。这样，在merge时就会生成一个新的commit，从日志上就可以看到分支合并记录了。 示例：我们在master-two分支上新增一次提交，然后合并到master分支上，git log查看最新一次的提交记录，显示的正是我们合并分支时的记录 git log --pretty=oneline -1 123456789101112131415161718192021222324252627282930313233343536JackFeng@JackFeng MINGW64 /d/Practice/SQL (master)$ git checkout master-twoSwitched to branch &#x27;master-two&#x27;JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two)$ echo &quot; thank you for attention DataScience &quot; &gt;&gt; a2data.txtJackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two)$ git add a2data.txtwarning: LF will be replaced by CRLF in a2data.txt.The file will have its original line endings in your working directoryJackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two)$ git commit -m &quot; add file&quot;[master-two 59a8816] add file 1 file changed, 1 insertion(+) create mode 100644 a2data.txtJackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two)$ git checkout masterSwitched to branch &#x27;master&#x27;Your branch is up to date with &#x27;origin/master&#x27;.JackFeng@JackFeng MINGW64 /d/Practice/SQL (master)$ git merge --ff -m &quot;meger master-two branch&quot; master-twoUpdating ab83ffb..59a8816Fast-forward (no commit created; -m option ignored) a2data.txt | 1 + 1 file changed, 1 insertion(+) create mode 100644 a2data.txtJackFeng@JackFeng MINGW64 /d/Practice/SQL (master)$ git log --pretty=oneline -159a88161e630f0853b852946fddb6c7e787906fe (HEAD -&gt; master, master-two) add file 冲突解决 当对分叉分支进行合并时，如果两个分支都对同一文件进行了修改，那么合并时就有可能会产生冲突情况。 如果两个分支对同一文件的修改是有规律的，比如对不同地方的修改，那么git工具可以实现自动合并. 如果无法自动合并，则需要对冲突文件进行手动修改，修改完成后使用git add表示冲突已经解决，然后使用git commit进行提交 示例：在master分支上对两个文件进行修改提交. a2data.txt和*DataScience。 然后切换到master-O分支上对两个文件进行修改提交. 文件由于修改的是不同地方，所以自动合并。 我们查看DataScience文件的内容，==上面和下面的内容分别代表了不同分支的修改内容，将冲突标记去掉，然后内容根据需求进行恰当的修改，然后进行一次提交即完成了冲突的解决。 修改文件相同则会产生合并冲突 (merge conflict) master master-O 合并分支 分支同步 主要是 自己的分支与主分支保持同步。 步骤： 1、git remote add master &#103;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;:A2Data/A2Data.github.io.git // 主分支master 2、 git branch -v 查看是否添加 3、git fetch master // 获取主分支的最新修改到本地 4、git merge master/master-O // 将master分支修改内容merge到本地个人分支； // 该步骤或者可以分成2步： 1） # git checkout master-O； // checkout到master-O分支 2） # git merge master； //合并主分支修改到本地master分支； 5、git push //本地分支提交到github上的个人分支 分支暂存 git stash #将工作暂存git stash list #列出所有的暂存状态 从暂存区之中进行恢复，有两种处理方式：1.先恢复，而后再删除暂存git stash applygit stash drop2.恢复的同时也将stash内容删除git stash pop 当我们在分支上进行代码开发时，有可能会接到突发需求，而当前的代码尚未完成，所以还**不能直接提交。** 为了解决这样的问题，git就提供了分支暂存的机制，可以将开发一半的分支进行保存，在适当的时候进行代码恢复。 示例：在master-two分支上新建文件，然后添加到暂存区表示尚未完成的任务，对当前分支进行暂存，git status显示工作空间是干净的。 欢迎关注","categories":[{"name":"Git","slug":"Git","permalink":"http://www.a2data.cn/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.a2data.cn/tags/Git/"}]},{"title":"带你玩转idea","slug":"Tools/带你玩转idea","date":"2020-03-31T14:51:10.000Z","updated":"2020-09-11T09:28:58.975Z","comments":true,"path":"posts/64846.html","link":"","permalink":"http://www.a2data.cn/posts/64846.html","excerpt":"IDEA 玩转详细教程","text":"IDEA 玩转详细教程 IDEA快捷键操作 颜色主题插件： **Material Theme UI Plugin ** 快捷键提醒： **Key Promoter X ** 查找Bug： QAPlig-FindBugs 热部署: JRebel 代码规范： Alibaba Java Coding Guidelines 字体推荐： Droid Sans Mono 代码检测：SonarLint(Sonarqube) 主题网站： http://www.riaway.com/index.php idea结合sonarLint进行的代码分析 idea结合sonar的话，可以下载sonarLint插件，操作步骤如下： 进入idea ，进入插件安装，在插件市场中搜索sonarLint，点击进行安装后重启idea； 配置sonarLint插件，设置settings中，查找到other settings,然后选择sonarLint General Setting ,在右侧的输入 接下来输入要连接的服务器的登录信息，如输入token或者是使用账号和密码的方式 配置当前的项目和sonar的关系,点击进入设置settings-&gt;other settings-&gt;SonarLint Project Settings Bind to Server 选择刚才配置的服务器信息。SonarQube project的选择可以点击Search in list查看sonar仓库中配置的项目信息，完成选择以后点击ok即可 代码分析，可以查看到当前的窗口中多了一个SonarLint的窗口（如无此窗口，可以点击analysis菜单进行查找），在其中选择report，点击文件夹图标，会弹窗提示，点击process之后即可进行项目分析。 JRebel 激活 GUIDS： https://www.guidgen.com/ 步骤： 步骤1:生成一个GUID：在线生成GUID地址 步骤2: 根据反向代理服务器地址拼接激活地址 服务器地址： https://jrebel.qekang.com/{GUID} Top1 循环.打印,Mainfori/sout/psvm+Tab 即可生成循环、System.out、main方法等boilerplate样板代码例如要输入for(User user : users)只需输入user.for+Tab 12比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。代码标签输入完成后，按Tab，生成代码。 Top2 类和包操作 Alt+Insert 生成代码(如get,set方法等) (右键 Generate） Ctrl+Alt+T 生成 try catch 或者 Alt+enter CTRL+ALT+T 把选中的代码放在 TRY{} IF{} ELSE{} 里 Ctrl + O 重写方法 Ctrl + I 实现方法 Ctr+shift+U 大小写转化 ALT+回车 导入包,自动修正 ALT+/ 代码提示 CTRL+空格 代码提示 CTRL+J 自动代码 Ctrl+Shift+J 整合两行为一行 CTRL+SHIFT+SPACE 自动补全代码 CTRL+ALT+L 格式化代码 CTRL+ALT+I 自动缩进 CTRL+ALT+O 优化导入的类和包 CTRL+E 最近更改的代码 CTRL+ALT+SPACE 类名或接口名提示 CTRL+P 方法参数提示 CTRL+Q 可以看到当前方法的声明 Shift+F6 重构-重命名 (包、类、方法、变量、甚至注释等) Ctrl+Alt+V 提取变量 Top3 查询快捷键 Ctrl＋Shift＋Backspace 可以跳转到上次编辑的地方 CTRL+ALT+ left/right 前后导航编辑过的地方 ALT+7 靠左窗口显示当前文件的结构 Ctrl+F12 浮动显示当前文件的结构 ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 CTRL+ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 Ctrl+Shift+Alt+N 查找类中的方法或变量 双击SHIFT 在项目的所有目录查找文件 Ctrl+N 查找类 Ctrl+Shift+N 查找文件 CTRL+G 定位行 CTRL+F 在当前窗口查找文本 CTRL+SHIFT+F 在指定窗口查找文本 CTRL+R 在 当前窗口替换文本 CTRL+SHIFT+R 在指定窗口替换文本 ALT+SHIFT+C 查找修改的文件 CTRL+E 最近打开的文件 F3 向下查找关键字出现位置 SHIFT+F3 向上一个关键字出现位置 选中文本，按Alt+F3 高亮相同文本，F3逐个往下查找相同文本 F4 查找变量来源 CTRL+SHIFT+O 弹出显示查找内容 Ctrl+W 选中代码 连续按会有其他效果 F2 或Shift+F2 高亮错误或警告快速定位 Ctrl+Up/Down 光标跳转到第一行或最后一行下 Ctrl+B 快速打开光标处的类或方法 CTRL+ALT+B 找所有的子类 CTRL+SHIFT+B 找变量的类 Ctrl+Shift+上下键 上下移动代码 Ctrl+Alt+ left/right 返回至上次浏览的位置 Ctrl+X 删除行 Ctrl+D 复制行 Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/…/） Ctrl+H 显示类结构图 Ctrl+Q 显示注释文档 Alt+F1 查找代码所在位置 Alt+1 快速打开或隐藏工程面板 Alt+ left/right 切换代码视图 ALT+ ↑/↓ 在方法间快速移动定位 CTRL+ALT+ left/right 前后导航编辑过的地方 Ctrl＋Shift＋Backspace 可以跳转到上次编辑的地 Alt+6 查找TODO Top4 其它快捷键 SHIFT+ENTER 另起一行 CTRL+Z 倒退(撤销) CTRL+SHIFT+Z 向前(取消撤销) CTRL+ALT+F12 资源管理器打开文件夹 ALT+F1 查找文件所在目录位置 SHIFT+ALT+INSERT 竖编辑模式 CTRL+F4 关闭当前窗口 Ctrl+Alt+V 可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+~ 快速切换方案（界面外观、代码风格、快捷键映射等菜单） Top5 svn快捷键 ctrl+k 提交代码到SVNctrl+t 更新代码 Top6 调试快捷键 常用的 F8 F7 F9 最值得一提的 就是 Drop Frame 可以让运行过的代码从头再来 123456789101112131415161718alt+F8 debug时选中查看值 Alt+Shift+F9，选择 Debug Alt+Shift+F10，选择 Run Ctrl+Shift+F9，编译 Ctrl+Shift+F8，查看断点 F7，步入 Shift+F7，智能步入 Alt+Shift+F7，强制步入 F8，步过 Shift+F8，步出 Alt+Shift+F8，强制步过 Alt+F9，运行至光标处 Ctrl+Alt+F9，强制运行至光标处 F9，恢复程序 Alt+F10，定位到断点 Top7 重构 Ctrl+Alt+Shift+T，弹出重构菜单Shift+F6，重命名F6，移动F5，复制Alt+Delete，安全删除 Top8 Ctrl+Alt+N，内联Ø 命令： Ctrl+Shift+A 可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。 Ø 新建： Alt+Insert可以新建类、方法等任何东西。 Ø 格式化代码： 格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。 Ø 切换窗口： Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。 Ø 单元测试： Ctrl+Alt+T创建单元测试用例。 Ø 运行： Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。 Ø 调试： F7/F8/F9分别对应Step into，Step over，Continue。 Top9 自定义Ø 水平分屏 Ctrl+| 小功能Ctrl+Shift+V粘贴很早以前拷贝过的， Alt+Shift+Insert进入到列模式进行按列选中。 Ø切来切去： Ctrl+Tab Ø选你所想： Ctrl+W Ø代码生成： Template/Postfix +Tab Ø发号施令： Ctrl+Shift+A Ø无处藏身： Shift+Shift Ø自动完成： Ctrl+Shift+Enter Ø创造万物： Alt+Insert Top10 舍我其谁Ø智能补全： Ctrl+Shift+Space Ø自我修复： Alt+Enter Ø重构一切： Ctrl+Shift+Alt+T CTRL+ALT+ left/right 前后导航编辑过的地方Ctrl＋Shift＋Backspace可以跳转到上次编辑的地","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.a2data.cn/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"GitBook","slug":"Tools/GitBook","date":"2019-12-30T07:44:58.000Z","updated":"2020-09-11T09:28:58.965Z","comments":true,"path":"posts/44947.html","link":"","permalink":"http://www.a2data.cn/posts/44947.html","excerpt":"‘GitBook文档，安装使用’","text":"‘GitBook文档，安装使用’ GitBook1、安装 安装和使用GitBook 完成GitBook的安装只需要几分钟。 GitBook.com GitBook.com为您提供简单高效的图书在线撰写、发布和托管方案， 你可以通过 进行在线编辑、或者使用GitBook 本地编辑器在本地电脑上编辑。 本地安装 要求 GitBook的安装非常简单。 您的系统只需满足这两个要求： NodeJS（推荐使用v4.0.0及以上版本） Windows，Linux，Unix或Mac OS X 使用NPM安装 安装GitBook的最好方法是通过 NPM 安装。 在已经安装好NodeJS和NPM的电脑上，通过命令行窗口，输入以下命令安装GitBook： 123npm install gitbook-cli -g gitbook-cli 2、使用 创建一本书 1gitbook init 如果你想用现有的目录来创建一本书，你可以通过运行 gitbook init ./directory来实现 使用下面的命令预览您创建的图书： 1gitbook serve 或者使用以下命令构建静态网站： 123gitbook build 安装其他版本gitbook命令可以方便地下载和安装不同版本的GitBook来测试你的书：$ gitbook fetch 4.0.0-alpha.1 使用gitbook ls-remote列出可用于安装的远程版本。 $ gitbook ls-remote Available GitBook Versions: 4.0.0-alpha.5, …部分省略…, 4.0.0-alpha.1, 3.2.2, 3.2.1, …部分省略…, 2.0.0-alpha.1 Tags: latest : 3.2.2 pre : 4.0.0-alpha.5 调试 您可以使用–log=debug和–debug来获得更详细的错误消息（堆栈跟踪）。例如： $ gitbook build ./ –log=debug –debug or $ gitbook serve ./ –log=debug –debug","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"}]},{"title":"14.Python强化练习","slug":"Python/Python速成/14、Python强化练习","date":"2019-12-30T07:43:39.000Z","updated":"2020-09-11T08:14:26.808Z","comments":true,"path":"posts/47220.html","link":"","permalink":"http://www.a2data.cn/posts/47220.html","excerpt":"Python学习阶段钱","text":"Python学习阶段钱 Python强化练习1、给程序传参数123import sysprint(sys.argv) 2、列表推导式 所谓的列表推导式，就是指的轻量级循环创建列表 2.1、基本的方式 请忽略手残的错误。。。 2.2、在循环的过程中使用if 2.3、2个for循环 2.4、3个for循环 2.5、练习 请写出一段 Python 代码实现分组一个 list 里面的元素,比如 [1,2,3,…100]变成 [[1,2,3],[4,5,6]….] 参考答案 3、set、list、tuple set是集合类型 set、list、tuple之间可以相互转换使用set，可以快速的完成对list中的元素去重复的功能","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"从零搭建ubuntu","slug":"Tools/从零搭建ubuntu","date":"2019-12-30T02:09:23.000Z","updated":"2020-09-11T09:28:58.982Z","comments":true,"path":"posts/48061.html","link":"","permalink":"http://www.a2data.cn/posts/48061.html","excerpt":"安装ubuntu、sublime骚操作","text":"安装ubuntu、sublime骚操作 Ubuntu系统1、虚拟机操作系统VMware Virtualbox 1、https://www.vmware.com/cn.html 2、https://www.virtualbox.org/ 2、小编哪个都玩得很溜此处采用 Virtualbox 原因是不用破解。 支持一下官方。 3、 下载ubuntu镜像 这里说明一下，官方下载贼慢。 https://ubuntu.com/download/desktop 12345# 所以小编收集了一个镜像网站 比官网快NNN倍不止http://mirrors.aliyun.com/ubuntu-releases/#以及上传到自己的微云网盘，供大家使用。如有需要，请加小编微信。 4、万事具备开始安装 每一步都是截图，这样更加直观明了。 走你！！！ 5、ubuntu安装5.1、启动 5.2、选择语言 5.3、根据自己需求安装 5.4、选择地区 5.5、创建用户信息 6、安装完成重启 7、安装扩展组件 支持全屏，自定义大小。 双向拖动等。 Vmware 中安装的是 Tools 需要sudo ./ 执行解压的文件即可 Vbox 直接根据菜单操作安装即可。 8、Python 安装pip 9、安装sublime 对于Ubuntu 18.04及更高版本，只需打开Ubuntu软件搜索并安装sublime-text即可 对于Ubuntu 16.04，打开终端（Ctrl + Alt + T）并运行snap命令来安装： sudo apt install snapd &amp;&amp; sudo snap install sublime-text 1.通过Ctrl + Alt + T键盘快捷键或从应用程序启动器打开终端。 打开时，运行命令添加密钥环： wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add - 在提示时键入用户密码（无星号反馈），然后按Enter键。 2.然后运行命令添加apt存储库： echo “deb https://download.sublimetext.com/ apt/stable/“ | sudo tee /etc/apt/sources.list.d/sublime-text.list 3.最后通过Synaptic包管理器或运行命令安装sublime-text包： sudo apt update &amp;&amp; sudo apt install sublime-text 卸载：要删除编辑器，请运行命令：sudo apt remove –autoremove sublime-text要删除apt存储库，请转到“软件和更新” - &gt;“其他软件”。 10、玩转sublime 选择类Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 此功能很好。当你想同时修改多个相同代码的时候，比如，将echo 统一改成print，可以双击选中echo，然后Ctrl+D，会向下连选echo，重复，直到你满意的位置，然后就可以统一编辑了。 有人说了，这不就是查找替换呀，是的，查找替换是可以实现，但这种方式更直观一些，而且不易出错。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个例子：快速选中并更改所有相同的变量名、函数名等。Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。Ctrl+M 光标移动至括号内结束或开始的位置。Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。Ctrl+Shift+] 选中代码，按下快捷键，展开代码。Ctrl+K+0 展开所有折叠代码。Ctrl+← 向左单位性地移动光标，快速移动光标。Ctrl+→ 向右单位性地移动光标，快速移动光标。shift+↑ 向上选中多行。shift+↓ 向下选中多行。Shift+← 向左选中文本。Shift+→ 向右选中文本。Ctrl+Shift+← 向左单位性地选中文本。Ctrl+Shift+→ 向右单位性地选中文本。Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 编辑类Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。Ctrl+Shift+D 复制光标所在整行，插入到下一行。Tab 向右缩进。Shift+Tab 向左缩进。Ctrl+K+K 从光标处开始删除代码至行尾。Ctrl+Shift+K 删除整行。Ctrl+/ 注释单行。Ctrl+Shift+/ 注释多行。Ctrl+K+U 转换大写。Ctrl+K+L 转换小写。Ctrl+Z 撤销。Ctrl+Y 恢复撤销。Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。Ctrl+F2 设置书签Ctrl+T 左右字母互换。F6 单词检测拼写 搜索类Ctrl+F 打开底部搜索框，查找关键字。Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 显示类Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。Ctrl+PageDown 向左切换当前窗口的标签页。Ctrl+PageUp 向右切换当前窗口的标签页。Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字）Alt+Shift+2 左右分屏-2列Alt+Shift+3 左右分屏-3列Alt+Shift+4 左右分屏-4列Alt+Shift+5 等分4屏Alt+Shift+8 垂直分屏-2屏Alt+Shift+9 垂直分屏-3屏Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式Shift+F11 免打扰模式","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.a2data.cn/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"MapReduce深入解析","slug":"Hadoop/MapReduce深入解析","date":"2019-12-27T03:04:21.000Z","updated":"2020-09-11T08:40:26.227Z","comments":true,"path":"posts/39508.html","link":"","permalink":"http://www.a2data.cn/posts/39508.html","excerpt":"MapReduce必备原理解析","text":"MapReduce必备原理解析 分布式计算框架MapReduce 1、概念 MapReduce是一个基于集群的计算平台，是一个简化分布式编程的计算框架，是一个将分布式计算抽象为Map和Reduce两个阶段的编程模型。（这句话记住了是可以用来装逼的） 2、执行流程 MapReduce程序执行图。 1. JobClient：运行于client node，负责将MapReduce程序打成Jar包存储到HDFS，并把Jar包的路径提交到Jobtracker，由Jobtracker进行任务的分配和监控。 2. JobTracker：运行于name node，负责接收JobClient提交的Job，调度Job的每一个子task运行于TaskTracker上，并监控它们，如果发现有失败的task就重新运行它。 3. TaskTracker：运行于data node，负责主动与JobTracker通信，接收作业，并直接执行每一个任务。 4. HDFS：用来与其它实体间共享作业文件。 MapReduce作业流程 1、JobClient通过RPC协议向JobTracker请求一个新应用的ID，用于MapReduce作业的ID 2、JobTracker检查作业的输出说明。例如，如果没有指定输出目录或目录已存在，作业就不提交，错误抛回给JobClient，否则，返回新的作业ID给JobClient 3、JobClient将作业所需的资源（包括作业JAR文件、配置文件和计算所得得输入分片）复制到以作业ID命名的HDFS文件夹中 4、JobClient通过submitApplication()提交作业 5、JobTracker收到调用它的submitApplication()消息后，进行任务初始化 6、JobTracker读取HDFS上的要处理的文件，开始计算输入分片，每一个分片对应一个TaskTracker 7、TaskTracker通过心跳机制领取任务（任务的描述信息） 8、TaskTracker读取HDFS上的作业资源（JAR包、配置文件等） 9、TaskTracker启动一个java child子进程，用来执行具体的任务（MapperTask或ReducerTask） 10、TaskTracker将Reduce结果写入到HDFS当中 3、工作原理 4、Map任务处理 1、读取HDFS中的文件。每一行解析成一个&lt;k,v&gt;。每一个键值对调用一次map函数 2、重写map()，对第一步产生的&lt;k,v&gt;进行处理，转换为新的&lt;k,v&gt;输出 3、对输出的key、value进行分区 4、对不同分区的数据，按照key进行排序、分组。相同key的value放到一个集合中 5、(可选) 对分组后的数据进行归约 5、Reduce任务处理 1、多个map任务的输出，按照不同的分区，通过网络复制到不同的reduce节点上 2、对多个map的输出进行合并、排序。 3、重写reduce函数实现自己的逻辑，对输入的key、value处理，转换成新的key、value输出 4、把reduce的输出保存到文件中","categories":[{"name":"大数据","slug":"大数据","permalink":"http://www.a2data.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"MapReduce","slug":"MapReduce","permalink":"http://www.a2data.cn/tags/MapReduce/"}],"author":"JackFeng"},{"title":"13.Python面向对象(4)","slug":"Python/Python速成/13、Python面向对象-4","date":"2019-12-25T15:22:13.000Z","updated":"2020-09-11T08:14:26.856Z","comments":true,"path":"posts/55248.html","link":"","permalink":"http://www.a2data.cn/posts/55248.html","excerpt":"Python面向对象异常、模块","text":"Python面向对象异常、模块 Python面向对象(4)1、异常的传递1.1、try嵌套 首先从 test.txt 文件中读取到信息 ^c 关闭文件 没有这个文件 最后的finally 1.2、函数嵌套调用中 如果try嵌套，那么如果里面的try没有捕获到这个异常，那么外面的try会接收到这个异常，然后进行处理，如果外边的try依然没有捕获到，那么再进行传递。。。 如果一个异常是在一个函数中产生的，例如函数A—-&gt;函数B—-&gt;函数C,而异常是在函数C中产生的，那么如果函数C中没有对这个异常进行处理，那么这个异常会传递到函数B中，如果函数B有异常处理那么就会按照函数B的处理方式进行执行；如果函数B也没有异常处理，那么这个异常会继续传递，以此类推。。。如果所有的函数都没有处理，那么此时就会进行异常的默认处理，即通常见到的那样 注意观察上图中，当调用test3函数时，在test1函数内部产生了异常，此异常被传递到test3函数中完成了异常处理，而当异常处理完后，并没有返回到函数test1中进行执行，而是在函数test3中继续执行 2、抛出自定义的异常 可以用``raise`语句来引发一个异常。异常/错误对象必须有一个名字，且它们应是Error或Exception类的子类 以上程序中，关于代码#super().__init__()的说明 这一行代码，可以调用也可以不调用，建议调用，因为__init__方法往往是用来对创建完的对象进行初始化工作，如果在子类中重写了父类的__init__方法，即意味着父类中的很多初始化工作没有做，这样就不保证程序的稳定了，所以在以后的开发中，如果重写了父类的__init__方法，最好是先调用父类的这个方法，然后再添加自己的功能 3、异常处理中抛出异常 4、模块介绍4.1、模块 说的通俗点：模块就好比是工具包，要想使用这个工具包中的工具(就好比函数)，就需要导入这个模块 4.2、import 在python中主要是 用关键字，import 来引入某个模块， 在调用math模块中的函数时，必须这样引用： 123456789模块名.函数名import math#这样会报错print sqrt(2)#这样才能正确输出结果print math.sqrt(2) 4.3、from…import Python的from语句让你从模块中导入一个指定的部分到当前命名空间中 语法如下： 1from modname import name1[, name2[, ... nameN]] 例如，要导入模块fib的fibonacci函数，使用如下语句： 1from fib import fibonacci 注意 不会把整个fib模块导入到当前的命名空间中，它只会将fib里的fibonacci单个引入 4.4、from … import * 把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明： 1from modname import * 注意 这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。 4.5、 as 4.6、定位模块 当你导入一个模块，Python解析器对模块位置的搜索顺序是： 当前目录 如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。 如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/ 模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。 5、模块制作5.1、定义自己的模块 在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。比如有这样一个文件test.py，在test.py中定义了函数add 123#test.pydef add(a,b): return a+b 5.2、调用自己定义的模块 那么在其他文件中就可以先import test，然后通过test.add(a,b)来调用了，当然也可以通过from test import add来引入 12345#test1.pyimport testresult = test.add(66,22)print(result) 5.3、测试模块 在实际开中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在py文件中添加一些测试信息，例如： 1234567#test.pydef add(a,b):return a+b# 用来进行测试ret = add(123,543)print(&#x27;int test.py file,,,,123+543=%d&#x27;%ret) 如果此时，在其他py文件中引入了此文件的话，想想看，测试的那段代码是否也会执行呢！ 12345#test1.pyimport testresult = test.add(66,22)print(result) 6、模块中的_all_6.1、没有 6.2、有 7、使用Pip安装模块 pip 是 python 自带的一个软件，相当于手机里的应用市场，可以用来安装、卸载、搜索 python 的常见模块。 直接输入 pip 后回车，可以查看 pip 命令的所有可用参数。 7.1、安装模块在命令行执行 1pip install 模块名 7.2、卸载模块在命令行执行 1pip uninstall 模块名 7.3、搜索模块在命令行执行 1pip search 模块名","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"12.Python面向对象(3)","slug":"Python/Python速成/12、Python面向对象-3","date":"2019-12-25T13:08:42.000Z","updated":"2020-09-11T08:14:26.803Z","comments":true,"path":"posts/59346.html","link":"","permalink":"http://www.a2data.cn/posts/59346.html","excerpt":"Python面向对象单例模式","text":"Python面向对象单例模式 Python面向对象(3)1、_new_方法 __new__和__init__的作用 __new__至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供 __new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以return父类__new__出来的实例，或者直接是object的__new__出来的实例 __init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值 我们可以将类比作制造商，__new__方法就是前期的原材料购买环节，__init__方法就是在有原材料的基础上，加工，初始化商品环节 注意点 2、单例模式 单例模式： ​ 确保某一个类，只有一个实例，并且自行实例化向整个系统提供这个实例，这个类称为 单例类，单例模式 是一种对象创建型模式。 创建单例，保证只有1个对象 创建单例模式，只执行1次__init__方法 3、异常介绍异常简介 如下 说明: 打开一个不存在的文件123.txt，当找不到123.txt 文件时，就会抛出给我们一个IOError类型的错误，No such file or directory：123.txt （没有123.txt这样的文件或目录） 异常: 当Python检测到一个错误时，解释器就无法继续执行了，反而出现了一些错误的提示，这就是所谓的”异常” 4、捕获异常4.1、捕获异常(try..except…) 把可能出现问题的代码，放在try中 把处理异常的代码，放在except中 说明: 此程序看不到任何错误，因为用except 捕获到了IOError异常，并添加了处理的方法 pass 表示实现了相应的实现，但什么也不做；如果把pass改为print语句，那么就会输出其他信息 4.2、except捕获多个异常 想一想: 上例程序，已经使用except来捕获异常了，为什么还会看到错误的信息提示？ 答: except捕获的错误类型是IOError，而此时程序产生的异常为 NameError ，所以except没有生效 4.3、获取异常的信息描述 4.5、else 咱们应该对else并不陌生，在if中，它的作用是当条件不满足时执行的实行；同样在try…except…中也是如此，即如果没有捕获到异常，那么就执行else中的事情 4.6、try…finally… try…finally…语句用来表达这样的情况： 在程序中，如果一个段代码必须要执行，即无论异常是否产生都要执行，那么此时就需要使用finally。 比如文件关闭，释放锁，把数据库连接返还给连接池等 test.txt文件中每一行数据打印，但是我有意在每打印一行之前用time.sleep方法暂停2秒钟。这样做的原因是让程序运行得慢一些。在程序运行的时候，按Ctrl+c中断（取消）程序。 我们可以观察到KeyboardInterrupt异常被触发，程序退出。但是在程序退出之前，finally从句仍然被执行，把文件关闭。","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"11.Python面向对象(2)","slug":"Python/Python速成/11、Python面向对象-2","date":"2019-12-23T14:59:23.000Z","updated":"2020-09-11T08:14:26.846Z","comments":true,"path":"posts/30675.html","link":"","permalink":"http://www.a2data.cn/posts/30675.html","excerpt":"Python面向对象介绍中篇","text":"Python面向对象介绍中篇 Python面向对象(2)1、保护对象的属性 如果有一个对象，当需要对其进行修改属性时，有两种方法 对象名.属性名 = 数据 —-&gt;直接修改 对象名.方法名() —-&gt;间接修改 为了更好的保存属性安全，即不能随意修改，一般的处理方式为 将属性定义为私有属性 添加一个可以调用的方法，供调用 私有共有属性区分 它是以属性命名方式来区分，如果在属性名前面加了2个下划线’__’，则表明该属性是私有属性，否则为公有属性（方法也是一样，方法名前面加了2个下划线的话表示该方法是私有的，否则为公有的）。 2、_del_()方法 当有1个变量保存了对象的引用时，此对象的引用计数就会加1 当使用del删除变量指向的对象时，如果对象的引用计数不会1，比如3，那么此时只会让这个引用计数减1，即变为2，当再次调用del时，变为1，如果再调用1次del，此时会真的把对象进行删除 3、单继承3.1、继承的概念 在程序中，继承描述的是事物之间的所属关系，例如猫和狗都属于动物，程序中便可以描述为猫和狗继承自动物；同理，波斯猫和巴厘猫都继承自猫，而沙皮狗和斑点狗都继承自狗，如下如所示： 3.2、继承示例 说明： 虽然子类没有定义__init__方法，但是父类有，所以在子类继承父类的时候这个方法就被继承了，所以只要创建Bosi的对象，就默认执行了那个继承过来的__init__方法 总结 子类在继承的时候，在定义类时，小括号()中为父类的名字 父类的属性、方法，会被继承给子类 3.3、注意点 私有的属性，不能通过对象直接访问，但是可以通过方法访问 私有的方法，不能通过对象直接访问 私有的属性、方法，不会被子类继承，也不能被访问 一般情况下，私有的属性、方法都是不对外公布的，往往用来做内部的事情，起到安全的作用 4、多继承 所谓多继承，即子类有多个父类，并且具有他们的特征 注意点 想一想: 如果在上面的多继承例子中，如果父类A和父类B中，有一个同名的方法，那么通过子类去调用的时候，调用哪个？ 5、重写与调用父类方法5.1、重写父类方法 所谓重写，就是子类中，有一个和父类相同名字的方法，在子类中的方法会覆盖掉父类中同名的方法 5.2、调用父类方法 6、多态 其实多态的概念，一般应用于Java这类强类型语言中， 而Python崇尚“鸭子类型” 所谓多态：定义时的类型和运行时的类型不一样，此时就成为多态 Python伪代码实现Java或C#的多态 鸭子类型 7、类、实例 | 属性7.1、类属性12345678910class People(object): name = &#x27;A2Data&#x27; #公有的类属性 __age = 22 #私有的类属性p = People()print(p.name) #正确print(People.name) #正确print(p.__age) #错误，不能在类外通过实例对象访问私有的类属性print(People.__age) #错误，不能在类外通过类对象访问私有的类属性 7.2、实例属性(对象属性)123456789101112131415class People(object): address = &#x27;北京&#x27; #类属性 def __init__(self): self.name = &#x27;A2Data&#x27; #实例属性 self.age = 22 #实例属性p = People()p.age =18 #实例属性print(p.address) #正确print(p.name) #正确print(p.age) #正确print(People.address) #正确print(People.name) #错误print(People.age) #错误 通过实例(对象)去修改类属性 123456789101112class People(object): country = &#x27;china&#x27; #类属性print(People.country)p = People()print(p.country)p.country = &#x27;japan&#x27; print(p.country) #实例属性会屏蔽掉同名的类属性print(People.country)del p.country #删除实例属性print(p.country) 归纳 如果需要在类外修改类属性，必须通过类对象去引用然后进行修改。如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，不会影响到类属性，并且之后如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性。 8、静态和类 | 方法8.1、类方法 类对象所拥有的方法，需要用修饰器@classmethod来标识其为类方法，对于类方法，第一个参数必须是类对象，一般以cls作为第一个参数（当然可以用其他名称的变量作为其第一个参数，但是大部分人都习惯以’cls’作为第一个参数的名字，就最好用’cls’了），能够通过实例对象和类对象去访问。 用类方法对类属性修改之后，通过类对象和实例对象访问都发生了改变 8.2、静态方法 需要通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Python烤地瓜案例","slug":"Python/Python速成/Python烤地瓜案例","date":"2019-12-23T04:26:20.000Z","updated":"2020-09-11T07:51:20.131Z","comments":true,"path":"posts/16550.html","link":"","permalink":"http://www.a2data.cn/posts/16550.html","excerpt":"Python烤地瓜实例解析","text":"Python烤地瓜实例解析 Python烤地瓜实例建议跟着操作，所以小编多数以截图的方式 为了更好的理解面向对象编程，下面以“烤地瓜”为案例，进行分析 定义地瓜类，存储烤熟的程度和添加的佐料，同时要提供烤地瓜和添加佐料的功能 1、分析属性事例方法 cook() : 把地瓜烤一段时间 addCondiments() : 给地瓜添加配料 __init__() : 设置默认的属性 __str__() : 让print的结果看起来更好一些 2、定义类并且测试 3、测试cook方法 4、自定义方法 5、完整代码 6、测试输出效果","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"10.Python面向对象(1)","slug":"Python/Python速成/10、Python面向对象-1","date":"2019-12-23T02:31:34.000Z","updated":"2020-09-11T08:14:26.843Z","comments":true,"path":"posts/34771.html","link":"","permalink":"http://www.a2data.cn/posts/34771.html","excerpt":"Python面向对象介绍上篇","text":"Python面向对象介绍上篇 Python面向对象1、面向对象介绍 思考 例如：你有一个想法，你要做一个项目。然后呢，你聚集了n个人，说明你要做啥，然后大家开始干。 根据小编的经验，这个项目肯定是失败的。 因为每个人做的事情很多，分工不明确，有些肯定到最后都是没人做的，所以问题来了，必须要进行分工， 哪些人搭架子，做什么。哪些负责哪一块。 例如：数一下如下字符串有多少个字符 1234567a2datahelloworldwwwa2datacna2data,helloworld,www,a2data,cn显然，被分组后的字符更容易计数 总结： 大型的项目，必须要进行分工，将函数分为几个不同的类型，每个人负责一个或多个类型，比如一个人负责网站首页，一个人负责订单界面，一个人负责用户设置页面。 面向对象与面向过程 面向过程：根据业务逻辑从上到下写代码 面向对象：将数据与函数绑定到一起，分类进行封装，每个程序员只要负责分配给自己的分类，这样能够更快速的开发程序，减少了重复代码 对于小编而已，跟大家一样，刚开始都喜欢面向过程开发。其往往用一长段代码来实现指定功能，开发过程的思路是将数据与函数按照执行的逻辑顺序组织在一起，数据与函数分开考虑。 面向对象编程（Object Oriented Programming，OOP，面向对象程序设计） 解决吃啤酒鸭的问题 第一种方式（面向过程）: 12345671、养鸭子2、鸭子长成3、杀4、作料5、烹饪6、吃 7、卒 第二种方式（面向对象）: 1231、找个卖啤酒鸭的人 2、给钱 交易3、吃 需要了解的定义性文字: 面向对象(object-oriented ;简称: OO) 至今还没有统一的概念 我这里把它定义为: 按人们 认识客观世界的系统思维方式,采用基于对象(实体)的概念建立模型,模拟客观世界分析、设 计、实现软件的办法。 面向对象编程(Object Oriented Programming-OOP) 是一种解决软件复用的设计和编程方法。 这种方法把软件系统中相近相似的操作逻辑和操作 应用数据、状态,以类的型式描述出来,以对象实例的形式在软件系统中复用,以达到提高软件开发效率的作用。 2、类和对象2.1、类 人以类聚 物以群分 具有相似内部状态和运动规律的实体的集合（抽象） 具有相同属性和行为事物的统称 类是抽象的，使用的时候，通常一个类可以找到多个对象。 例如：轮胎，汽车，飞机，推车..等等 2.2、对象 某一个具体事物的存在，现实中就是看得见摸得着的。 code: 可以直接使用的 2.3、类与对象的关系 类就是创建对象的模板 2.4、类的构成 类(Class) 由3个部分构成 类的名称:类名 类的属性:一组数据 类的方法:允许对进行操作的方法 (行为) 狗类的设计 类名:狗(Dog) 属性:品种 、毛色、性别、名字、 腿儿的数量 方法(行为/功能):叫 、跑、咬人、吃、摇尾巴 2.5、类的抽象 拥有相同(或者类似)属性和行为的对象都可以抽像出一个类 方法:一般名词都是类(名词提炼法) 3、定义类 定义一个类，格式如下： 12class 类名: 方法列表 说明： 定义类时有2种：新式类和经典类，如下的Car为经典类，如果是Car(object)则为新式类 类名 的命名规则按照”大驼峰” 4、创建对象python中，可以根据已经定义的类去创建出一个个对象 创建对象的格式为: 1对象名 = 类名() 创建对象demo: 12345678910111213141516171819# 定义类class Car: # 移动 def move(self): print(&#x27;车在奔跑...&#x27;) # 鸣笛 def toot(self): print(&quot;车在鸣笛.....&quot;)# 创建一个对象，并用变量BMW来保存它的引用BM = Car()BM.color = &#x27;黑色&#x27;BM.wheelNum = 4 #轮子数量BM.move()BM.toot()print(BM.color)print(BM.wheelNum) 5、Self理解Self 所谓的self，可以理解为自己 某个对象调用其方法时，python解释器会把这个对象作为第一个参数传递给self，所以开发者只需要传递后面的参数即可 6、init6.1、使用方式1234def 类名: #初始化函数，用来完成一些默认的设定 def __init__(): pass 6.2、init()方法调用123456789101112131415# 定义汽车类class Car: def __init__(self): self.wheelNum = 4 self.color = &#x27;蓝色&#x27; def move(self): print(&#x27;车在跑，目标:北京&#x27;)# 创建对象BM = Car()print(&#x27;车的颜色为:%s&#x27;%BM.color)print(&#x27;车轮胎数量为:%d&#x27;%BM.wheelNum) __init__()方法，在创建一个对象时默认被调用，不需要手动调用 __init__(self)中，默认有1个参数名字为self，如果在创建对象时传递了2个实参，那么__init__(self)中出了self作为第一个形参外还需要2个形参，例如__init__(self,x,y) __init__(self)中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递进去 7、“魔法”方法 定义 __str__() 方法 在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法 当使用print输出对象的时候，只要自己定义了__str__(self)方法，那么就会打印从在这个方法中return的数据","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"面试拆招详解","slug":"Tools/面试拆招详解","date":"2019-12-22T01:43:28.000Z","updated":"2020-09-11T09:28:58.972Z","comments":true,"path":"posts/9812.html","link":"","permalink":"http://www.a2data.cn/posts/9812.html","excerpt":"面试精选！！！","text":"面试精选！！！ 面试拆招1、请你自我介绍一下自己好吗? 回答提示:一般人回答这个问题过于平常,只说姓名、年龄、爰好、工作经验,这些在简历上都有。其实,企业最希望知道的是求职者能否胜任工作,包括:*最强的技能、最深研究的知识领域、个性中最积极的部分、做过的最成功的事、可以和学习无关,也可以和学习有关,但要突出积极的个性和做事的能力,说得合情合理企业才会相信。企业很重视一个人的礼貌,求职者要尊重考官,在回答每个问题之后都说一句“谢谢”,企业喜欢有礼貌的求职者。 2、你觉得你个性上最大的优点是什么? 回答提示: 沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱。我在xxxx经过一到两年的培训及项目实战,加上实习工作，使我适合这份工作。(此处根据自己情况而改) 3、说说你最大的缺点? 回答提示: 这个问题企业问的概率很大,通常不希望听到直回答的缺点是什么等,如果求职者说自己小心眼、爱忌妒非常懒、脾气大、工作效率低,企业肯定不会录用你绝对不要自作聪明地回答“我最大的缺点是过于追求完美”,有的人以为这样回答会显得自己比较出色,但事实上,他已经岌岌可危了。企业喜欢求职者从自己的优点说起,中间加一些小缺点,最后再把问题转回到优点上,突出优点的部分,企业喜欢聪明的求职者。 4、你对薪资的要求? 回答提示: 如果你对薪酬的要求太低,那显然贬低自己的能力;如果你对薪酣的要求太高,那又会显得你分量过重,公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算,因而他们第一次提出的价钱往往是他们所能给予的最高价钱,他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。 回答样本一: 我对工资没有硬性要求,我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会,所以只要条件公平,我则不会计较太多 回答祥本二: 我受过系统的软件编程的训练,不需要进行大量的培训,而且我本人也对编程特别感兴趣。因此,我希望公司能根据我的情况和市场标准的水平,给我合理的薪水 回答样本三: 如果你必须自己说出具体数目,请不要说一个宽泛的范围,那样你将只能得到最低限庋的数字。最好给出一个具体的数字,这样表明你已经对当今的人才市场作了调查,知道像自己这样学历的雇员有什么样的价值 5、你对加班的看法? 回答提示: 实际上好多公司问这个问题,并不证明一定要加班,只是想测试你是否愿意为公司奉献。 回答样本: 如果工作需要我会义不容辞加班,我现在单身没有任何家庭负担,可以全身心的投入工作。但同时我也会提高工作效率,减少不必要的加班。 6、如果通过这次面试我们录用了你,但工作一段时间却发现你根本不适合这个职位,你怎么办? 回答提示: 一段时间发现工作不适合我,有两种情况: ①如果你确实热爱这个职业,那你就要不断学习,虚心向领导和同事学习业务知识和处事经验,了解这个职业的精神内涵和职业要求,力争减少差距; ②你觉得这个职业可有可无,那还是趁早换个职业,去发现适合你的,你热爱的职业,那样你的发展前途也会大点,对单位和个人都有好处。 7、谈谈你对跳槽的看法? 回答提示: ①正常的“跳槽”能促进人才合理流动,应该支持。 ②频繁的跳槽对单位和个人双方都不利,应该反对。 8、工作中难以和同事、上司相处,你该怎么办? 回答提示: ①我会服从领导的指挥,配合同事的工作。 ②我会从自身找原因,仔鈿分析是不是自己工作做得不好让领导不满意,同事看不惯。还要看看是不是为人处世方面做得不好,如果是这样的话我会努力改正。 ③如果我找不到原因,我会找机会跟他们沟通,请他们指出我的不足,有问题就及时改正。 ④作为优秀的员工,应该时刻以大局为重,即使在段时间内,领导和同事对我不理解,我也会做好本职工作,虚心向他们学习,我相信,他们会看见我在努力,总有天会对我微笑的。 9、你对于我们公司了解多少? 回答提示: 在去公司面试前上网查一下该公司主营业务。如回答:贵公司有意改变策略,加强与国外大厂的QFM合作,自有品牌的部分则透过海外经销商. 10、最能慨括你自己的三个词是什么? 回答提示: 我经常用的三个词是:适应能力强,有责任心和做事有始终,结合具体例子向主考官解释。 11、你的业余爱好是什么? 回答提示: 找一些富于团体合作精神的,这里有一个真实的故事:有人被否决掉,因为他的爰好是深海潜水。主考官说:因为这是一项单人活动,我不敢肯定他能否适应团体工作 12、作为被面试者给我打一下分? 回答提示: 试着列出四个优点和一个非常非常非常小的缺点可以抱怨一下设施,没有明确责任人的缺点是不会有人介意的) 13、你为什么要离开原来的公司? 回答提示: ①回答这个问题时一定要小心,就算在前一个工作受到再大的委屈,对公司有多少的怨言,都千万不要表现出来,尤其要避免对公司本身主管的批评,避免面试官的负面情绪及印象。 建议此时最好的回答方式是将问题归咎在自己身上,例如觉得工作没有学习发展的空间,自己想在面试工作的相关产业中多加学习,或是前一份工作与自己的生涯规划不合等等,回答的答案最好是积极正面的。 ②我希望能获得一份更好的工作,如果机会来临,我会抓住。我觉得目前的工作,已经达到顶峰,即沒有升迁机会。 14、你欣赏哪种性格的人? 回答提示: 诚实、不死板而且容易相处的人、有“实际行动”的人。 15、你通常如何对待别人的批评? 回答提示: ①沈默是金,不必说什么,否则情况更糟,不过我会接受建设性的批评。 ②我会等大家冷靜下来再讨论。 16、怎样对待自己的失败? 回答提示: 我们大家生来都不是十全十美的,我相信我有第二个机会改正我的错误。 17、你为什么原意到我们公司来工作? 回答提示: 对于这个问题,你要格外小心,如果你已经对该单位作了研究,你可以回答一些详细的原因,像“公司本身的高技术开发环境很吸引我”,“我同公司出生在同样的时代,我希望能够进入一家与我共同成长的公司。”、“你们公司一直都稳定发展,在近几年来在市场上很有竞争力。”、“我认为贵公司能够给我禔供一个与众不同的发展道路。”这都显示出你已经做了一些调查,也说明你对自己的未来有了较为具体的远景规划。 18、对这项工作,你有哪些可预见的困难? 回答提示: ①不宜直接说出具体的困难,否则可能令对方怀疑应聘者不行。 ②可以尝试迂回战术,说出应聘者对困难所持有的态度一一工作中出现一些困难是正常的,也是难免的,但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备,任何困难都是可以克服。 19、如果录用了你,你将怎样开展工作? 回答提示: ①如果应聘者对于应聘的职位缺乏足够的了解,最好不要直接说出自己开展工作的具体办法。 ②可以尝试采迂回战术来回答,如“首先听取领导的指示和要求,然后就有关情况进行了解和熟悉,接下来制定一份近期的工作计划并报领导批准,最后根据计划开展工作。” 分析 这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性,而且重点想要知道细节。如果向思路中所讲灼迂回战术,面试官会认为回避问题,如果引导了几次仍是回避的话,此人绝对不会录用了。 20、你希望与什么样的上级共事? 回答提示: ①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识,这既是一个陷阱,又是一次机会。 ②最好回避对上级具体的希望,多谈对自己的要求。 ③如“做为刚步入社会的新人,我应该多要求自己尽快熟悉环境、适应环境,而不应该对环境提出什么要求,只要能发挥我的专长就可以了。 分析: 这个问题比较好的回答是,希望我的上级能够在工作中对我多指导,对我工作中的错误能够立即指出。总之，从上级指导这个方面谈,不会有大的纰漏 21、与上级意见不一时,你将怎么办? 回答提示: ①一般可以这样回答“我会给上级以必要的解释和提醒,在这种情况下,我会服从上级的意见。” ②如果面试你的是总经理,而你所应聘的职位另有一位经理,且这位理当时不在场,可以这样回答:“对于非原则性问题,我服从上级的意见,对于涉及公司利益的重大问题,我希望能向更高层领导反映” 分析: 这个问题的标准答案是思路①,如果用②的回答,必死无疑。你没有摸清楚改公司的内部情况,先想打小报告,这样的人没有人敢要。 22、为什么选择我们公司? 回答提示: 曾经在报章杂志看过关于贵公司的报道,与自己所追求的理念有志一同。而贵公司在业界的成绩也是有目共睹的,而且对员工的教育训练、升迁等世都很有制度。 分析: 去面试前先做功课,了解一下该公司的背景,让对方觉得你真的很有心想得到这份工作,而不只是探探路。 23、谈谈如何话应办公室工作的新环境? 回答提示: ①办公室里每个人有各自的岗位与职责,不得擅离岗位。 ②根据领导指示和工作安排,制定工作计划,提前预备,并按计划完成。 ③多请示并及时汇报,遇到不明白的要虚心请教。 ④抓间隙时间,多学习,努力提高自己的政治素质和业务水平 24、除了本公司外,还应聘了哪些公司 回答提示: 很奇怪,这是相当多公司会问的问题,其用意是要概略知道应徵者的求职志向,所以这并非绝对是负面答案,就算不便说出公司名称,也应回答“销售同种产品的公司”,如果应聘的其他公司是不同业界,容易让人产生无法信任的感觉。 25、你还有什么问题要问吗? 回答提示: 企业的这个问题看上去可有可无,其实很关键,企业不喜欢说“没问题”的人,因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题,如果有人这样问:贵公司对新入公司的员工有没有什么培训项目,我可以参加吗?或者说贵公司的晋升机制是什么样的?企业将很欢迎,因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。 26、如果你被录用,何时可以到职? 回答提示: 大多数企业会关心就职时间,最好是回答“如果被录用的话,到职日可按公司规定上班”,但如果还未辞去上一个工作、上班时间又太近,似乎有些强人所难,因为交接至少要一个月的时间,应进一步说明原因,录取公司应该会通融的。","categories":[{"name":"职场","slug":"职场","permalink":"http://www.a2data.cn/categories/%E8%81%8C%E5%9C%BA/"}],"tags":[{"name":"面经","slug":"面经","permalink":"http://www.a2data.cn/tags/%E9%9D%A2%E7%BB%8F/"}]},{"title":"9.Python文件操作及应用","slug":"Python/Python速成/9、Python文件操作及应用","date":"2019-12-19T14:21:43.000Z","updated":"2020-09-11T08:14:26.854Z","comments":true,"path":"posts/8573.html","link":"","permalink":"http://www.a2data.cn/posts/8573.html","excerpt":"Python的基础语法","text":"Python的基础语法 Python文件操作、应用1、文件操作介绍 文件是什么呢？ 文件的作用呢？ 大家应该听说过一句话：“好记性不如烂笔头”。 不仅人的大脑会遗忘事情，计算机也会如此，比如一个程序在运行过程中用了九牛二虎之力终于计算出了结果，试想一下如果不把这些数据存放起来，相比重启电脑之后，“哭都没地方哭了” 相信很多做ps的朋友，深有体会 可见，在把数据存储起来有做么大的价值 使用文件的目的： 就是把一些存储存放起来，可以让程序下一次执行的时候直接使用，而不必重新制作一份，省时省力 2、文件的打开与关闭2.1、打开文件 在python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件 open(文件名，访问模式)示例如下： 1f = open(&#x27;test.txt&#x27;, &#x27;w&#x27;) 说明: 访问模式 说明 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 2.2、关闭文件 close( ) 示例如下： 12345# 新建一个文件，文件名为:test.txtf = open(&#x27;test.txt&#x27;, &#x27;w&#x27;)# 关闭这个文件f.close() 3、文件读写3.1、写文件(write) 注意： 如果文件不存在那么创建，如果存在那么就先清空，然后写入数据 3.2、读数据(read) 使用read(num)可以从文件中读取数据，num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据 3.3、读数据(readlines) 3.4、读数据(readline) 注意： 如果open是打开一个文件，那么可以不用写打开的模式，即只写 open(&#39;text.txt&#39;) 如果使用读了多次，那么后面读取的数据是从上次读完后的位置开始的 3.5、文件定位读写3.5.1、获取当前读写的位置 在读写文件的过程中，如果想知道当前的位置，可以使用tell()来获取 1234567891011121314151617# 打开一个已经存在的文件f = open(&quot;test.txt&quot;, &quot;r&quot;)str = f.read(3)print &quot;读取的数据是 : &quot;, str# 查找当前位置position = f.tell()print &quot;当前文件位置 : &quot;, positionstr = f.read(3)print &quot;读取的数据是 : &quot;, str# 查找当前位置position = f.tell()print &quot;当前文件位置 : &quot;, positionf.close() 3.5.2、定位到某个位置 如果在读写文件的过程中，需要从另外一个位置进行操作的话，可以使用seek() seek(offset, from)有2个参数 offset:偏移量 from:方向 0:表示文件开头 1:表示当前位置 2:表示文件末尾 demo:把位置设置为：从文件开头，偏移5个字节 1234567891011121314151617# 打开一个已经存在的文件f = open(&quot;test.txt&quot;, &quot;r&quot;)str = f.read(30)print &quot;读取的数据是 : &quot;, str# 查找当前位置position = f.tell()print &quot;当前文件位置 : &quot;, position# 重新设置位置f.seek(5,0)# 查找当前位置position = f.tell()print &quot;当前文件位置 : &quot;, positionf.close() demo:把位置设置为：离文件末尾，3字节处 123456789101112131415# 打开一个已经存在的文件f = open(&quot;test.txt&quot;, &quot;r&quot;)# 查找当前位置position = f.tell()print &quot;当前文件位置 : &quot;, position# 重新设置位置f.seek(-3,2)# 读取到的数据为：文件最后3个字节数据str = f.read()print &quot;读取的数据是 : &quot;, strf.close() 4、制作文件备份 输入文件的名字，然后程序自动完成对文件的备份操作 5、文件、文件夹相关操作 有些时候，需要对文件进行重命名、删除等一些操作，python的os模块中都有这么功能 5.1、文件重命名 os模块中的rename()可以完成对文件的重命名操作 rename(需要修改的文件名, 新的文件名) 12345import osos.rename(&quot;text.txt&quot;, &quot;test.txt&quot;)# 需要注意以下 5.2、删除文件 os模块中的remove()可以完成对文件的删除操作 remove(待删除的文件名) 123import osos.remove(&quot;text.txt&quot;) 5.3、创建文件夹123import osos.mkdir(&quot;小风&quot;) 5.4、获取当前目录123import osos.getcwd() 5.5、改变默认目录123import osos.chdir(&quot;../&quot;) 5.6、获取目录列表123import osos.listdir(&quot;./&quot;) 5.7、删除文件夹123import osos.rmdir(&quot;小风&quot;) 6、批量修改文件名 例如，我们有很多文件，想批量修改，该怎么办呢？ 12345678910111213141516171819202122# 批量在文件名前加前缀import osfunFlag = 1 # 1表示添加标志 2表示删除标志folderName = &#x27;./小风/&#x27;# 获取指定路径的所有文件名字dirList = os.listdir(folderName)# 遍历输出所有文件名字for name in dirList: if funFlag == 1: newName = &#x27;[A2Data出品-]&#x27; + name elif funFlag == 2: num = len(&#x27;[A2Data出品]-&#x27;) newName = name[num:] print (newName) os.rename(folderName+name,folderName+newName)","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"8.Python函数(下)","slug":"Python/Python速成/8、Python函数-下","date":"2019-12-19T00:29:40.000Z","updated":"2020-09-11T08:14:26.817Z","comments":true,"path":"posts/6275.html","link":"","permalink":"http://www.a2data.cn/posts/6275.html","excerpt":"Python函数介绍下篇","text":"Python函数介绍下篇 Python函数(下) 1、引用 在python中，值是靠引用来传递来的。 我们可以用id()来判断两个变量是否为同一个值的引用。 我们可以将id值理解为那块内存的地址标示。 123456789101112131415161718192021222324&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = a&gt;&gt;&gt; id(a) 13033816&gt;&gt;&gt; id(b) # 注意两个变量的id值相同13033816&gt;&gt;&gt; a = 2&gt;&gt;&gt; id(a) # 注意a的id值已经变了13033792&gt;&gt;&gt; id(b) # b的id值依旧13033816&gt;&gt;&gt; a = [1, 2]&gt;&gt;&gt; b = a&gt;&gt;&gt; id(a)139935018544808&gt;&gt;&gt; id(b)139935018544808&gt;&gt;&gt; a.append(3)&gt;&gt;&gt; a[1, 2, 3]&gt;&gt;&gt; id(a)139935018544808&gt;&gt;&gt; id(b) # 注意a与b始终指向同一个地址139935018544808 2、递归函数2.1、什么是递归函数 通过前面的学习知道一个函数可以调用其他函数。 如果一个函数在内部不调用其它的函数，而是自己本身的话，这个函数就是递归函数。 2.2、递归函数的作用 举个例子，我们来计算阶乘 n! = 1*2 * 3 * … * n 方案1： 阶乘的规律 1234561! = 12! = 2 × 1 = 2 × 1!3! = 3 × 2 × 1 = 3 × 2!4! = 4 × 3 × 2 × 1 = 4 × 3!...n! = n × (n-1)! 方案2： 递归原理 3、匿名函数 用lambda关键词能创建小型匿名函数。这种函数得名于省略了用def声明函数的标准步骤。 lambda函数的语法只包含一个语句，如下： 1lambda [arg1 [,arg2,.....argn]]:expression 如下实例： 12345sum = lambda arg1, arg2: arg1 + arg2#调用sum函数print &quot;Value of total : &quot;, sum( 10, 20 )print &quot;Value of total : &quot;, sum( 20, 20 ) 以上实例输出结果： 12Value of total : 30Value of total : 40 Lambda函数能接收任何数量的参数但只能返回一个表达式的值 匿名函数不能直接调用print，因为lambda需要一个表达式 应用场合 3.1函数作为参数传递 自己定义函数 123456789&gt;&gt;&gt; def fun(a, b, opt):... print &quot;a =&quot;, a... print &quot;b =&quot;, b... print &quot;result =&quot;, opt(a, b)...&gt;&gt;&gt; fun(1, 2, lambda x,y:x+y)a = 1b = 2result = 3 作为内置函数的参数 3.2想一想，下面的数据如何指定按age或name排序？123456# A2Data制作stus = [ &#123;&quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:18&#125;, &#123;&quot;name&quot;:&quot;lisi&quot;, &quot;age&quot;:19&#125;, &#123;&quot;name&quot;:&quot;wangwu&quot;, &quot;age&quot;:17&#125;] 3.3 按name排序：123&gt;&gt;&gt; stus.sort(key = lambda x:x[&#x27;name&#x27;])&gt;&gt;&gt; stus[&#123;&#x27;age&#x27;: 19, &#x27;name&#x27;: &#x27;lisi&#x27;&#125;, &#123;&#x27;age&#x27;: 17, &#x27;name&#x27;: &#x27;wangwu&#x27;&#125;, &#123;&#x27;age&#x27;: 18, &#x27;name&#x27;: &#x27;zhangsan&#x27;&#125;] 3.4按age排序：123&gt;&gt;&gt; stus.sort(key = lambda x:x[&#x27;age&#x27;])&gt;&gt;&gt; stus[&#123;&#x27;age&#x27;: 17, &#x27;name&#x27;: &#x27;wangwu&#x27;&#125;, &#123;&#x27;age&#x27;: 18, &#x27;name&#x27;: &#x27;zhangsan&#x27;&#125;, &#123;&#x27;age&#x27;: 19, &#x27;name&#x27;: &#x27;lisi&#x27;&#125;] 4、函数使用注意事项4.1、自定义函数 1、无参数、无返回值 12def 函数名(): 语句 2、无参数、有返回值 123def 函数名(): 语句 return 需要返回的数值 注意: 一个函数到底有没有返回值，就看有没有return，因为只有return才可以返回数据 在开发中往往根据需求来设计函数需不需要返回值 函数中，可以有多个return语句，但是只要执行到一个return语句，那么就意味着这个函数的调用完成 3、有参数、无返回值 12def 函数名(形参列表): 语句 注意： 在调用函数时，如果需要把一些数据一起传递过去，被调用函数就需要用参数来接收 参数列表中变量的个数根据实际传递的数据的多少来确定 4、有参数、有返回值 123def 函数名(形参列表): 语句 return 需要返回的数值 5、函数名不能重复（如下所示） 4.2、调用函数 1、调用的方式为： 1函数名([实参列表]) 2、调用时，到底写不写 实参 如果调用的函数 在定义时有形参，那么在调用的时候就应该传递参数 3、调用时，实参的个数和先后顺序应该和定义函数中要求的一致 4、如果调用的函数有返回值，那么就可以用一个变量来进行保存这个值 4.3、作用域 1、在一个函数中定义的变量，只能在本函数中用(局部变量) 2、在函数外定义的变量，可以在所有的函数中使用(全局变量)","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"7.Python函数(中)","slug":"Python/Python速成/7、Python函数(中)","date":"2019-12-18T00:15:35.000Z","updated":"2020-09-11T08:14:26.812Z","comments":true,"path":"posts/30873.html","link":"","permalink":"http://www.a2data.cn/posts/30873.html","excerpt":"Python函数介绍中篇","text":"Python函数介绍中篇 Python函数(中)1、回顾函数应用 函数的嵌套应用 程序设计的思路，复杂问题分解为简单问题 Demo 12345678910111213141516171819202122# 1.写一个函数打印一条直线# 2.打印自定义行数的横线# 打印一条def printOneLine(): print(&quot;-&quot;*30) # 打印多条def printNumLine(num): i = 0 # printOneLine 函数已经完成了打印横线的功能 # 只需要多次调用此函数即可 while i &lt; num: printOneLine() i+=1 # 调用printNumLine(3) Demo1 1.写一个函数求三个数的和 2.写一个函数求三个数的平均值 12345678910111213141516171819# 求三个数的和def sum3Number(a,b,c): return a+b+c #return的后面可以是数值，也可以是表达式# 完成三个数的平均值def average3Number(a,b,c): # 因为sum3Number函数已经完成3个数的求和 # 将接收到的3个数，当做实参传递即可 sumResult = sum3Number(a,b,c) aveResult = sumResult/3.0 return aveResult# 调用函数，完成对3个数求平均值result = average3Number(11,2,55)print(&quot;average is %d&quot;%result) 2、局部变量 归纳分析 局部变量，就是在函数内部定义的变量 不同的函数，可以定义相同的名字的局部变量，但是各用个的不会产生影响 局部变量的作用，为了临时保存数据需要在函数中定义变量来进行存储，这就是它的作用 3、全局变量3.1、全局变量是什么？ 如果一个变量，既能在一个函数中使用，也能在其他的函数中使用，这样的变量就是全局变量 Demo 12345678910111213141516# 定义全局变量a = 100def test1(): print(a)def test2(): print(a)# 调用函数test1()test2()# 结果显而易见100100 3.2、全局和局部变量名一致的情况 3.3、修改全局变量 3.4、可变类型的全局变量123456789101112131415161718192021&gt;&gt;&gt; a = 1&gt;&gt;&gt; def f():... a += 1... print a...&gt;&gt;&gt; f()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 2, in fUnboundLocalError: local variable &#x27;a&#x27; referenced before assignment&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; li = [1,]&gt;&gt;&gt; def f2():... li.append(1)... print li...&gt;&gt;&gt; f2()[1, 1]&gt;&gt;&gt; li[1, 1] 3.5、 归纳总结 在函数外边定义的变量叫做全局变量 全局变量能够在所有的函数中进行访问 如果在函数中修改全局变量，那么就需要使用global进行声明，否则出错 如果全局变量的名字和局部变量的名字相同，那么使用的是局部变量的，小技巧强龙不压地头蛇 在函数中不使用global声明全局变量时不能修改全局变量的本质是不能修改全局变量的指向，即不能将全局变量指向新的数据。 对于不可变类型的全局变量来说，因其指向的数据不能修改，所以不使用global时无法修改全局变量。 对于可变类型的全局变量来说，因其指向的数据可以修改，所以不使用global时也可修改全局变量。 4、函数返回值 在python中我们可不可以返回多个值？ 本质是利用了元组 12345678910&gt;&gt;&gt; def divid(a, b):... shang = a//b... yushu = a%b ... return shang, yushu...&gt;&gt;&gt; sh, yu = divid(5, 2)&gt;&gt;&gt; sh5&gt;&gt;&gt; yu1 5、函数参数5.1、 缺省参数 调用函数时，缺省参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入： 12345678def printinfo( name, age = 35 ): # 打印任何传入的字符串 print &quot;Name: &quot;, name print &quot;Age &quot;, age# 调用printinfo函数printinfo(name=&quot;miki&quot; )printinfo( age=9,name=&quot;miki&quot; ) 以上实例输出结果： 1234Name: mikiAge 35Name: mikiAge 9 注意：带有默认值的参数一定要位于参数列表的最后面。12345&gt;&gt;&gt; def printinfo(name, age=35, sex):... print name... File &quot;&lt;stdin&gt;&quot;, line 1SyntaxError: non-default argument follows default argument 5.2、不定长参数 有时可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，声明时不会命名。 基本语法如下： 1234def functionname([formal_args,] *args, **kwargs): &quot;函数_文档字符串&quot; function_suite return [expression] 加了星号（*）的变量args会存放所有未命名的变量参数，args为元组；而加**的变量kwargs会存放命名参数，即形如key=value的参数， kwargs为字典。 12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; def fun(a, b, *args, **kwargs):... &quot;&quot;&quot;可变参数演示示例&quot;&quot;&quot;... print &quot;a =&quot;, a... print &quot;b =&quot;, b... print &quot;args =&quot;, args... print &quot;kwargs: &quot;... for key, value in kwargs.items():... print key, &quot;=&quot;, value...&gt;&gt;&gt; fun(1, 2, 3, 4, 5, m=6, n=7, p=8) # 注意传递的参数对应a = 1b = 2args = (3, 4, 5)kwargs: p = 8m = 6n = 7&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; c = (3, 4, 5)&gt;&gt;&gt; d = &#123;&quot;m&quot;:6, &quot;n&quot;:7, &quot;p&quot;:8&#125;&gt;&gt;&gt; fun(1, 2, *c, **d) # 注意元组与字典的传参方式a = 1b = 2args = (3, 4, 5)kwargs: p = 8m = 6n = 7&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fun(1, 2, c, d) # 注意不加星号与上面的区别a = 1b = 2args = ((3, 4, 5), &#123;&#x27;p&#x27;: 8, &#x27;m&#x27;: 6, &#x27;n&#x27;: 7&#125;)kwargs:&gt;&gt;&gt;&gt;&gt;&gt; 5.3、引用传参 可变类型与不可变类型的变量分别作为函数参数时，会有什么不同吗？ Python有没有类似C语言中的指针传参呢？ 12345678910111213141516&gt;&gt;&gt; def selfAdd(a):... &quot;&quot;&quot;自增&quot;&quot;&quot;... a += a...&gt;&gt;&gt; a_int = 1&gt;&gt;&gt; a_int1&gt;&gt;&gt; selfAdd(a_int)&gt;&gt;&gt; a_int1&gt;&gt;&gt; a_list = [1, 2]&gt;&gt;&gt; a_list[1, 2]&gt;&gt;&gt; selfAdd(a_list)&gt;&gt;&gt; a_list[1, 2, 1, 2] Python中函数参数是引用传递（注意不是值传递）。对于不可变类型，因变量不能修改，所以运算不会影响到变量自身；而对于可变类型来说，函数体中的运算有可能会更改传入的参数变量。 想一想为什么12345678910111213141516&gt;&gt;&gt; def selfAdd(a):... &quot;&quot;&quot;自增&quot;&quot;&quot;... a = a + a # 我们更改了函数体的这句话...&gt;&gt;&gt; a_int = 1&gt;&gt;&gt; a_int1&gt;&gt;&gt; selfAdd(a_int)&gt;&gt;&gt; a_int1&gt;&gt;&gt; a_list = [1, 2]&gt;&gt;&gt; a_list[1, 2]&gt;&gt;&gt; selfAdd(a_list)&gt;&gt;&gt; a_list[1, 2] # 想一想为什么没有变呢？","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"6.Python函数(上)","slug":"Python/Python速成/6、Python函数(上)","date":"2019-12-14T03:40:19.000Z","updated":"2020-09-11T08:14:26.851Z","comments":true,"path":"posts/34946.html","link":"","permalink":"http://www.a2data.cn/posts/34946.html","excerpt":"Python函数介绍上篇","text":"Python函数介绍上篇 Python函数(上)1、什么是函数 如过在开发程序时，需要某块代码使用多次，但是为了提高编写的效率以及代码的复用。 将具有独立功能的代码块组织为一个小模块—-&gt;函数 2、函数的定义和调用2.1、定义函数 格式如下： 123def 函数名(): 代码 定义一个函数打印信息 1234def printinfo(): print (&#x27;-&#x27;*21) print(&#x27;--人生苦短，我用Python--&#x27;) print(&#x27;-&#x27;*21) 2.2、调用函数 定义函数之后，就相当于具备一些功能的代码块，想要这些代码执行，就需要调用函数。 （定义函数后，函数不会自动执行的）如何调用呢？ 函数名（） 2.3、动动手 定义一个函数，能够输出自己的姓名和年龄，并且调用这个函数让它执行！ 使用def 定义函数 编写函数完成之后，通过 函数名（）调用 2.4、函数的文档说明1234567&gt;&gt;&gt; def test(a,b):... &quot;用来完成对2个数求和&quot;... print(&quot;%d&quot;%(a+b))... &gt;&gt;&gt; &gt;&gt;&gt; test(11,22)33 如果执行，以下代码 1&gt;&gt;&gt; help(test) 能够看到test函数的相关说明 12345Help on function test in module __main__:test(a, b) 用来完成对2个数求和(END) 3、函数参数3.1、定义带有参数的函数123def addnum(a,b): c =a+b print (c) 3.2、调用带参函数12# 调用带有参数的函数时，需要在小括号中，传递数据addnum(12,28) 3.3、参数练习题 要求：定义一个函数，完成前2个数完成加法运算，然后对第3个数，进行减法；然后调用这个函数 使用def定义函数，要注意有3个参数 调用的时候，这个函数定义时有几个参数，那么就需要传递几个参数 3.4、调用函数时参数的顺序123456789101112&gt;&gt;&gt; def test(a,b):... print(a,b)... &gt;&gt;&gt; test(1,2)1 2&gt;&gt;&gt; test(b=1,a=2)2 1&gt;&gt;&gt; &gt;&gt;&gt; test(b=1,2) File &quot;&lt;stdin&gt;&quot;, line 1SyntaxError: positional argument follows keyword argument&gt;&gt;&gt; 3.5、总结 定义时小括号中的参数，用来接收参数用的，称为 “形参” 调用时小括号中的参数，用来传递给函数用的，称为 “实参” 4、返回值 所谓“返回值”，就是程序中函数完成一件事情后，最后给调用者的结果 4.1、返回值的函数 想要在函数中把结果返回给调用者，需要在函数中使用return 如下示例 123def add2num(a, b): c = a+b return c 或者 12def add2num(a, b): return a+b 4.2、保存函数的返回值123456789#定义函数def add2num(a, b): return a+b#调用函数，顺便保存函数的返回值result = add2num(100,98)#因为result已经保存了add2num的返回值，所以接下来就可以使用了print result 结果 1198 5、函数的类型 根据有没有参数，有没有返回值，可以互相结合，一共有4种 无参数，无返回值 无参数，有返回值 有参数，无返回值 有参数，有返回值 5.1、无参数，无返回值 此类函数，不能接收参数，也没有返回值，一般情况下，打印提示灯类似的功能，使用这类的函数 123def printMenu(): print(&#x27;-----------&#x27;) print(&quot;欢迎关注A2Data&quot;) 5.2、无参数，有返回值 此类函数，不能接收参数，但是可以返回某个数据，一般情况下，像采集数据，用此类函数 1234567891011# 获取温度def getTemperature(): #这里是获取温度的一些处理过程 #为了简单起见，先模拟返回一个数据 return 24temperature = getTemperature()print(&#x27;当前的温度为:%d&#x27;%temperature) 5.3、有参数，无返回值 此类函数，能接收参数，但不可以返回数据，一般情况下，对某些变量设置数据而不需结果时，用此类函数 5.4、有参数，又返回值 此类函数，不仅能接收参数，还可以返回某个数据，一般情况下，像数据处理并需要结果的应用，用此类函数 123456789101112# 计算1~num的累积和def calculateNum(num): result = 0 i = 1 while i&lt;=num: result = result + i i+=1 return resultresult = calculateNum(100)print(&#x27;1~100的累积和为:%d&#x27;%result) 结果 11~100的累积和为: 5050 5.5、小归纳 函数根据有没有参数，有没有返回值可以相互组合 定义函数时，是根据实际的功能需求来设计的，所以不同开发人员编写的函数类型各不相同 6、函数的嵌套调用","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"5.Python元组与字典","slug":"Python/Python速成/5、Python元组与字典","date":"2019-12-13T00:48:16.000Z","updated":"2020-09-11T08:14:26.836Z","comments":true,"path":"posts/520.html","link":"","permalink":"http://www.a2data.cn/posts/520.html","excerpt":"Python的元组与字典","text":"Python的元组与字典 元组 Python的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。 123&gt;&gt;&gt; aTuple = (&#x27;a2data&#x27;,66,99.9)&gt;&gt;&gt; aTuple(&#x27;a2data&#x27;,66,99.9) 1、访问元组 2、修改元组 说明： python中不允许修改元组的数据，包括不能删除其中的元素。 3、元组的内置函数count, index index和count与字符串和列表中的用法相同 1234567891011&gt;&gt;&gt; a = (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;)&gt;&gt;&gt; a.index(&#x27;a&#x27;, 1, 3) # 注意是左闭右开区间Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: tuple.index(x): x not in tuple&gt;&gt;&gt; a.index(&#x27;a&#x27;, 1, 4)3&gt;&gt;&gt; a.count(&#x27;b&#x27;)2&gt;&gt;&gt; a.count(&#x27;d&#x27;)0 字典 字典介绍 定义字典 获取字典数据(键、get) 想一想： 如果有列表 1nameList = [&#x27;a2data&#x27;, &#x27;a2data1&#x27;, &#x27;a2data2&#x27;]; 需要对”xiaoWang”这个名字写错了，通过代码修改： 1nameList[1] = &#x27;a2data112&#x27; 如果列表的顺序发生了变化，如下 1nameList = [&#x27;a2data&#x27;, &#x27;a2data2&#x27;, &#x27;a2data112&#x27;]; 此时就需要修改下标，才能完成名字的修改 1nameList[2] = &#x27;a2data112&#x27; 有没有方法，既能存储多个数据，还能在访问元素的很方便就能够定位到需要的那个元素呢？ 答： 字典 另一个场景： 学生信息列表，每个学生信息包括学号、姓名、年龄等，如何从中找到某个学生的信息？ 1&gt;&gt;&gt; studens = [[1001, &quot;王宝强&quot;, 24], [1002, &quot;马蓉&quot;, 23], [1005, &quot;宋喆&quot;，24], ...] 循环遍历？ No！ 0、根据键访问值1234info = &#123;&#x27;name&#x27;:&#x27;班长&#x27;, &#x27;id&#x27;:100, &#x27;sex&#x27;:&#x27;f&#x27;, &#x27;address&#x27;:&#x27;地球亚洲中国北京&#x27;&#125;print(info[&#x27;name&#x27;])print(info[&#x27;address&#x27;]) 结果: 12班长地球亚洲中国北京 若访问不存在的键，则会报错： 1234&gt;&gt;&gt; info[&#x27;age&#x27;]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: &#x27;age&#x27; 在我们不确定字典中是否存在某个键而又想获取其值时，可以使用get方法，还可以设置默认值： 1234567&gt;&gt;&gt; age = info.get(&#x27;age&#x27;)&gt;&gt;&gt; age #&#x27;age&#x27;键不存在，所以age为None&gt;&gt;&gt; type(age)&lt;type &#x27;NoneType&#x27;&gt;&gt;&gt;&gt; age = info.get(&#x27;age&#x27;, 18) # 若info中不存在&#x27;age&#x27;这个键，就返回默认值18&gt;&gt;&gt; age18 1、常见操作11.1、查看元素除了使用key查找数据，还可以使用get来获取数据 1.2、修改元素字典的每个元素中的数据是可以修改的，只要通过key找到，即可修改 1.3、添加元素访问不存在的元素 如果在使用 变量名[‘键’] = 数据 时，这个“键”在字典中，不存在，那么就会新增这个元素 添加新的元素 1.4、删除元素对字典进行删除操作，有一下几种： del clear() del 删除指定的元素 del 删除整个字典 clear 清空整个字典 1234567info = &#123;&#x27;name&#x27;:&#x27;a2data&#x27;, &#x27;sex&#x27;:&#x27;f&#x27;, &#x27;address&#x27;:&#x27;China&#x27;&#125;print(&#x27;清空前,%s&#x27;%info)info.clear()print(&#x27;清空后,%s&#x27;%info) 2、常见操作22.1、len() 测量字典中，键值对的个数 2.2、keys 返回一个包含字典所有KEY的列表 2.3、values 返回一个包含字典所有value的列表 2.4、items 返回一个包含所有（键，值）元祖的列表 2.5、has_key dict.has_key(key)如果key在字典中，返回True，否则返回False 在python3之后删除了这个方法。 contains(key) 3、字典遍历 通过for … in …:的语法结构，我们可以遍历字符串、列表、元组、字典等数据结构。 注意python语法的缩进 3.1、字符串遍历12345&gt;&gt;&gt; a_str = &quot;hello itcast&quot;&gt;&gt;&gt; for char in a_str:... print(char,end=&#x27; &#x27;)...h e l l o i t c a s t 3.2、列表遍历12345&gt;&gt;&gt; a_list = [1, 2, 3, 4, 5]&gt;&gt;&gt; for num in a_list:... print(num,end=&#x27; &#x27;)...1 2 3 4 5 3.3、元组遍历1234&gt;&gt;&gt; a_turple = (1, 2, 3, 4, 5)&gt;&gt;&gt; for num in a_turple:... print(num,end=&quot; &quot;)1 2 3 4 5 3.4字典遍历3.4.1、key（键） 3.4.2、value（值） 3.4.3、项（元素） 3.4.4、 key-value（键值对） 想一想，如何实现带下标索引的遍历 12345678910&gt;&gt;&gt; chars = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]&gt;&gt;&gt; i = 0&gt;&gt;&gt; for chr in chars:... print(&quot;%d %s&quot;%(i, chr))... i += 1...0 a1 b2 c3 d enumerate() 12345678&gt;&gt;&gt; chars = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]&gt;&gt;&gt; for i, chr in enumerate(chars):... print i, chr...0 a1 b2 c3 d 4、公共方法4.1、运算符 运算符 Python 表达式 结果 描述 支持的数据类型 + [1, 2] + [3, 4] [1, 2, 3, 4] 合并 字符串、列表、元组 * ‘Hi!’ * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 复制 字符串、列表、元组 in 3 in (1, 2, 3) True 元素是否存在 字符串、列表、元组、字典 not in 4 not in (1, 2, 3) True 元素是否不存在 字符串、列表、元组、字典 +123456&gt;&gt;&gt; &quot;hello &quot; + &quot;a2data&quot;&#x27;hello a2data&#x27;&gt;&gt;&gt; [1, 2] + [3, 4][1, 2, 3, 4]&gt;&gt;&gt; (&#x27;a&#x27;, &#x27;b&#x27;) + (&#x27;c&#x27;, &#x27;d&#x27;)(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;) *123456&gt;&gt;&gt; &#x27;ab&#x27;*4&#x27;ababab&#x27;&gt;&gt;&gt; [1, 2]*4[1, 2, 1, 2, 1, 2, 1, 2]&gt;&gt;&gt; (&#x27;a&#x27;, &#x27;b&#x27;)*4(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;b&#x27;) in12345678&gt;&gt;&gt; &#x27;a2&#x27; in &#x27;hello a2data&#x27;True&gt;&gt;&gt; 3 in [1, 2]False&gt;&gt;&gt; 4 in (1, 2, 3, 4)True&gt;&gt;&gt; &quot;name&quot; in &#123;&quot;name&quot;:&quot;小风&quot;, &quot;age&quot;:24&#125;True 注意，in在对字典操作时，判断的是字典的键 4.2、python内置函数 Python包含了以下内置函数 Python3 使用 import operator 序号 方法 描述 1 cmp(item1, item2) 比较两个值 2 len(item) 计算容器中元素个数 3 max(item) 返回容器中元素最大值 4 min(item) 返回容器中元素最小值 5 del(item) 删除变量 cmp123456789101112131415161718&gt;&gt;&gt; cmp(&quot;hello&quot;, &quot;a2data&quot;)-1&gt;&gt;&gt; cmp(&quot;a2data&quot;, &quot;hello&quot;)1&gt;&gt;&gt; cmp(&quot;a2data&quot;, &quot;a2data&quot;)0&gt;&gt;&gt; cmp([1, 2], [3, 4])-1&gt;&gt;&gt; cmp([1, 2], [1, 1])1&gt;&gt;&gt; cmp([1, 2], [1, 2, 3])-1&gt;&gt;&gt; cmp(&#123;&quot;a&quot;:1&#125;, &#123;&quot;b&quot;:1&#125;)-1&gt;&gt;&gt; cmp(&#123;&quot;a&quot;:2&#125;, &#123;&quot;a&quot;:1&#125;)1&gt;&gt;&gt; cmp(&#123;&quot;a&quot;:2&#125;, &#123;&quot;a&quot;:2, &quot;b&quot;:1&#125;)-1 注意：cmp在比较字典数据时，先比较键，再比较值。 len12345678&gt;&gt;&gt; len(&quot;hello a2data&quot;)12&gt;&gt;&gt; len([1, 2, 3, 4])4&gt;&gt;&gt; len((3,4))2&gt;&gt;&gt; len(&#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;)2 注意：len在操作字典数据时，返回的是键值对个数。 max12345678910&gt;&gt;&gt; max(&quot;hello a2data&quot;)&#x27;t&#x27;&gt;&gt;&gt; max([1,4,522,3,4])522&gt;&gt;&gt; max(&#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;)&#x27;b&#x27;&gt;&gt;&gt; max(&#123;&quot;a&quot;:10, &quot;b&quot;:2&#125;)&#x27;b&#x27;&gt;&gt;&gt; max(&#123;&quot;c&quot;:10, &quot;b&quot;:2&#125;)&#x27;c&#x27; del del有两种用法，一种是del加空格，另一种是del() 1234567891011121314151617&gt;&gt;&gt; a = 1&gt;&gt;&gt; a1&gt;&gt;&gt; del a&gt;&gt;&gt; aTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#x27;a&#x27; is not defined&gt;&gt;&gt; a = [&#x27;a&#x27;, &#x27;b&#x27;]&gt;&gt;&gt; del a[0]&gt;&gt;&gt; a[&#x27;b&#x27;]&gt;&gt;&gt; del(a)&gt;&gt;&gt; aTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#x27;a&#x27; is not defined 4.3、多维列表/元祖访问的示例123456789101112131415161718192021222324&gt;&gt;&gt; tuple1 = [(2,3),(4,5)]&gt;&gt;&gt; tuple1[0](2, 3)&gt;&gt;&gt; tuple1[0][0]2&gt;&gt;&gt; tuple1[0][2]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: tuple index out of range&gt;&gt;&gt; tuple1[0][1]3&gt;&gt;&gt; tuple1[2][2]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range&gt;&gt;&gt; tuple2 = tuple1+[(3)]&gt;&gt;&gt; tuple2[(2, 3), (4, 5), 3]&gt;&gt;&gt; tuple2[2]3&gt;&gt;&gt; tuple2[2][0]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#x27;int&#x27; object is not subscriptable","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"4.Python列表介绍","slug":"Python/Python速成/4、Python列表介绍","date":"2019-12-12T00:35:16.000Z","updated":"2020-09-11T08:14:26.840Z","comments":true,"path":"posts/58489.html","link":"","permalink":"http://www.a2data.cn/posts/58489.html","excerpt":"Python列表介绍","text":"Python列表介绍 Python列表解析章节1、列表介绍想一想： 前面学习的字符串可以用来存储一串信息，那么想一想，怎样存储公号所有粉丝的名字呢？ 定义100个变量，每个变量存放一个粉丝的姓名可行吗？有更好的办法吗？ 答： 列表 1.1、列表的格式变量A的类型为列表 1namesList = [&#x27;a2data&#x27;,&#x27;a2data1&#x27;,&#x27;a2data2&#x27;] 比C语言的数组强大的地方在于列表中的元素可以是不同类型的 1testList = [1, &#x27;a&#x27;] 1.2、打印列表demo: 1234namesList = [&#x27;a2data&#x27;,&#x27;a2data1&#x27;,&#x27;a2data2&#x27;]print(namesList[0])print(namesList[1])print(namesList[2]) 结果： 123a2dataa2data1a2data2 2、列表的循环2.1、 使用for循环 为了更有效率的输出列表的每个数据，可以使用循环来完成 demo: 123namesList = [&#x27;a2data&#x27;,&#x27;a2data1&#x27;,&#x27;a2data2&#x27;]for name in namesList: print(name) 结果: 123a2dataa2data1a2data 2.2、 使用while循环为了更有效率的输出列表的每个数据，可以使用循环来完成 demo: 123456789namesList = [&#x27;a2data&#x27;,&#x27;a2data1&#x27;,&#x27;a2data2&#x27;]length = len(namesList)i = 0while i&lt;length: print(namesList[i]) i+=1 结果: 123a2dataa2data1a2data2 3、列表的常见操作 列表中存放的数据是可以进行修改的，比如”增”、”删”、”改”、”查” 3.1、添加元素 (“增”append, extend, insert) append通过append可以向列表添加元素 demo: 1234567891011121314#定义变量A，默认有3个元素A = [&#x27;a2data&#x27;,&#x27;a2data1&#x27;,&#x27;a2data2&#x27;]print(&quot;-----添加之前，列表A的数据-----&quot;)for tempName in A: print(tempName)#提示、并添加元素temp = input(&#x27;请输入要添加的学生姓名:&#x27;)A.append(temp)print(&quot;-----添加之后，列表A的数据-----&quot;)for tempName in A: print(tempName) extend通过extend可以将另一个集合中的元素逐一添加到列表中 12345678&gt;&gt;&gt; a = [1, 2]&gt;&gt;&gt; b = [3, 4]&gt;&gt;&gt; a.append(b)&gt;&gt;&gt; a[1, 2, [3, 4]]&gt;&gt;&gt; a.extend(b)&gt;&gt;&gt; a[1, 2, [3, 4], 3, 4] insertinsert(index, object) 在指定位置index前插入元素object 1234&gt;&gt;&gt; a = [0, 1, 2]&gt;&gt;&gt; a.insert(1, 3)&gt;&gt;&gt; a[0, 3, 1, 2] 3.2、修改元素(“改”)：修改元素的时候，要通过下标来确定要修改的是哪个元素，然后才能进行修改 demo: 12345678910111213#定义变量A，默认有3个元素A = [&#x27;a2data&#x27;,&#x27;a2data1&#x27;,&#x27;a2data2&#x27;]print(&quot;-----修改之前，列表A的数据-----&quot;)for tempName in A: print(tempName)#修改元素A[1] = &#x27;a2data666&#x27;print(&quot;-----修改之后，列表A的数据-----&quot;)for tempName in A: print(tempName) 结果: 12345678-----修改之前，列表A的数据-----a2dataa2data1a2data2-----修改之后，列表A的数据-----a2dataa2data666a2data2 3.3、查找元素 (“查”in, not in, index, count) 所谓的查找，就是看看指定的元素是否存在 in, not in python中查找的常用方法为： in（存在）,如果存在那么结果为true，否则为false not in（不存在），如果不存在那么结果为true，否则false demo 1234567891011#待查找的列表nameList = [&#x27;a2data&#x27;,&#x27;a2data1&#x27;,&#x27;a2data2&#x27;]#获取用户要查找的名字findName = input(&#x27;请输入要查找的姓名:&#x27;)#查找是否存在if findName in nameList: print(&#x27;在字典中找到了相同的名字&#x27;)else: print(&#x27;没有找到&#x27;) 说明： in的方法只要会用了，那么not in也是同样的用法，只不过not in判断的是不存在 index, countindex和count与字符串中的用法相同 1234567891011&gt;&gt;&gt; a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;]&gt;&gt;&gt; a.index(&#x27;a&#x27;, 1, 3) # 注意是左闭右开区间Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: &#x27;a&#x27; is not in list&gt;&gt;&gt; a.index(&#x27;a&#x27;, 1, 4)3&gt;&gt;&gt; a.count(&#x27;b&#x27;)2&gt;&gt;&gt; a.count(&#x27;d&#x27;)0 3.4、删除元素 (“删”del, pop, remove) 类比公号中，如果掉粉了，那么就应该把这个取关粉丝的姓名删除掉；在开发中经常会用到删除这种功能。 列表元素的常用删除方法有： del：根据下标进行删除 pop：删除最后一个元素 remove：根据元素的值进行删除 demo:(del) 1234567891011movieName = [&#x27;a2data&#x27;,&#x27;a2data1&#x27;,&#x27;a2data2&#x27;,&#x27;a2data3&#x27;,&#x27;a2data4&#x27;,&#x27;a2data5&#x27;]print(&#x27;------删除之前------&#x27;)for tempName in movieName: print(tempName)del movieName[2]print(&#x27;------删除之后------&#x27;)for tempName in movieName: print(tempName) 结果: 12345678910111213------删除之前------a2dataa2data1a2data2a2data3a2data4a2data5------删除之后------a2dataa2data1a2data3a2data4a2data5 demo:(pop) 1234567891011movieName = [&#x27;a2data&#x27;,&#x27;a2data1&#x27;,&#x27;a2data2&#x27;,&#x27;a2data3&#x27;,&#x27;a2data4&#x27;,&#x27;a2data5&#x27;]print(&#x27;------删除之前------&#x27;)for tempName in movieName: print(tempName)movieName.pop()print(&#x27;------删除之后------&#x27;)for tempName in movieName: print(tempName) 结果: 12345678910111213------删除之前------a2dataa2data1a2data2a2data3a2data4a2data5------删除之后------a2dataa2data1a2data2a2data3a2data4 demo:(remove) 1234567891011movieName = [&#x27;a2data&#x27;,&#x27;a2data1&#x27;,&#x27;a2data2&#x27;,&#x27;a2data3&#x27;,&#x27;a2data4&#x27;,&#x27;a2data5&#x27;]print(&#x27;------删除之前------&#x27;)for tempName in movieName: print(tempName)movieName.remove(&#x27;a2data3&#x27;)print(&#x27;------删除之后------&#x27;)for tempName in movieName: print(tempName) 结果: 12345678910111213------删除之前------a2dataa2data1a2data2a2data3a2data4a2data5------删除之后------a2dataa2data1a2data2a2data4a2data5 3.5、排序(sort, reverse) sort方法是将list按特定顺序重新排列，默认为由小到大，参数reverse=True可改为倒序，由大到小。 reverse方法是将list逆置。 123456789101112&gt;&gt;&gt; a = [1, 4, 2, 3]&gt;&gt;&gt; a[1, 4, 2, 3]&gt;&gt;&gt; a.reverse()&gt;&gt;&gt; a[3, 2, 4, 1]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[1, 2, 3, 4]&gt;&gt;&gt; a.sort(reverse=True)&gt;&gt;&gt; a[4, 3, 2, 1] 4、列表的嵌套4.1 列表嵌套 类似while循环的嵌套，列表也是支持嵌套的 一个列表中的元素又是一个列表，那么这就是列表的嵌套 123schoolNames = [[&#x27;北京&#x27;,&#x27;山西&#x27;], [&#x27;湖南&#x27;,&#x27;天津&#x27;,&#x27;深圳&#x27;], [&#x27;长沙&#x27;,&#x27;上海&#x27;]] 4.2、 应用 一个公号，有5个长期运营，现在要分配其中3个位置，但是有8位运营者等待分配，请编写程序，完成随机的分配 1234567891011121314151617181920212223#encoding=utf-8import random# 定义 一个运营管理者的列表offices = [[],[],[]]# 定义一个列表用来存储8位运营者的名字names = [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;,&#x27;G&#x27;,&#x27;H&#x27;]i = 0for name in names: index = random.randint(0,2) offices[index].append(name)i = 1for tempNames in offices: print(&#x27;运营%d的人数为:%d&#x27;%(i,len(tempNames))) i+=1 for name in tempNames: print(&quot;%s&quot;%name,end=&#x27;&#x27;) print(&quot;\\n&quot;) print(&quot;-&quot;*20)","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"3.Python的字符串","slug":"Python/Python速成/3、Python的字符串","date":"2019-12-10T23:30:21.000Z","updated":"2020-09-11T08:14:26.834Z","comments":true,"path":"posts/29055.html","link":"","permalink":"http://www.a2data.cn/posts/29055.html","excerpt":"Python的字符串","text":"Python的字符串 Python的字符串1、字符串介绍 想一想： 当打来浏览器登录某些网站的时候，需要输入密码，浏览器把密码传送到服务器后，服务器会对密码进行验证，其验证过程是把之前保存的密码与本次传递过去的密码进行对比，如果相等，那么就认为密码正确，否则就认为不对；服务器既然想要存储这些密码可以用数据库（比如MySQL），当然为了简单起见，咱们可以先找个变量把密码存储起来即可；那么怎样存储带有字母的密码呢？ 答： 字符串 python中字符串的格式 如下定义的变量a，存储的是数字类型的值 1a = 100 如下定义的变量b，存储的是字符串类型的值 123b = &quot;hello a2data.cn&quot;或者b = &#x27;hello www.a2data.cn&#x27; 小总结： 双引号或者单引号中的数据，就是字符串 2、字符串输出demo 123456789name = &#x27;小风&#x27;position = &#x27;大数据分析狮&#x27;address = &#x27;北京市朝阳区xxxx&#x27;print(&#x27;--------------------------------------------------&#x27;) print(&quot;姓名：%s&quot;%name) print(&quot;职位：%s&quot;%position) print(&quot;公司地址：%s&quot;%address)print(&#x27;--------------------------------------------------&#x27;) 结果 12345-------------------------------------------------- 姓名： 小风 职位： 大数据分析狮 公司地址： 北京市朝阳区xxxx-------------------------------------------------- 3、字符串输入 在input的时候，通过它能够完成从键盘获取数据，然后保存到指定的变量中； 注意：input获取的数据，都以字符串的方式进行保存，即使输入的是数字，那么也是以字符串方式保存 demo 12345userName = input(&#x27;请输入用户名:&#x27;)print(&quot;用户名为：%s&quot;%userName)password = input(&#x27;请输入密码:&#x27;)print(&quot;密码为：%s&quot;%password) 4、下标和切片4.1、下标索引 字符串中”下标”的使用 列表与元组支持下标索引好理解，字符串实际上就是字符的数组， 所以也支持下标索引。 如果有字符串:name = &#39;abcdef&#39;，在内存中的实际存储如下: 如果想取出部分字符，那么可以通过下标的方法，（注意python中下标从 0 开始） 12345name = &#x27;abcdef&#x27;print(name[0])print(name[1])print(name[2]) 运行结果 4.2、切片 切片是指对操作的对象截取其中一部分的操作。字符串、列表、元组都支持切片操作。 切片的语法：[起始:结束:步长]注意：选取的区间属于左闭右开型，即从”起始”位开始，到”结束”位的前一位结束（不包含结束位本身)。 我们以字符串为例讲解。 如果取出一部分，则可以在中括号[]中使用 : 123456name = &#x27;abcdef&#x27;print(name[0:3]) # 取 下标0~2 的字符print(name[0:5]) # 取 下标为0~4 的字符print(name[3:5]) # 取 下标为3、4 的字符print(name[2:]) # 取 下标为2开始到最后的字符print(name[1:-1]) # 取 下标为1开始 到 最后第2个 之间的字符 12345678910111213a = &quot;abcdef&quot;a[:3] &#x27;abc&#x27;a[::2] &#x27;ace&#x27;a[5:1:2] &#x27;&#x27;a[1:5:2] &#x27;bd&#x27;a[::-2] &#x27;fdb&#x27; a[5:1:-2] &#x27;fd&#x27; 想一想 （面试题）给定一个字符串aStr, 请反转字符串 例如： ‘www.a2data.cn&#39; 5、字符串常见操作 如有字符串mystr = &#39;hello world a2data and jackfeng&#39;，以下是常见的操作 5.1、find 检测 str 是否包含在 mystr中，如果是返回开始的索引值，否则返回-1 12mystr.find(str,start=0, end=len(mystr))mystr = &#x27;hello world a2data and jackfeng&#x27; 5.2、index 跟find()方法一样，只不过如果str不在 mystr中会报一个异常. 12mystr.index(str, start=0, end=len(mystr)) mystr = &#x27;hello world a2data and jackfeng&#x27; 5.3、count 返回 str在start和end之间 在 mystr里面出现的次数 12mystr.count(str, start=0, end=len(mystr))mystr = &#x27;hello world a2data and jackfeng&#x27; 5.4、replace 把 mystr 中的 str1 替换成 str2,如果 count 指定，则替换不超过 count 次. 12mystr.replace(str1, str2, mystr.count(str1))name =&quot;hello world ha ha&quot; 5.5、split 以 str 为分隔符切片 mystr，如果 maxsplit有指定值，则仅分隔 maxsplit 个子字符串 12mystr.split(str=&quot; &quot;, 2) name =&quot;hello world ha ha&quot; 5.6、capitalize 把字符串的第一个字符大写 1mystr.capitalize() 5.7、title 把字符串的每个单词首字母大写 5.8、startswith 检查字符串是否是以 obj 开头, 是则返回 True，否则返回 False 1mystr.startswith(obj) 5.9、endswith 检查字符串是否以obj结束，如果是返回True,否则返回 False. 1mystr.endswith(obj) 5.10、lower 转换 mystr 中所有大写字符为小写 1mystr.lower() 5.11、upper 转换 mystr 中的小写字母为大写 1mystr.upper() 5.12、ljust 返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串 1mystr.ljust(width) 5.13、rjust 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串 1mystr.rjust(width) 5.14、center 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串 1mystr.center(width) 5.15、lstrip 删除 mystr 左边的空白字符 1mystr.lstrip() 5.16、rstrip 删除 mystr 字符串末尾的空白字符 1mystr.rstrip() 5.17、strip 删除mystr字符串两端的空白字符 5.18、rfind 类似于 find()函数，不过是从右边开始查找. 1mystr.rfind(str, start=0,end=len(mystr) ) 5.19、rindex 类似于 index()，不过是从右边开始. 1mystr.rindex( str, start=0,end=len(mystr)) 5.20、partition 把mystr以str分割成三部分,str前，str和str后 1mystr.partition(str) 5.21、rpartition 类似于 partition()函数,不过是从右边开始. 1mystr.rpartition(str) 5.22、splitlines 按照行分隔，返回一个包含各行作为元素的列表 1mystr.splitlines() 5.23、isalpha 如果 mystr 所有字符都是字母 则返回 True,否则返回 False 1mystr.isalpha() 5.24、isdigit 如果 mystr 只包含数字则返回 True 否则返回 False. 1mystr.isdigit() 5.25、isalnum 如果 mystr 所有字符都是字母或数字则返回 True,否则返回 False 1mystr.isalnum() 5.26、isspace 如果 mystr 中只包含空格，则返回 True，否则返回 False. 1mystr.isspace() 5.27、join mystr 中每个字符后面插入str,构造出一个新的字符串 1mystr.join(str) 想一想 （面试题）给定一个字符串aStr，返回使用空格或者’\\t’分割后的倒数第二个子串","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"python第二天作业答案","slug":"Python/Python速成/python第二天作业答案","date":"2019-12-10T23:20:20.000Z","updated":"2020-09-11T08:01:01.043Z","comments":true,"path":"posts/27081.html","link":"","permalink":"http://www.a2data.cn/posts/27081.html","excerpt":"有东西被加密了, 请输入密码查看.","text":"您好, 这里需要密码.如若不知,请联系小编。163d7990d844d85d4b343793961f88f6691b2ac9101dd433f612620dfb90183d31e09db63073007a33e2b728c9a812009dd567a3a438edff90b577fc447c8740b188e61ce4f73c1d8513edab492988ad22a26d9e1f46e1144816a2c963d0f156b6fafb9bc916774c22578761919c6219cd1f211c263dc850ed564f1feb2857b5df1b237bf8435eace63a1e1302f1e0e204da10bdd477c53fa7b7a6dfa042301e50847a85fd3e4e28da320c92e46782c60afbcfce17c56e1ab4e9a12998bab7600548465b9601e8dce4a5a9aaf48820c195b7da5c85823c632200dc59188d6aac1c0701ab1cfc487004e3b9a0aca8d60b9d1a5ae1b0a78336a4d66eef8789efa0022700f3fec319f5925f6e217ca55c03d311f644da8f9dcf6cccbaa60410486930a90e6223749486d3c89cc5fd00f9a67276e04415358db052877bb86c4e25a1f0de8ced4e1f86e307ac22fa8db40fc9871857e0525c41be2eb62334f2929200fec9287930de17e2463a774a2bee815b5ab51bde0f6f97a9bd596183ed83764d65cd2df4aca4165fe675f0ddef88531306d16be9ec65d8a3211787a8fa1ba9e223e2983077788aabd7ffb5560fd3713d487d6e3c33353bd739710160549ec08ed46da901c2cc1d40b2c35cf9fc76d0301dcfcd17bf7a104de65ea614e68fd2faad69aec47442a28419dbffb730cb50c29c6630e4d7c73d09cdbe5dd8378d149523e6a945265a20a83cc86564761fce36f366504d3e92a8e0f6adb7b9c6c77b7402c51e74a58f2713c659c66759f40c662bd9cb3e7a37fe4e97e4a2a45a300af248349708f9062f88242037257c7a8d5c318f3108cdc90dbfea155a5daf4c0fb60490f3640c1639a0a44828e8f31b7eee198531a95ece7ac9cb65e776d5752ea81309df55c9255769c202f47d8518d2b26b300cfb6326ecabce95ace4c3d6fd4e43fe754007c8db501eb8a35351b7e8fe0ff9daa193355d59c98a934ebd495d490758a410829a1e4c2934fe333fda185a414c6882a99e9e2d76cf4449b98b3be3c3cef0ddc654e36940d24a56fe70b683ba385d0c8e6963ab4e6f3dc6e730bcd4543f03ee3944c7a0b2ce6a8ef5b041ebc2a6a09439be2152336ab392fc17260eca4189c5488d06c3a7b34222ea54fdf34d6cc821231043ca9936115361c64df622a404ab4c1e16251f04c78c49a4010bc9cbb301c286af2a116ec200fd58613a5c9c291a9c152865e63fab9a2976499d01201e00cdc5e274292598ac6725ad7f743320e9ec9d000a2b2146a69ff5f96c351a14e22b359d589af94726acfe7539900481a86531cb12566f78d3a4288baadb06f4b54dd29a8c72a218eb03e208367592efa859b77fd7ff73a608098dba1255a0e9878781601338ff1df270ad70cc2588005471e4900e5126bc5f7a6631b6bfbcb8bcadb1d73ac57afbd08ec0fc471c56b91f08068f333c19daaa95ffa028375376dd30d890ce5cb262e7037f8bcf391eb7d99c6405e62a7ca0f2d355f0eedd73d72f1673fc9f2f99ac2ea18fdd5ebe57e66ec7c01cdb2551d1f5830e7054883c8754cfa8db9b58c2d22a3e9a183e127b2e41ce90c4bb5a029123e403edbed43cbd4b202ee5fbb4703f934b14391d4aba437948d89f4768f884230af28522c77e96ffa3f1281c2fc5b9e4a63b7cabea19df81bdd06a129b96f3939e45d342973e530360c92fdbb43d4369526f11dff26d770ca260da92f52c82a1e9dff0d0ca36a42878ff9e1ff1307858a34761aa146cb1086874c2561805c181a78d2a62fc5c110eb61e74ed4ad95b91520ec8192d5e966140e53075ec4d6ae1e466a0fe07395fe94dc58c3ab384e45dafc70d05caa8c1e4eb715907bca26c9bf223717a830879e67c3ae65df44d5548e8882cbb0765589d11b8d69fc13a2da1036c59636433be71f671388c01fea684ba3d2224b7936badd424fa9e5eddaf594db276e1e5fb34f728e13cc72139ae089c8e03736af65c4730ce24715995333df9de3fb59f46dba341d349dc9f63e1fb5535274d038aac0e24766ee95c074fa52881808bb3bdbaeb0c692246844e51c05877c81380a6339bb942dfb79919c1f734de15b8bd8251fb5184ef482391720937360384926fecfc33936c42e647f4454a447f22fa5f8d568c95d8f63f1623a5979823b38b5aafad807f2641ed859d791ae37fce2b85f046962e0a8d51145b9004716b46c2ee6eac3fbfa02896f2617addbb563924d1ecacc235623df89d104fe73e596b887d8a79498af6c86ad874dc73bdb3a2922f89a9833e0d4996d1fc255a6011a06d25563cb8c4da0dda80cddd4e9badc5a87f7d6e4be9557b886ae88a15f501703088bf1ab25039b878632fe02bcefc8655ea3a8c70a4fd9aa3489944a105cb11aef253dfc4f664fe85a542c6ccdf002b82ae915b6b32aa6fb63cd8a36f10a3baff1ff967c102abd9244369b74903a969810d82ab77b38a3c66294b512c0943f5e6ef379985b25abe6e808c3a58994140210587a9bca6821334b8aff4057b22318f48bd1e6c5b026d0ca89d67c8dfb1b611d0e998fc4f499313f1eb861a581d416669e38f7dd77369ca31ad298127e59fb8ed7065bee9e475b56836d712a4bed9ca3806414ea3d00626d00c27e938d1e3f623a1923737875d132b5c102074789538ab5507917fbeaa2af5afbc6ded1b983844f4eec9934a24d816961f950ff654082a56a224b758b932e4966f10925c7ecfcb8d620d9bbe578d5f460184656096da33812cd8d809ae9163fa15137731c3b5d1a60fb6ed0710d7312b296d9a2c4009483bdbd2e08f612a1eccbbf8e8accc0f32ff905b96f8649fbfd42494936f520fa37051c7caac26e3b248d0dc67a53d50e28592b7d30c219a67c018d10a24b36e0a71f576367aed10092f4ea48ef2419f20a21890ad10c7e2d3c26b80f33eeb4c01b56d25aca04252839b79c054776989e5153fabfdc512350b25104451520e8053ba70a868c66f16dac50abc52478c743441bde4cc4913aaafd6c4c2d412a24b4aeced1466ad01fccf2ba6dd95444dd56faeb20ced690976448681516fd256a1441d15e4e99cf8674506f74c127e0f0058f4d98768da3aabe377fcc28f82f76da8156106d9d060c5896ae2982ca58b79959302eb5cdfb5ead645cf9edee5b3e84912fbac3a9457815d82ce39b4fbeea1ad4f2a41ef88466a956dde69979a44a2c06e30a19bcd53b9eec30709f8ff25bc6190cf84558d770783c9ae32bd75ef4d9336b58eddcf31dc79d7f2b6bddd31009fb7449ffb3b0db0f876161824ada82910204cb3f6073538b1a36fa0425fdeebb40521b834d42fbcb0f787687f3df8b55eafa7dfbf08e26503e67824eae586e0e28d4cc9b2aabfc151d3f103dcf45665da6227ca6e50bdd9e2b1d10aaacb38351da4ccd7867418e7fdb1f055059df19d8c97bccf51a70eb63b32064e466ba748540b23562e8e0dc833bef45057ecc64c1fd00dd5d8f0c6da3b3267bcd3ee895d1e73f5a70965db6f0217997db2023869855fd0c904b5f7054c88ada19961a692c6e5a420bf2c067a8654209ed1db7493dc45fdff2bc2a04360cf81cb4bdd57de3e1053b8c41bd0d01ec1fdab43ebcc0e846689ab118a48d5df50d9e12f1e80b74264d4c83c34db5f87acd70758958d35f1c0f3ed74a1d568fc42ec43d9137ecdf2b37e1c92ee05a302c266a67c59f28dddd6d6b5ed3056a89fde85cdef97212087a7e738f223380c637d8cf21daea06ebdb01ac3bf3f55c981980a1b322007d44cb361af0f3a8f5d69f35687b318885ffb4a3ddbdc84f143ae7598f787b77e8c5469d28ddc5cf251e139d4859f4c8ca4399f241bc7848b06c6ec4831c8f938cfda71a3e846a5ea18266248f01e371c543f010346ac695f7cc1d4b6aa8764475249d7bfe695815ea4a0a640aae159c9abbceaa805f023b4cc1f3225b2343fc5b1727f3506dfc7336ad37be0004443d95fbf34ad3ecf06e7aec4282f82b954c263dede0184d9cdfad5c0b9c686e2be4e744fbf85e922ca53489301b2bcd50a78fbe6ce252a31b92e9d6b3f9fc029311d40b5c5252a31de46f64134dbe373bd9c9acf230fea5031261e24485b707e78bda73b083fe96645ec1f59a8836b6ee93ee80f84021a16feb4a4ae8d0da1647f7feb3774b4c4cfc203ede3727a20dc50df50137bbd3b6537ef3be5ce931cc2ecf93d7673b5c92e21449d220b5d3f9b03ae0864d8df9b04624776f1e6d5a67a1bfda112024c13bb61753738f037d9efcd51914cfd4afa5dca6e1e2d6a2a1db9a20c35fbf72febd1fea59c1ef1180193970c06db5030b46d672a513b936e4734cebf382c0b1e004a9f6f92f0d6f370f17dc4d6d43d8cb3df2344b2a46f9977dc6a43a5ec9a12d208628daf5086644718e4f0ab7dfc884dca64362870765597575fba17b835a3445938097f76335244ad7e53b8f196fc415203cf059c6a6d8630b92e2aca183e6012bb414a639a58103362695a077dd3784ce84499131ae60cd9db01f5bc33c43282ccc51a0dae332331b9a8b87550c9675334a9a44cbf316ce1f808fc154daa1263f37c9c04a52fb5ea0f832ac7f278bfce8907924d5c3b8f4df10068f65975b26e60be6915b9fe953ef504dbb00e1acbee17eae9bfc3c2358d00e32fbbceb210cb440c546d222cdf94ac132d03608afe9e1428fa15c0db36d3e562f2a4a5593817c0c284edd53d8f2f2b4e11dc945ed6bf2991619b823a7c83e956de774e98fcb312c2bc6ccda291772404a6af58ac2237d1e4f0cd8b1f174598012179492085f0f8fa23c27f58289013a253a6094fe6b74bc22f21cdb0ab7165b513278f1a2cb27c08bb9b2729f521667413e70da2e7db7a9872a7c78c993e42664ba0e7793bad14713447f657f734867606bea9c1f86271608d76ac4bc8af9192689dd8c597497e14683f12bf0836a3343873385c711cfd417f44b2aa6f9e97863ff97f176f420d33df921efb67318db807b615fc306ec6b0e7f81b89e9552bd6e56351b133c32642d836a361036a813fe68a8e7ad7bf1576f205e16c34bd3e8a97966295f14344276c5f536d3e567c53b9725f3e1c4d32945bfba18f6a04be15bc769990afd1b336a1659f76808e6ce685e7beced15da218dafacc47c1db1e8289d669eeb29969e94cce77a5e490b3478bb233237bc8ae613ed480a7e21c3ac2af5edcda8e966aff5069e3e60f4e96b05c597efc46329a47cb45d316979dc791d63234cca9d8fdb65526429f4b9616042767f612d8f2caa117418c14562190f1880535317804f28c9e70382f9b46c967c7ff0c6d42455e923c2039eaa20e388fa1fad53a4f32b24c89d28b750310bd5e48c64382497d7e198e1ca6026104c7d043070b5f99a38138e46b4ab769ccafaf6f41e051decb3721e3931b450f4f4651e4ba597e5890a5921ce393c2dd16e403b1a1e756ae480cfdb26cf3417d4b38c7fc2dbee0dcab9b12937543d9f5d990150b50cf2442d0a3092108b149649938ea901c866919793982a074129acde26c966c227a65156c8e493d7a7c5b6e9f832a9ba0b94b6528141d333988b01a874b51771f658c23235db89f5d76f2af36983c89fb2766963d807bb8521dae884d51c6b0d2d98047b70f0d50115cc8e8f5cab1e9ce95a04668b19eef3bb38b596ea3d1b5f6c8312309ec36540bb9e2d958521418a970b09cedff300089d07aef95141f541b30d040948d0387ffb681be461c79b9b9866e7105c565d1b85f17de89c98ed91c410c2fa5af80f5c1c33232afc9ff6216610baa68adaab8f6d2d1d3e632fba0bf6cce743b12ce86c5c3aa73a4629bfc7278b4fc4a32c6d90e8365d617245aa3cb5ad04b05f0cffd14d4bb8c9bda600b490af8a020a7dffb235a9cd5a132ed8878c36e914c5b5077d4e952eccd77e4bd901558c8550da965b2be35adb1942a103a659afd10a79d4f7f66ecc1fe52b75cb85bc5751be2081e72fe5a042876da9984cc5f9ec049379f4c992ad12f70624f96896ea6d5bb747d1eac05a450c9ae83d651e6aeadfc1f3dd0bba10d749151c63cc8bb65e39cd917beca992fb2d38bca9772d15432e1a5b18405566663d0b136acdef6a42c16a8766876464f255460e33c2ab0386b7c9e4327e073ad807ed59c17c59ee1f7e959c2f7564b5801dffc9e8f194c9ef594099754a8fa8701500ea3406fdefe41e6f5419db48d9683a44b726a029827b28e28644853a0920c7baacc4e77e5d83a3b26b08ff102512f009d4e74b248802a63b4fe317cc9f27e9f5eace2bf21b8037db862e6e5689fa0eaf0a93e4dc998f633d9af998a0508e5b90f787628e9782e3a138818020232dc86dfd6386af3dc53cecffc0b78a244b4eaff15ac9b4bdf763566a356b2b477bcf8bd4b7dc183603e86b26bf5f778895f98b474e43fa9106a1ec5c16e13963e356aabfaf3af1d0899f9148449e92993d88db48dc1d342d1f1bd36f42e966b7b16b8fdcad2173e5f693d87836398b6f374fc41faad587a492b1261d31124ed6d14f47ca890defabd3b74c2aa7fd43810f6a93bb8a74bcb7f78c97b0059a21315d8e3fa7023f69352426a61e46aa626dd6ad987d2be4cc16483f8751895e1b4ccf0371fb4fd14b4b518b3373622918804ff240e975663391861ca6b624fa7b9f1c24311b3808bc389252381f8ba1c33777f009e41ce5f42cc037b5934425d661a7d6ded4b7dc12e9f370a8dad82fe40e50e3e9b9cc8e2555b1f26bc29753f1a50ee642a407cdc54fe32f3284479008cfdd182ac15f1fbaf0e66f4070c053f9c28ba4b19dd8949592830f11ae27024419f3211c35f023a210cc0b3f4e107781f76e9164038260e8584cbd324c1ba92ed2850258d2ec6b5e67bed666f38ac98eb48850476d754751fc43b54190b940a91632ed00ee868ee5c80176c8b12a1e76aca69d73f1772795ada12ea4f01f2316464c356d37e7259f6a9cce1dc937063bff8c18efaa0e4b9197aea2effe49736d6afe64ed2245c3e1660a2c5e20aefcde4c2b4b4c435f5667e44d6a4c7d2476c3527e0e68a6c43751d7e44b5f8f72e545b0b5a8da90da435773174db2186aa202f5e6756b761063808528c9b6b569454ae0fa43cadb972dba40b35069f4090f5ad75ce8802b4390043797b6ec9b2f2ac33ebda645875fac26414b4e7360032b6cddf6b1b51b009c264372c392c0d46c96308f74803a162e5bdf04cc14da8d26125e43082073a1ac06ab2348d0b80fcc2e6fe0643806abe99a97a4f0b460b127fd7a13c0ebae3ce99f22bf99a376344e61edae62dfa0add614b49710661d6499549b982c7ef5533cb9fe9cff08baa545d35c761f130f858d98617a96526dae2bbe82c3c2981846a8919c86dff7f75b18537f5d5ab74fdd8de48d782b3e73ef9d673e63a90ab53fdf2ec0181553f5a022ca1e98a0bdcb4beaa1a34211f881b2189d8191f8d0195b19f499abbde0c71a5ec81d3839c865ca81439af5d76c647a06634dd1c3cef1a29ed93480b4e413aff1f7c42dfe59df938484ba8f1c77e3a314f24a4c06685c5304523e5d22ced4f9c2a5454768d6997a9c764e0fa22d4fd712fcec35f9e355d8608b28070151a649a951ed0f9bb51e32a27f426aa5c1746bfd7eed69c9580ca8f7a6c3fa4330c7bc78989de8e7c1e1123ceeeef85e382999cd09d811a71aa48b1860ca102616891b291497538dc82b2af70f77b285b74db3d5974d2cea5d7684821c88cdbe5af62554cf3bf917f287ef64e72cc12f23ba381f0fcee5d8e733f09ec994abf10d7c90b373288b2e9df17bf471b69c2e959d40ee9720167df4e21cdbc3bbce5928a6f89d4e16c8a4c73a062b09b9b1f66c0268f36db34bb97638f0ebf44945de2c90586612b8f082895e54a064ed7a88224a7a9a530d517b77bf493b0feeff2ff7741af8d1b884707896379374e8c64f2aeccc791740918a4c1ec6709f30c1d5ae981e44a1ec26c84e04a02a365cb9a5e908a87509db876aac10c193714ce7d4100ad9b5ae7e67ac04a6f7e9e5969de21d724d2732c5c6deb9c2a4a1f502d1fe98f6b2b519a92856f60067c80c5d0ab5fa1d2b0b5c0f358cea6553596007f0cb6d8e6ffec515d3c4d70f912079b544c2d5032c798bba0242d8701930ed10fcc04dc1a27cef0d7ad1bfc975fae4563c6f120c28d9a0846422209bce7cc53db05e12316d2328e3d40e1473cda26805a9e7c15ee67036ca236c180106d2daafb25590bff536b7b53107c681c783d6ac22613c3253ce1232b4c1bd8cc379b6b310f9733c1a21b8233de2b60cdd95f10935baaabb3400216db13b82c0e9ad1b9c5c23f4fc430430569a328b4ada8df1566e0c34963a7830dd54131f59c5280dd5f7dc903919f3c62e1e42d89a8a19f591c7b339fdb18f1472d772b3c1a717b574c3730978b67b4361adca47656e814cad386f744c7fc87c93839975ae53febebeeea908b1f8006a07a68554ab6cb21818eba369e11a23fc339c55b3a5d79ef21b4584c9baaa81a53ec6a68c94e2e9a4a27ae62ed8909543765e0f2cf5e8b12cf593969eebe78417da5c38e708c5d283a7f2ab4c6431820ab60c47e1d587f1e76207df9ebe1b92d23d7219a359e561a60cbcbac925e547ebbbf149fce2929467432059f87cf5198f9cc2a6de02c4bdd98b44962cf95754ea8390d04ed8f496748c7ae2c53f0914ee6f05d8edac232573b11a8c77eb030b51f20602ed588456bdd0c399e52b75a0942c35c1765272362e90147a550c3afc18e7ff2c4d5942718ec4cc5a2a82a19c370c4f9eb800b25933494a569ec580e787cca9fd2f7ce74d618cf39120533cf9499c31b583bcfd0a65874c7882dfc7cb848b91d14c09c9f90afd5678e7311e13700f1c8cdd1ef8c78416d28f7e4ef3a5f7f8f5b056db1a53a4a544785315fff528ab5aa821a03699d1661c210fb4fea5b78f2025d6521b6a887d72cd3429b00a011894ddd6ff857d94b67fc49df2492cbc2b0489b23594ccea85d06a47bc35764ff0285d336d1c07922de882e9f5155eda0273f4ff4ca245d7d9ce12d1bcf0b20f3cb4418005de35c52ba13bf9354490877d768f1585439bec7d7747f34ec3ee8607b7d2cfbf687abaf81193e99ca715b7545976453f587647f872cab034976b14ac8e5a98b69d63aed7119b80e78a9c16bbeed515fca2b435649d57d0297aeea967f3893d3ad5a0723289c2a9744f6da2eec0f9db2707132431e7e04c3223a049decc2cace4dd00508a248f4a8ebc590610cb4376c8e52161e3d8354f578da84afb597b0f2915c46fca3d9b32a5b4fa79dd0fce40594bac182a7121f452e571fe2471cb48dea8abdce20eb02e3a416a690995fa46907bbf7243eabe902f662918fe3ca8885d4ad30619df9b7a6296b50b3ae1261fc2eecfa6918297d02e9d7e12de98b889a0138d854dfddac975815853f88068734ebb5cfc2a677b55025c3147f04f8becab0b71e46861d7b1d8b4b206680d2961d3d79c767e2b501bd23419f35120c2a3b38f43b541ab51c5c24a2ebc67ecc0cc2a044e9c5ddd83b61b2f3e8e526b2114fa91cb34cefe7b69c429afc0d35ddc5380fdbb19eddc9c677beb55a5eb86e4488e91b2f6c4fb97a14b102095406c9558cab67cfd20e177a47b4fe14a3c20044d2834fd2f8f0628024732c369f28eb554f2505603ed8a0acb33222d23b29e97bf99d40ba96a9afcc4965eaa9464c07f0de63a94318a00e421280544da09f541858a38ca48412279c10c4c41aa352fef7b9ec3eaab079efff56714a9af492a91ef0d622b3e00d9e7a9a09295332c31a35f5a500eac40dfb6cace62d9cb7882dc2bb2c7a5378c24d6489eaead47b45fdcfec8b92290017aae7826df4d610f3d94d2dde33cc2353835b6513911c800108c2d2f85291aec55f838bf128c66f08b8786c5dd83a6b0285cc6c51dc68073369f7efaedc1abd045e98f5c314785d3f215fc42069c6f6a88d63597956e83654f48a9d12de8a85641012abd4d30515f0156659fc4d34ebb8216d1caf668755b0a0697c289fdab38d13b4c06893a205dfeef53142098ae83b81742e3f6864047a740fa63e0fad741179b81116134ae7fb91404bcfb3f429b289efa39c686d23b4944f653ff4d31c5ced2f9dba690bab96af811e4ed9638cc5d7e4426d7860569256d20d184ecbefc8d2d48a5fc9a8a8ce1ccd038f4f325fee85100d9f28ddbf887317705b2abf5879617ede5cb8aaf00bcbe0f32034048b45cf94803e45ddf6ae71b6e35da89b2ac3d143d324754234a60b39555dfef06bc0ff09574bb0fd54fc73bdbe39ae41ecf5b46c762888407615716d973284e36c1fd7a96f38c456317b37332a57da4821905c7fda6a9184f98855dc0c9f9aef8a4338ac71cb3ef544879c747c6b67bf761eba492276a33ff400c14306117422bb5047c437ca65c93777ba398820c89941cf15c01dc5f43899afc8e1e062cbe81e8bcf509554a160df855dac8eaaf75ac977b2225ac4598f509e84962d22d325f12e1a1e47bf6b9dcd0da14d5ac9d30539de5eed7914d33bf27be9e92a3ddac602ff9cb42fe5961860188e6dc8cf1afb5b98e2c67bc8436521361237bca0d18b2403e0119423780bd8f5b87a3232f7c89fc4c9b5029518bb0fd23b5714c7ac1ccb06ba16173c14335ecd6c839e5bfd974d000203161d5bea215ba47374b5b62a3b8fcd5cd09ff6968ad6063ebe36f5595fde40e1923a36d1dbb6c075953bb33006901ea3a03acbb992ea6976b2a22095dee822195c407b6cfc0d42c473b10de7480f960a8f62c6497c47ab5146b7ec484824286b3fb9146bb6c8d7d860148cf409dfd19370d380baabee7037fccb14d93fd92ec69caf03cfd805901e21b27c693726ff57df48920e3ee2009cbe5b38afe59a2962c9e38135a44f554e8870503a657b88740b23a14933be4a1dc2e5290e6d61178e83fc29aa8e78add8bfcfe19e5eff359e1b3ba4db1ad76654ce4ffad966aaa26b275d8c35978f7ed1ca0468c072ac692a73c6a072f07d3442053d6b707883102e39dc4d8f75f8667d6865623f850fd55f1b2d521ea08757e19af0df2b52078b11d042cff2c1b612e00fad46ce19b8af07b26711c65b58ebb15ee652dc866f193416cae370f1e43c69042c0723f54df1cacbfea1bed11fd6d67c03893e8ae34c8a90b2a22787f6056287da39a0d3568cef9fc76ea28c455a6ab8149bae54a58e387757a76b8858729a0ff39b1157a8fe2ea4e458b188028392c879b7ee7d05d6278b1693072a012a6462fca26763053070c862a9c7d3970226397366e1125a50a0d0f6af057bfe38d41c447c8bd767a58b59d42012b30bb61e6b057d9d6810f9fd32edb711291a7844db007abd58073d977701c78ba7a5113a4ca48f5d5056a9df2eadb2d8c6347f0375e904194c5609028b3201137c3e20689c550de20e5eaa383f7cad7c8578754a9119bd1da359168105bd39fe8db56dce70bae89168107e6b0322cdfea725adf355c38bfd6cc5b370d4b8d582b396751cac6adda1029ac55c8d2e06f50e2270d299eba690aa05208d42ff23c90bc7ee59998736b91c8198af15d4376904920f7400f573f10d15c20bae0203c4a518cd2849150a9d068283f3bdbb97ad1bd3fb99f81f7890457179efc4339d820abc98f6362da5ada8adb75937aceb5d726e397fd2316482a5c94bf1b3fbd56a4c137709124208ef251825bf76efeefd5be77dfabc51474e514b1d5e690f48cdbd47d6ae292656e019233b0c5866b820bf2f705132ae1fd0fb3091ad76fd532a8cb8ae5693d4780eafccb31fa45260f18c2fc5a901751e5766b1303a310bc9c5889f1f3ce38e8f469963c8945858f253e3769119c38ddf3f0984db5d60643d218f3716868eb653faffcc6f828e814dc2a376e067e8feae32f95ad14e30d94dc92b653eb3271fed4457c1fc670114248ae1e932cddc58a051f1304bcec9f40ce8ecb4e2c351c231b582675558bd2653349f3023ddce995e98660c984a58aa1d738da733856c8dcff212a576c118d906d29f68686ce080fc4165797d220bb43ffff547f1bd5c9b21039785e73e071826c3d695ef1f33f22add49ce18a62558347c85878f12ce78a37687867b3cc9229515bd3f0e4439b84fa45286eb62208d7cb6738a1164c4f8a92dca60724ea20d2384888874ea47bb6f462ce31a623089a6e5cf2175f3059b22ae3f213be7fe4c37f3c82389db1e542e5ff170a3aa174bca8869fc537be5029545a0978d314e591b6bca4a14f35356ebdbe57aa26d467ac6ef05f72308fa657f7abadc6e1ea397d2fb0373236b68c55f12abb55167f37017fc2e910089b0d26d18f12a38e0a4773f4e1ecb5bfbbe7842228231b94746a058e5d52786eb4dfc8454b32f737606eb6ba793cd4175026eaaf06981928b84fe6073c0c1dffef74da81019616ffa425216597e1c83dc0022fba6482c347016c1ad43ba12a99f6cfba11526fc03fc15e140433a3c41e419bc39283702d031118dba505f818a2f95b2fbb3035fba17823aac5eee5465095a1dde399227f67e157d8618e8ddedfea2e2957d234044a7aae450bed02d2e00a7a9d23e88ec24d588059754516db865dfb1b54fbab065db78df6aac76499fc207a44a2a56b316980c6fd31b8be386f7f83559b101ea8f1926045ad1c268934398312ec6325e385d171a13beeade222413976f838d37a427eec83c80d65c0f9ed424506ecefcb64c8c39537575df409bafa703fd0c6b0c78f7058a76db4e0e7647f1fd2727281158f9865271632f942a565fffa9c64376f7ed22d87930363596002da57d299f88a24de93db81fbeddc0e700246e38377c02e946905a45d5c4e35ca9342ab3590c73f5983065dbecaac22e5228f622eaf54693f99c5e530665224a970ede18b67d47232cc3b752e6f4a384ef53e905e4eb361707e0f30bb2ce4ead6113fea154fbed25aba7d93fec9e61be43d08143f8797bf15c409d6f602d0e8129b1c775e92a8933a501a4127cfe14f0c3d8d557de615b85b8733a9d79a191759cac162bec5a0fb2e4dd86c5da7a541439bcc35cfbac0fdef71110821acd603e63ca35df9a0e1d0d44b430cac341b685ce2cab9f009c792eafebebc184d14bc7dafcbb3d2286c4dafbd37c0d08b7d146751d70f926f1123c8d64445aa638bbe257f7b0bcbce9ede4700f5d0cc658c106b42d3946f1e6af0f97e0835b86a045ba081c6e6b2d2346df7f5497e123cf938901ae30ee6acbf46c4f161a6a5dc68ff0d2fc66b85d01f5f4822bffb2395a93189c6df3d97aa910588ae1552c91abe75a1b28f675e17ffa84703d4df66e6554b4a2490281fc71aef70ff91497a5e43ff38922368ff98e3b3894e86defaf2d1af5a0855a92dfccc95e10eac828a477a804aea3f09ea7c2f6a6886ee96a11ee46528225f6450c8f40925c00df27ec10f9c314524d5d15a4835cea0cec5d1a6c0f766b109b8c1180423076d802d0aaf9c46a8d0744210e8d277397be35e7ea68b3312711274b700106ba6da04d7cb123f6450f29fe6b00b9712ec79b5ec0df36c4c2af672aa3d06841960c43583fc758de7d9850e6bd6e83ea3adcc701a86025a9388a7b00a5f9b05823383492e9c1a2668bc947a180722d4416574c361a72f43d826ffc2d9d55f81a3983df5bca31c0f42f451dc5a6643753907c6da4b849da180ed6f8c5079d9e7faa74ca330182557c83d06ab287e82ee454fa11b557225febee162236e240fe2baad702488bc9b3f03c38c0300c7e5e512cc17b88ee38bccc34902c6fbeac7b634f37a53882320ba08e8d4e696a5b5bca34f401bfcbc07a35d2196df99e01867a3c6066dfe3c9b38c9f7b521acd788cd8ec853b2e0c249a2f5222b2e3905ac29390f4fe596574b926dd4f471128712030083317bc1a2561565bd4bdb9bb975ee871058bb281f36a5fb815334112fcd4419c1241413f2cf2889f56ebfe4554709abfd9020935574030cb7c6344b77852aec4bb0712013239ba29dc7194b6eabbf4c39e0b97ed55945605c3d100c8c73f16dd6eb5117117bba22cc3cdaee4c29c64912beda6caddf1871c2fc69e793dbc7bb25863b94a79bc32ba2dcc48eb8776fdda5ebec702cf6df33f666d5af2331c309737928de720cb57ecc58758a308b87622707893ef9ffb68de3bc74e19b518ea6e4e1dc51c681c40271829f948ee210888e0667044a1d1d7d4ce87729efc5dbad214210678a8272176296eb75508cfb672ebcfb1ea91e8e28a4819aec3f0309b713086f585d66890b4833fc095fcb5b41e005acfba8a401a6a6ddee662eb68007b83b3f1be287eb87c1bc205bef26157fb54cdc56ba7fa320318f082dc963f407c636d7594647f983edd75d7b4dfdae7bba8b5558d30e81c960fd58f9c70a12a8f881bb288235b43d76ffbd2574df91b85632f7b933c363279ae6e20a18b3a7ff2a177c85f26db7058462f80df0502e4be069ca096a34fc55a4ce4ce6a52c7cef092cb1b2de66ce6275e2675faee60481b74e0aa49bc3a10a612d6e1ebfb4b9a6bd4f8b80a58c3a88ad39764118ccc22c08914f28631d616be9d964828ed7bc3e92f3293f9589dc9a8ed67138cbe4802e1583d6a82b2fec498f69efd55cd9f5030c074d28d9cd9ab49abb6686ae356b658aa453dc5ede9f79f43257e8474c7191c413f7d97f2603e2f560bc645ece7d199c651f5c96c3bd56bede076d19068d924d7cdee90fc62f2ca55b5533a43fbb4b16d39e7aa2e09b2ed8cd951c89bac634fc665c730c3f137a3f3aa5f332ef556b97eddacaa91578e71bef98d1dc2df4ee0aaf5efb9f9ae923b6ba1ef6d843b9ae00d942511d98df762cb3f2c726bcd06dceb6e87be6533287ddaf9e62355e907669c1859988edd0e7d1781a2a14bdacfeac2538d6ee004ca70460f91b0bc5cecdc410630a1aab6fe8421b7ddd1e1efb854b03a3410532cb15b1eba47b4410ae4585ef434d04d5265ebebe11b0763977a49e3c8ce59a2a93931d05bc6563e07593e8f1312e0df702c676acec18e1cbe0679dd72464339de50d4fe80ba685ab0784b1612d42a9026df03ae8fdc22a060629008e385604ec101e9702f6355cd043c1d79c741671613c569defc6a79d07f2efbbbb753734d5e8c09c957f2a8591f63be221567dffaffe5f96b74b8602bb069fa268b5799a97f5e83cf8e87237fd5c4235e6c4df94380902b71e0c1963525447d3edb86373d385deee42c590a3ebc48bcba45025e5fd75f8d46ae60ffa35fb69334ffbb8000c1aadce7cb092fd9fa7104c8265e741bfd0b304a3a198953a04a67f87912cb4757a794e714fd20b2c2118e94fdae0637a02e49fc44baf56a27258cbe0a12384889bba1ad2a70a8d6808308816ece91291fdb3513f6078a3038b04a2b053c589fa9ffc7ea17ad3aba79742246ff18deae66e275686215d3c3c1167b8443671596f29780c76d734e8cd02a795ae67e70f97eb79d53a0449a488d93c40e62833d23eda70d05a27d7461681e385387dd9442dc31e8bce90e4f8c725cb54748ca5fb272d63ba4a5f62062b773b15d157fb63fb403810cb3337959dd2ac589159815952cb50f3198de6976bf2f851ebd6dc242e1819b223976e5d75f3f172978dea55a9144896ff67b499e74a7c029a045e99119ff7ed4040128cc2ddbca922dc37ada2d97bf5ca1c0629b63c086673abb58e4ac3a1b888d99b6b140cd664611f2b5e6432e62766abf0b99f28dad5e5e7e3a34155eea42bbac8a82a82fe378709aa261e98c8a82ee71a4cab810983884bad868c4c6dfbdd9f7bcea16576faf724341805a40b501bae5a85d59de976e7d7350340085cd52c61d4806364fecdc284263c36a6454c2c5197740a470c8de7c6950a36a7b1b09c99fbd770b484a701adfde923aeef0bcd3edadb031e691c30366afc5c833dcacc205dd56da747d3776d46bef2c9e1a2ee9a092222a2913ef4f2b6115b9727bd98bd8278e3beb96f0a561395fd863967f3f465b88aca79df164da5b700725315a2b198ba070c5337cf89fcc8f0c4bca065e4ac8087e1528197f6e77dca8c37a96277f33aa6efd7635726228db88978eafb864add6d259b6844c19b2195cca80290397b8778ed1799e7fab6490e672d79375b2aa7c9401e8d59e35bd12787a189ca63e37804a6abc63200e2df10268eaa6b2ca4f9f66eb4b57f48eec33d26becf90b8324a4f3ec5fd489ebd38d13ca76c0a30fffccaba0da1ccc7c47406abaaf01fea4c18f7e28c386fc6d7fc66dbdbea4d0d44e5334161ee2e906138620b9649a82d170415665fa40c1c783daa0964873f8ecd55114e5c71890bb8e203e7b548b1c2be12740e897b7debdf99a3e10fa6e81ee462cde7c86a327c5cbe1d0d6a0a653188fb5da94257ceb9c5f7653099db5887d4d5632d2c0360d02e0b7ab35eade8420d2992bbbb9c5f2489312add10ceb1c36633e58db6759f1bce537d049041966836f3b9bffca76ea6520ffb28aa82f3e26dec50ab6f18edc9dbb156cca02626405b6d3d6436e38379c09d6d22b029d4c37c233a701973660ce6f12247c572217479f6c35c56748f4ab0b92384c3da4ba2895dcd46c32879c310574382fe5312e5c0b2176ca7d50a691361a2f5621372167e7f8ff0692401b5e7fef219fd5a390a92afae5f825b91745ae3117f372450d1d4c86714cd1e2eabe9924373d984682fc679308d3f8b59713b66d192d43505e3df8fe09b9d714a99feb470b09582de7b240fd1397d00ce0262fcd0a96d82f131588ad26b26a4d5bc672b8eddf474a2e740e6d78ff1125b9e9f9056cdc2e01f07e7af05dd417cabc89890a2ed099e979cf9a35537ea191924084c104573033ef7d3392b0a28963183fb8b657ee5a7d5e200fb006244b7bcd01898f27de269fe4f9dbf4afbb6b2f1dd33c9d5d0f2899759025c677402968c68dc51bc9b501b823f80de35fb1985b75721324ca8d3755945f23c9c46467e902b5152ab5e0555d236a46ac57f0c880c9d728e6bc7b566c54d9c0b405530986ae8cbce96ced1125df550b250df13b42f35bea6b31b3138f36c10fa46db4aa11e223557595c966e495085f6c164587c8ebf6fac63c362fbac4d4abc99afffb851bbb3fceefb9bf3100ed4705a89623bc63df88adbfa5d7ab5749152e0a5206cd57908c5acf06142f147054e8127da6070781eaac8a7066f6945792dbf1909a688f6b2c897e8e0cc45fa30ac9a6ac979d322e113adbeb25913c68cde1369dd303203e0241f63350d17159923654cc44330eaec77ce142fbc61fbff30af6e6562c8a00efeb2b1483dc54a3c5446ca77ce8c3feb6dbcfae033690bca3afe4836bdc890d5af6f96e7b4ff4c3e9cf239133027d88c6dd6d888a2fc95bd078c51d51e6a483b635d7d98cf8bd174e5cec948fd44fbf87e996cfcdd83e43105f29965ec028db01acc5b0820f224f85fe0ca0aa6488fd7fada844af04f28f03c7e39548920ee97c0fefc6edc41fb70d60687cf9848799437f89f502cc157c6b0f2f1383f38e7e8a97381950a1c59d64f5dd04509504ab41bc7d61ac4fbb75e13971057e3dc64af3d4ed7b8e070677c95a199e3b3173aab001e6e055dd717464d75a22482a40388523ae42ea58a0881d524a9902aa349cd0ba1ff550f8b707e13dd05f3aef2826f5cfc0565867bf59e88fc8d2290802b22713f12133e237801dca7303ad0ab63eea76a49ab3503bbadec631808e85a94b5ebc38df2560b289df2b2b5d4adfc54c9d4b6265f682f575d14d630db73a24e9c08cb9ac524a79da66644003e9fcd3eb8d267abd18632119edaade7c199940df3a9af69b5feaedec4cc0ca1d9db5256760987d79ac61aff6a6d9952355e2bdff6aa2d58f4f0ff694c85bf5439f8be05e81045acf4536a71a12b25afec955011ec13e87a107f762df116dd26cce1166cb89623a6d9c13969ab3d5b491ceeea6642ec4b62a29e3ab2e09810cb3680ecaf7114ce0eee0946ba5091d544d72724c1470007e018b08417f0d642b95521f6f1ea77f57b56ddf4528966531df4d93d7333e9669cee563107770581f946032f8696d9b119ffa51ade3cb9a0fe9d731a766703a57ef2ce4530ce35472dd4577d3177ca65ccc282c4c3267a8b66d7bc1d4337060df14d41a391a407c3e9ca8cdea6eccab43f82a5f967826962ce9c4a05af0519c80d0591945a6b92f0c6703556c71ac9fc57f2de548718b0ec1a4aea20a308f2460bb28babb3db396e3427adcb8a77b0a9f826bdd7d7ded96069fde24408a8d50458e31f8640004c3ee62cf973c43397976cbb2d86fa228fea8f22d3e6e021c0832da3eee732b0c9639819e7fca01456c3bf885f99b6e2b8c4ec177065b0c95f5c3c628e06cc7e40dcbbced7ab77a99431010c75a0dc94e3f7c4e2cac4b44ee1273004743f34cd8ce08c42549cccf0a4c6c50429aa0224b49413e8a31a975ba90c24050b2d2e2041b2955b499851abc1038025d05012f9b04321e9ea1efc2eb2c3cd8bcb9fb3bed4a230a53e432e8b08494bf4800c3bc3f1158173f89b9970674b4555f1340ea4e9db1f0963d4dceb4c2dd1462776082d27c8632534ab7d51edfc7283a21197a0aeee8d77050a1cf2296e69fbc7b0f7b1dbd4135e9d8e66ffb5dbdaed892c69dc9f179ec6902854fa41eacfa267a56429f5709053dba64fe936bd21107206430632be45ee4f7da62adab2d260a2da6532502d0c9593e8ac2c554a76a67f9d0478b4fc455913684044359e07b34bf844310621e01f717500164409a197f18501dec449f356e00ad5ea0b0c09dba7cf75be3a66034ca9d0ae7ff88d9a7d47770391c94139339c5c54ad2322fdf18853f99b3a108272cba220942f03039d96715b57449766e83e6438837ac93c71331c6033beb1e2347291d4510f6bedf13ddf70b6f99639aee5e8bd02944efe72e81066b9c5e5d4bf3cd59dd1c48bb26e69afeaf0ee4028bc7a5e36676a3e85d2cfe4da99e96f325f95f8ce67c08f955f294f2d4983f6f4676dc1996e24b55d7c87c4adea9c001f95ba3015ee3412844ea2ce1e3a34c92f5b37adf3654cb0d0ea692f6dcbb59caf41fedb4e420cf158197312b5841186d0a8cd670e38278a0cac076bc61b3c84e4a49bb05d1524f18451dd5d4313cd0fdd5fd1837bc5e962aae57bbc5600fd2fbb664c28f249161616ef8ac08528ae1a3f31af7680a47ae2da807c2ee1d9db6044c6974d0659312d74488e8d1e7d23fea425c243ed17e12c95bc8ac6d2b0bcf8922c521a8a5131f91976103c8196738d932551f4c269ae17556c28b48f96f020f5a747d5d672777fd51949c40b572dbef48128a1bbda0c3f254cbce295dc54949b3a48c5e5ff7efd3bd4981308b5744b48080b01f7c9a4ad28c482d62d2a7ce452b97a6239e299570a3572817dc03bd3e4bf639ab3b66aa1729cd5f3ef4c40d866dd9afd68d67747b7b2106ba67cf5ba72c156cb6ec4e4be8dd87497885f79c56a30a3d6d306d8e1057fde75a959bf933ccdcd7902617d5e115729cbaa667713a8a39b8d60da5108bc74e9260f64b018fe94871091426c4150d863c0e9c21851620d1de3dc03c7c514d4e2a28b92423f62a91b34f63fefa71d55ad0f22195fd1053d0b88c01cbb46300a40466492408650c58cd4e2db02876295d5a9b4f6db5a0edd2830bc700143f5987925fa0edeb9f40c700290559b16a45b19f714d53ac661d9ace8f840784cd21ae19b0727e6b5cb0a64ac4f2549bfc61a141485ceff7ecfb9b62567057bb422a61d0d2d9e4d063901b1849d51fb0a4e957716a51dd5992311cbfeb68b764ec05b47b2c196aae3ede7c038ac4385562ffd1e15a565f089a650a506979ee391e168536cea99bd5880f83969943c34047b624ddb65013a4cbdebbf1a341dbe267627cd55fc597e1cd91b3a2a376536961ff1e2552033368765318ea7349a2f11020200bac16f50f5a7286aac7d9ea2388ac8925b03f14fa147666a5f144ea7219f515b60984fbeffaceec2a240fca62255ba739ed8a7e4619daaff88f51966fe70d288c7a0d293540bff82e89541681a5a864bef6c2fcd483b3535dcf5f98124c6a159ef5666877b2de2bc31c1ce290439f206bcee1f1ace951c456fb4537f5fd08a1fbdea2d3ffa1fe3b33ce068644f8b2796188e12cf8756b7125c13bc87f7a8628c4621e213cc52d5193d4dd6bbbb60f5070abfb5bf813747d3d805cd379a3edb34994d1cabcf2f5d25d7fbb2383e11f62cbdffb5832efef247fd7aaf22f0ebc7694cc65e2bfbc20fd3549e41c07a9d1c856d4732c722236fa308d9a0591faf1e52d2b3de006beeb1c15e371e3a812c2a9a83b1278d9648a0d74e11dc61cb8065d4c301aa337b201dcc811186ca74801cc474e3df24c100cceff30f246ff192a4a5fe363886682db93f565125516c9bef52c52714242a69911db2eecb525203a1259cc25c6a531355939dc566e37bacae437783e2fd35ca1ee5355ac124c2d6c5211021564adcebf57a7c7050e45237ebedc037ec0e801608eb8df2f08849bde79c4a8033550256d1088a6986a6a4d3959779697251c6f68f283587cd214effaa7cf15557123dea7ab6b5bf76da4b75c39c14b6c68170730e0ff11e438079761c2c7e8d6d6b0b4067e0e806e9a8e65c89b2aa83f817bf497fc5f6d0ca51aeed94ddcd226c9cbd3a996d9173f8c5337cd772b890bd1406184cf941ef46a94048446b01a244b44112dfb9ccdd8046527c50c112838856c48ee8fbc90d6d4dacb87ef635b62c3a0054791fb3f3682854ca62dd2a1713f1815ba2d071cfab4d5a35572ff8ebbb29051d389f8c7417108459f313c74efd8f990213eaddfe99dad6548be9d0dd824004348e3f84257b78e847885f12ae10c48dba486c93192a12efb834cbfaf0edca01acfe4bd1fce6779df9430a2a5efb197974c3bb2b23555d6b9b5c6d36a6afe310e9d86d895e6b50c6274654bfd50496fa829d539b1491dc83a02cc725ab22571e8eab52f62383f332a594306a51726d838309c86e7e76ea1461cafc76604eff759506849815926bf4973578cf002a9dbcc724a03d403d3c29d9b9b832459741f6c1930a04a65cf75c839342b4b670d304247e3fb5b5d6f734177bd20046044aa69da8ed63c5eb029d638af24d28b60b90ecbabb31f06bb61638abe1a4af7deceb9e9c637e56d1a6d216b6e54524d62f474fc829d65416265a37a5b6be03e822a308917e809320e7a332f1033262b9ec8b3e65c102f235c6042cc13ea1e07c06ce81bf7b3a1c2b23603a417112d3d764544a3e7dc6d1cae751744dc2124513f43fc565bd2276ef4ef7fc9b81175714de42a5a374e18b0014737ac79d9bd6d4961093dceaa0649ccb3393297ccde1cf95a577f81815c0226ffe8ce00aea3243e595e7beda38dbc021197f4fb48abebd0fdb1e8b796bff02e72aa86aa87ed958b3aba0f6b33f2559733989c5f16e147564fc47a4b990b3e0e02c42884e087629452b0f57799c7546b0de2b21398451ef31f448f313aefa80c4384b63bc39278762c13d63d0af9afb91c7851ff9c1b28521706df0ccb20bd1a968954af55328baaded1c9034aa107ba2264e70469d8a52519541f062e1071d54ad331ec8eb4cdfb0395a589a901bc7cfe2bbd09b6a9762e72b31519c4df4a5782fa83d0ef1d283d28b212afdf2ff0f3cb1eefadbfbc498193593ff470bfb6f63540920ddc75e238d9f9e0ff41f4e46fd6b29f5d074a5f670e7159a9c66694fa06cc3a12702b332b152a043319714f9d45f3b60709ca503b1071ec66f00769e52bc6124f5ed67a746c51f3b34d8243304859040c61f9cae9a8dff668aebbc9d45b18054a521ffd4356f8fe1e5719cc29c02f657f8bdfdf65e8b82f89c3a3c1f6d56a6ee47479bd66c3d71e36bfedfbde71d3758c137d7798b2f9afb2a06711664a271e1e1026d85baf46e23bcb4fadb21cec1dbfb78b188c3fa8742f8c6925283beb2f2e9091a43983ad1eb942201dd53076cef7791b7a0ec8818bbb47d26f581784df13d38d26ea4dbd4736d1e5d4246507c2984a82c0e71d385303caab29aa7f572b45f714d7c1f3b19efd6a4d970d94ace89f5edeef66ecf83c03e1f309b750dbfed5ed8a50c40813584662166e516c583d9d2f96e5788a307012f349de470edbd34536de092c1a7f747fbdec8ecf08a49da4ba625f2a328e184d9440b5e15fa97c6c5d1c2e6c8760e9c861bfab1f508740066579ce3587946c6625b413d9629e6d8e5292fba1ab4beaf11a0bcda95fe4a495a43053bf0fc94e58866e6b4a7f2425d63a1a7cba0cf58c211e3d65d224a94f88fa022abbd03d2b06877c38e2e22a3bf749b1ec109b45c48fc105b8f04183e40e856cb1c0e9dfd74e1d49372155e40a8007864e54bfb13beaffaf9c5247ba32a28a5d49e8e83fe5e8d13431dfb50904dcfbaa5d9b5efa8b4195976b2d05971b5deeeb10d38e0bfa4545d6d8363a93bf46648c49c15b2ee4456ad1b9477b999a265ed9271538fcbcc845a357f6aecba411e6ae0c2e143d9bf215cdeb064ce53d92d44b83bf8ffaac0ac3456b4cc09f5ff5a4512c70aa293df0e6d3f684b431b7ff946f7c6b551843ed5a67b712e7a7e9dd39ab0a3f0a8e470775e0396f883ea850a3c7387dab35dda85aca1f562c4b05aa301d7f5af340a320a6e39e5e3eb9891e71f5d29cac040223cbabf2df451a9d72f0eb1f72ab03c38c892a33a55d140ea55dd8d5a7e844a3a21256277d8fc69ac19960ee1eef8a6a436500b213199662c4bd5f6f64f92d54673a703c504aa67f4e53929b0c3a21051bf58facd055c3d9915f10cf395005fbc52a4e213aea4cc144b7e0df0fd421f43d6919cf98a2608c54a7430f8eabe0bf353c6aeed0b944af23efba75696ba5a013f76ad1a6a1e08743710568505b1917f32f9784e83b1be90ddadb137023437fd7cca07d09468a88836ad7c7eb11f7785806b0a52cae4171e14ef2e0c003b3376d05668fd8d8f33a96f0b1cc48b744645aa5542a9b015ba4118b0130f6bef076acab374cac363d58d991e7aa7d1d0527b25de16bafdbea2cba108b7b03cfddc3863ac96bc63b7b8c9b761c546614d5114b8792b0078ccc8e4a2b48bc922df177894e8ff34cb063bce7eb4ba03844a657f2599f0b6eb6c6be0a488454ca454d0787b695f2ba32de4578e7f535b078d9dd5baa89df5daef63148b83dbe5e119c98abec5bd03fa7375f5f85ea7b533bdb2b2128f153b35276b0294c7edff192d1e564b2feb5411e461b993d1dea04aa154b9dc60d78a3589a9ed06b10f193fc1f1af0231dd48810d5940526d80396c2616b1d200a31d84d00d355449a626a636903e85ae574bd2877064909caace8f5455bbd63dea232509cd9bedd2fd11d5dc6a5f8816077f00a5e3abd92dc83bba2afee6133a54bd037b353b861c449566c0bc144bf955879f698df97f8392a76dc195ab64b2bfa44caae3c12d4ea6832eaea68bea77e674d2061578935e105c051a28a5a1c00e979b327ddc3b3797298e1228e6be50ccf11bbce40a90d034965334205600d6eb3c6601cfa01e4d99419110a9e60af1e06dba03aa98e3db1671ec2fa82e33694b23383022ba877bdfff3707d926c2dfaf9950e44355d5a595c843b264d74cde8b3aa84021a3fcc777a4c38fb07a83e7557f5ab7e04f65fef7f42ac0d89f6c1dc1e76c038bbc36fb956fe9727351cae0ba8a7cbb006e27da883544505af1d51ee1caeffe78f8474d0623c2c5459be65f08007ee27785e7ab61b910a39252984541f4c58899666395aa4989b560aff26efa4a2451c851a284653694ecab8b3aa5850886852373dc0f6dd6142d2ebb59c714f25c3910f5f5b7a2709abaa08c83e41513f7baff8286023184ab7479b36f234e47d7a0ebe9880737d135611ba4fe441604c347dade3c7734727aa923989a049a7180d878399a8d8bdcf7953b9ee23b662a565da54f3b660c7dae2bdbdc4c57b12fca328cce943a0b7df19eae698642d522cf159aa5ddf4d96add7b3ffdf2e6eecef57bb56d63a88f24833a6784aab643ae6ffdbede8c3ec371c88e53168c2c52f2ff3d85ef3e6bc05a5adebe3062f877f5112e1d547623d6c031f622c756b546d8fca65650f81216dc6a02bd12896f615d936a85a47be3ce9ae6c6034c4f9f3d8048c7ca6ff50a90bedf4dfd06614c496b7cea6a754a983182fa29bd856fb7c6186270fd3d9f07429bdb5f6177cdfffed195eef635225c43c63c4cea5a395ef758ef0e6b3b76f05baec70912faefeb36ce7e503011bec96d18c8a6919342ca08716852fed2ba3ade7600a4866937a5464abe0554c5bc7d244caea3e7e0d3f29bd2a5223e1db0a46e8ea76a32c1ac4cc426dc648d225402bb20ed6ecad1c16b7cf919919db576f666b7b4ec4ebfbc49f02795e9789ea8a3adda23aaea9558b3ac064fd74dbb13112be2d628d60626cc60168c22cb0e00510a9fb99bcd2ef32f88232df5a59e0cc464fe2c5b8dd31737cde69ee4cb3ce8d1b3990557d03832568cffa9dba5c21874de92b0e2d6e39ef30111c61e421440836a1620a924195d0a68734d3cbab5fb7430419d81fa1112941fc002f2a74d3293ad83a4d2d37f2bb748d6195d146e77781d34f0d05da1f71c8f4fb43fc14258ab03cc0fd8ebd972c7725c0bb92966d72da0954e6336444493e5ebabe4ae6328dc90b021f2f8d0ac10111e670c6c9cad7cfa05ae295b2fcd065b64b06316c035722d62790f36a2b9a67d0a8d881e1189e84691b59edcc9b9a9a2585d3ba80c00cb1d03afe374980a00a0793976700551061d5e050981a3bf6615f11945d34a9c269e8fe1de004f6012aba188448a9a23cfa21c3c30eda4195dad93c82c08fc004b5300abb2fd457c992428d2f9d1f523ee283b2767536193fdd319e75b6570a","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"Python习题","slug":"Python习题","permalink":"http://www.a2data.cn/tags/Python%E4%B9%A0%E9%A2%98/"}]},{"title":"2.Python判断和循环语句","slug":"Python/Python速成/2、Python判断和循环语句","date":"2019-12-08T23:47:37.000Z","updated":"2020-09-11T08:14:26.849Z","comments":true,"path":"posts/51417.html","link":"","permalink":"http://www.a2data.cn/posts/51417.html","excerpt":"Python的判断和循环语句","text":"Python的判断和循环语句 Python判断循环语句1、if-else 掌握 if-else 的语法格式 想一想：在使用if的时候，它只能做到满足条件时要做的事情。那万一需要在不满足条件的时候，做某些事，该怎么办呢？ 答：else 1.1、使用格式 12345678910if 条件: 满足条件时要做的事情1 满足条件时要做的事情2 满足条件时要做的事情3 ...(省略)...else: 不满足条件时要做的事情1 不满足条件时要做的事情2 不满足条件时要做的事情3 ...(省略)... demo 马上要过年了，又到了抢票的季节。 1234567chePiao = 1 # 用1代表有车票，0代表没有车票if chePiao == 1: print(&quot;有车票，可以上火车&quot;) print(&quot;终于可以坐着回家了，美滋滋~~~&quot;)else: print(&quot;没有车票，不能上车&quot;) print(&quot;可否上车补票啊，真是一票难求啊~~~~(&gt;_&lt;)~~~~&quot;) 1.2、练一练 要求：从键盘输入刀子的长度，如果刀子长度没有超过10cm，则允许上火车，否则不允许上火车 2、elif 想一想: if能完成当xxx时做事情 if-else能完成当xxx时做事情1，否则做事情2 如果有这样一种情况： 当xxx1时做事情1， 当xxx2时做事情2， 当xxx3时做事情3， 那该怎么实现呢？ 答: elif 2.1、elif的功能elif的使用格式如下 123456if xxx1: 事情1elif xxx2: 事情2elif xxx3: 事情3 说明: 当xxx1满足时，执行事情1，然后整个if结束 当xxx1不满足时，那么判断xxx2，如果xxx2满足，则执行事情2，然后整个if结束 当xxx1不满足时，xxx2也不满足，如果xxx3满足，则执行事情3，然后整个if结束 demo 123456789101112score = 77if score&gt;=90 and score&lt;=100: print(&#x27;本次考试，等级为A&#x27;)elif score&gt;=80 and score&lt;90: print(&#x27;本次考试，等级为B&#x27;)elif score&gt;=70 and score&lt;80: print(&#x27;本次考试，等级为C&#x27;)elif score&gt;=60 and score&lt;70: print(&#x27;本次考试，等级为D&#x27;)elif score&gt;=0 and score&lt;60: print(&#x27;本次考试，等级为E&#x27;) 2.2、注意点 可以和else一起使用 123456789if 性别为男性: 输出男性的特征 ...elif 性别为女性: 输出女性的特征 ...else: 第三种性别的特征 ... 说明: 当 “性别为男性” 满足时，执行 “输出男性的特征”的相关代码 当 “性别为男性” 不满足时，如果 “性别为女性”满足，则执行 “输出女性的特征”的相关代码 当 “性别为男性” 不满足，“性别为女性”也不满足，那么久默认执行else后面的代码，即 “第三种性别的特征”相关代码 elif必须和if一起使用，否则出错 3、if嵌套想一想： 坐火车或者地铁的实际情况是：先进行安检如果安检通过才会判断是否有车票，或者是先检查是否有车票之后才会进行安检，即实际的情况某个判断是再另外一个判断成立的基础上进行的，这样的情况该怎样解决呢？ 答： if嵌套 3.1、嵌套格式12345678910if 条件1: 满足条件1 做的事情1 满足条件1 做的事情2 ...(省略)... if 条件2: 满足条件2 做的事情1 满足条件2 做的事情2 ...(省略)... 说明 外层的if判断，也可以是if-else 内层的if判断，也可以是if-else 根据实际开发的情况，进行选择 3.2、嵌套应用demo 1234567891011121314chePiao = 1 # 用1代表有车票，0代表没有车票daoLenght = 9 # 刀子的长度，单位为cmif chePiao == 1: print(&quot;有车票，可以进站&quot;) if daoLenght &lt; 10: print(&quot;通过安检&quot;) print(&quot;终于可以坐着回家了，美滋滋~~~&quot;) else: print(&quot;没有通过安检&quot;) print(&quot;刀子的长度超过规定，等待警察处理...&quot;)else: print(&quot;没有车票，不能进站&quot;) print(&quot;不要方，真是一票难求啊~~~~(&gt;_&lt;)~~~~&quot;) 结果1：chePiao = 1;daoLenght = 9 123有车票，可以进站通过安检终于可以回家了，美滋滋~~~ 结果2：chePiao = 1;daoLenght = 20 123有车票，可以进站没有通过安检刀子的长度超过规定，等待警察处理... 结果3：chePiao = 0;daoLenght = 9 12没有车票，不能进站一票难求啊~~~~(&gt;_&lt;)~~~~ 结果4：chePiao = 0;daoLenght = 20 12没有车票，不能进站一票难求啊~~~~(&gt;_&lt;)~~~~ 想一想:为什么结果3和结果4相同？？？ 3.3 、练一练 情节描述：上公交车，并且可以有座位坐下 要求：输入公交卡当前的余额，只要超过2元，就可以上公交车；如果空座位的数量大于0，就可以坐下 4、猜拳游戏 应用，根据if语句相关知识，完善猜拳游戏 优化参考代码 优化以下代码，解决只能玩一次的问题 123456789101112131415161718import randomplayer = input(&#x27;请输入：剪刀(0) 石头(1) 布(2):&#x27;)player = int(player)computer = random.randint(0,2)# 用来进行测试# 感谢关注A2Data#print(&#x27;player=%d,computer=%d&#x27;,(player,computer))if ((player == 0) and (computer == 2)) or ((player ==1) and (computer == 0)) or ((player == 2) and (computer == 1)): print(&#x27;获胜，哈哈，你太厉害了&#x27;)elif player == computer: print(&#x27;平局，要不再来一局&#x27;)else: print(&#x27;输了，不要走，洗洗手接着来，决战到天亮&#x27;) 5、循环语句 生活中的循环应用场景： 跑道、风扇、空调左右上下摆风、地铁日常运行等 开发中的循环场景。 某天，你惹你女朋友生气了， 需要跟她诚恳地道歉。 1234print(&quot;亲爱的，我错了&quot;)print(&quot;亲爱的，我错了&quot;)print(&quot;亲爱的，我错了&quot;)...(还有99997遍)... 使用循环语句呢？ 一句话搞定 1234i = 0while i&lt;10000: print(&quot;亲爱的，我错了&quot;) i+=1 # i+=1 同等于 i= i+1 使用场景： 一般情况下，需要多次重复执行的代码，都可以用循环的方式来完成 循环不是必须要使用的，但是为了提高代码的重复使用率，所以有经验的开发者都会采用循环 6、while循环格式 12345while 条件: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... demo 12345i = 0while i&lt;5: print(&quot;当前是第%d次执行循环&quot;%(i+1)) print(&quot;i=%d&quot;%i) i+=1 结果 12345678910当前是第1次执行循环i&#x3D;0当前是第2次执行循环i&#x3D;1当前是第3次执行循环i&#x3D;2当前是第4次执行循环i&#x3D;3当前是第5次执行循环i&#x3D;4 7、while循环应用7.1、计算1~100累积和 注意：包含 1 和 100 123456789# A2Data提供参考代码i = 1sum = 0while i&lt;=100: sum = sum + i i += 1print(&quot;1~100的累积和为:%d&quot;%sum) 7.2 、计算1~100偶数累积和 注意： 同样包含1 和 100 123456789# 欢迎关注A2Data 转发在看求支持哦i = 1sum = 0while i&lt;=100: if i%2 == 0: sum = sum + i i+=1print(&quot;1~100的累积和为:%d&quot;%sum) 8、break和continue8.1、break8.1.1、for循环 for循环场景下的使用案例。 具体差别，自己动手输出看。 正常for循环 12345name = &#x27;a2data&#x27;for x in name: print(&#x27;----&#x27;) print(x) 带有break 1234567name = &#x27;a2data&#x27;for x in name: print(&#x27;----&#x27;) if x == &#x27;d&#x27;: break print(x) 8.1.2、while循环 普通循环如下 123456i = 0while i&lt;10: i = i+1 print(&#x27;----&#x27;) print(i) 带有‘break’循环 12345678i = 0while i&lt;10: i = i+1 print(&#x27;----&#x27;) if i==5: break print(i) break的作用：用来结束整个循环 8.2、continue8.2.1、for循环1234567name = &#x27;a2data&#x27;for x in name: print(&#x27;----&#x27;) if x == &#x27;d&#x27;: continue print(x) 8.2.2、while循环12345678i = 0while i&lt;10: i = i+1 print(&#x27;----&#x27;) if i==5: continue print(i) 总结: continue的作用：用来结束本次循环，紧接着执行下一次的循环 8.2.3、注意点 break/continue只能用在循环中，除此以外不能单独使用 break/continue在嵌套循环中，只对最近的一层循环起作用 9、while循环嵌套9.1while嵌套格式123456789101112while 条件1: 条件1满足时，做的事情1 条件1满足时，做的事情2 条件1满足时，做的事情3 ...(省略)... while 条件2: 条件2满足时，做的事情1 条件2满足时，做的事情2 条件2满足时，做的事情3 ...(省略)... 9.2、练习打印如下图形12345** ** * ** * * ** * * * * 参考代码 12345678910i = 1while i&lt;=5: j = 1 while j&lt;=i: print(&quot;* &quot;,end=&#x27;&#x27;) j+=1 print(&quot;\\n&quot;) i+=1 9.3、打印：九九乘法表 10、for循环 掌握 for 循环的语法格式 掌握 for-else 的执行过程 像while循环一样，for可以完成循环的功能。 在Python中 for循环可以遍历任何序列的项目， 如一个列表或者一个字符串等。 请跟着操作如下demo！ demo0 1234name = &#x27;a2data&#x27;for x in name: print(x) demo1 12345678name = &#x27;hello1&#x27; # 皮一下很开心for x in name: print(x) if x==&#x27;l&#x27;: break #退出for循环else: print(&quot;==for循环过程中，如果没有break则执行==&quot;) demo2 12345678name = &#x27;hello&#x27;for x in name: print(x) #if x==&#x27;l&#x27;: # break #退出for循环else: print(&quot;==for循环过程中，如果没有break则执行==&quot;) 11、总结与练习 11.1、必做题：使用if，编写程序，实现以下功能 从键盘获取用户名、密码 如果用户名和密码都正确（预先设定一个用户名和密码），那么就显示“欢迎进入xxx的世界”，否则提示密码或者用户名错误 使用while，完成以下图形的输出 123456789** ** * ** * * ** * * * ** * * ** * ** ** 11.2、选做题：根据以下信息提示，计算出每月乘坐地铁支出的总费用 提示信息（票价）： 地铁6公里(含)内3元，公交车10公里(含)内2元，使用市政交通一卡通刷卡乘公交车普通卡5折，学生卡2.5折。 一、城市公共电汽车价格调整为：10公里(含)内2元，10公里以上部分，每增加1元可乘坐5公里。使用市政交通一卡通刷卡乘坐城市公共电汽车，市域内路段给予普通卡5折，学生卡2.5折优惠;市域外路段维持现行折扣优惠不变。享受公交政策的郊区客运价格，由各区、县政府按照城市公共电汽车价格制定。 二、轨道交通价格调整为：6公里(含)内3元;6公里至12公里(含)4元;12公里至22公里(含)5元;22公里至32公里(含)6元;32公里以上部分，每增加1元可乘坐20公里。使用市政交通一卡通刷卡乘坐轨道交通，每自然月内每张卡支出累计满100元以后的乘次，价格给予8折优惠;满150元以后的乘次，价格给予5折优惠;支出累计达到400元以后的乘次，不再享受打折优惠。 要求 假设每个月，你都需要上20天班，每次上班需要来回1次，即每天需要乘坐2次同样路线的地铁；每月月初第一次刷公交卡时，扣款5元；编写程序，请计算出你每月乘坐地铁需要的总费用","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Python第一天作业答案","slug":"Python/Python速成/Python第一天作业答案","date":"2019-12-08T13:04:54.000Z","updated":"2020-09-11T08:01:01.045Z","comments":true,"path":"posts/5010.html","link":"","permalink":"http://www.a2data.cn/posts/5010.html","excerpt":"有东西被加密了, 请输入密码查看.","text":"您好, 这里需要密码.如若不知,请联系小编。3a0b0ebb43c4620dd0164696d76712adda08d924b0619ffca817202e677196d0457eac00861ee754233ca19bb41dadb3eaac2ccbdb2cafeca743a5ea8aa4216f39cf117817137b6781dd72300c7102779da7a4f7c1b37b023a99516a78124280838929c8c7a66fc61426a8263e7d3b59bc50cbcf967d25d5638c014cf437db66f50dd427efc35410e5d24606a045bb977b98be157f2430ab9c5437cddd44ff9116cf71560b7df9c4617959db03165b1d969487a9eb3348b76a1194b9effd9b9ff5a3a6cde78a0512c946463119cc407de7accca511f16ff0f8c09b4b35461126ec7b335fc04e51e6e5512b26b319d92927790557954073f8c3b092365f5180ff0545c87a62c6d35965f239363aa8fcc0df0c92c816e0d2793303b6f3339772130b30c2a79808361d06a26952cbb6825e98d7ff72c0758e84f2dd7fe32fa5e087a1b90126f7d37ce25430773edbcb693cb5dd87933f230ac9dfb4d502db9d544802f7bf092f11f5531537e1639275bc58fdf0ba4462ef673573caa9f7ed715941c550aafadce54407e94a2e054b1d605ded646d231cff331a51a8a6029d9c1972181ae0659b0b77f0e9ddae813fa4812b6b91b407beeb537324c20197616ea4043cf4eaa92406f1d086b85748b77e705628bcda690d9c4811ebc38e63902eabb2f50de36c0a3689273d5b679b6343abdfc9241c7e6f2619adfc13b22723d3f1d0cf40a91a358d2f0544fac19b9f5d286fa232d6abc4920947b049dbeebc7729e392651197a2ac8eda9d85a134e4044482e09dd822986fdf7ee477550b779ea87f5e1b14d842d128e6dbf1e426f8af63c0c19220a25369c0e0c26d2807c23bfa41a64829601f9aa3a21973dd8439b0a76cc3d28073deb221fa4d25bddf734631edc455ac10baccfbeb6cbb0febea8449a7678d508f0db96c024bbbd059525e15f20b81d2980b01009e70415e98821bf4a7a561c1bf4380488e5bfebc8ec7e04c591650ed87742550724687ba070b650dd5082bcaeb5b3f8e9f55d1ecc3769e42965a428c35c2d0a07e85adac205bb14dd33df421630cc66a1cb82e82b7550bfa9c5994fb52ce23ee590e2c82b92cb947d9d6229c90f39210e10737c28542b5d2d9754dd05910d8998fe8955e1d4d5fb4ac93d5d257022b5cfcebb44999ccbc21904d00084065687f7356204ebf76f2513881dc157942ae4f71f855b6fff355a2454dd429d39f3ff980f009b108d36cf80403f6fb52d8507fbf88348ae3f53ce7de608a3f7d5bd4c955c24eb537d770659e39b5d5abc9417b7585e5e48ca954ef13bca83de97bad380794bd6af5a619573a92bd73d902ea7bf8039cff000a84c1fb40e9a7ee7970e5beb5257e075061e56e51191596672ca497ba655f821969321c264841708e6e6e79316852f14a6371d479ad527842b9d6f8c79b35026ea99cb4b54fc3f45c812e8d13f3c4c3ad90a7198e67a1499b2dbfe302b297560f9d0a91b48bda0b88132361c2a6ddaaffbce6da321ffaae351beaf75c3dca01c6fc14776f57f56e789dae999ec203b56fccfc03457d5446203eb37cac3c7fbd10ca5f14cd8f8897f7bb31b0f22088a65d9822dc7ae140ae1e22dee3ad8a47e92d66f885f0e73811dd3ce98251f6f3b618627f58bdfbc50676f301b7d94832769febd1b5e3a39b7e4fef4518d0e4f498c97e8116ded4805636355475c115a93fd5c2bd54d6c519dd6e1b20f2aa1a9d1d44c7b86e48c07c8c7904611eb730c99f41d670ec1b057e3d5e620049e7764f25c961448212b9e03e41f4e2f84308b8ef75bb6712e86ffa30e5f557bb963178931e7f4fbfca1c7b4010fc5234472c7fbbc93fd9d6a330b021ffab2e3a0ac2039ae5f22ea9f3dc37cd782b49a2184593dcdcdbf4778a7241548495cbac811afe6ec5dd4ac4e12424aaa1b850757c250ef1fbe3a2c565674e1b95715b4e97670dd393004ca3a25e52fa4904aaeb2d3ef9718b5a6b1918c54fc683985c440bde9f00279671938a4b8bafd8baffdd54137d84d8e2ac819bab1132d6ac80a75d947383a26396defd30d192895553be49ca07342f93cb6b4ce0afe34cf4da952177175ea1bcd1116e9128caee900cd26bca7c17f38dd835c1b95e222438c829a43fe4b11a568c7cc000fc690c225adbaf3a22a0053443aa1e8ffd146f95f541390b57b7b3061921a791bd385ea9f7d157ec7ca37326122e7beca3cd291a2b9f8aeed442bf3a977429d9366fd7a7c22a97d3785058eb4b4f6ad77e6dc0e70585ef5bd163425893f1fced3940684c99999640f9576043d9f8bf5653291b90c849d661744874b4d50d33be4066a3a7fe86591d548512fd4b84792a9a6301850aa09e9ffff9a965472c9a461ec882de5985a7be6f8180f0b262b2d4cb22ff8f14e4c7af93e4562d00aa7e94a4e7f31a8e242abbc2305bb0fae4115f92bf3b4b8a92841f3198dbf746d46d6550403978e1d82f8435608322d24f736f11b166b84e7d2d2f90ea13c891ab7b8ccff46ace1a6fb5c1ae564295c51b9dd92782a1cd2d948bb6838d34314990c1fd09a053cfde2ab8a7de5a941d5ad336e2c0fcf12352bf2b711b869f68837702180b8246c83998da27c193b4c4dc9731b92ecd8866001b02a87dfb84fa338a4283975dce49c1e8cd0880faf4dd078572d3db2c88b8ea6bc73b228fc8f7aaa3ebcd4cee80f3769b0d9c90557dcd389d0247b9e3ad1a6441aaaf91e1c85af14f08838ca7762a21acf1b4ea631c3789b864ea78f4bbe4feaaeec493434a430fbc2fe9a22489ecf6a7bb0df9007cc0eb991b9e9264a27de8b8c244bd9b1b87ce6d53fd1ebe93137a34b6acca7608ae46c6d55ba2a9ff1a2df95f9a68b3e13ba3e8e49b1f2005c2f52781da84821a70fbc85af8b0ae26d3e4adae58844ae6ff36adf47edc5c3d7763312467b10fedf23e74f5721337840b964994d0a78efc4ba711bda7abfe4d7e2a97158b51eb883190effdc12d3599681a11d85dc7440d955c668cb191bcb28a6c213a2236e47b0fecf5c49d6deda5338accee2a01e0b2c2e56d825b1b6f3ddf3f0b62f84cbf5cdfaae7483d51b32d2d35850dc1c6aaf2587086633b599ffaa5b817e74448b3d3be10b2114da148b0b1d35022c1108d07a578383f927adc70333dbb042941a6fe454d16bcbb70019e16b2f8c4be53b5898d43714c75e8ddd2fc125ee99fe527ac29b359395d79469f0f44b85ae840723dfb4385e62ff677eab0311a6357f564bdeea5fc0048d4f30afc10cbdc23ca2d384f4d04e0c3e0033afa6e7ea9287fe0d63a1c8f3ab61a82055a43d085a4b2548b8b2131fba7482a35fa50ac3eb93c2da2acd536d5b2fe2e1054a8d9fda0414ab00942dae34de327fc32f0d2dd5f019c0497e61a08988781ff73ca832e99e2998b07740c4858464566bf1124615b2b297d844404b0924f864c53f9117bd0e1ea4eaf5e5745daff0f5b93e0d735014348187380d21c6eb29a56f83a53e1cb6644c602978d14072e0e63da28a709e328812ec38974fca1144b171aef7a94cdd31b311173ad4f3fdbf441183a5556774bfe0e65e148a2b107564f1b0673bb9ec70903605d49658a0f647d5540c888a2c2db433a342bbea1fd1603f89c1244a59c6c7042f7bfcc004d2261ef355007f04879de0b8e8aa6bce3e696e1cc0fedcbaff2d3927137d7f932515b442973b64aa1e7ff1f5ed72abfbc6e3cfe0ce470a2a368c1b43e76d4f78ddad7dcf7d83d057e907c13fc5cc463c7abd697833772a5129ae38a1d54cc5f8042f20972d5aa2325c6c168862fd47bb839b41de7ba7b91a168e2aff8cc40bb66e38f7f8f6e0c277626a752cbb4f017607bc532419583be0594007ff8898fe6e924f85980b0b0a6f06b971ab6c6f3c2ec7c8cbd489ec3ae4941ce50d5e39550551427d72936535e3df133770fe10443454b1a544ab9c4921c576eb1bc4f92f5c699a80fb63864acba6d2d2914d1b028bc269e6e0cc3e8ab46f2d62bdb9ffa532e0626fba1b08360155135ab289aeb5edef40691b517673b3f210250f229b1a0873b4ecfcf859d282d4f3f73334a27faedaecc0a409dacce0972690f31d14d5bd59c66061833740282eb72c133be26f5c2964b2a88f989c95883f7ce9188b737fdbb27dc0ff390c544bbd279a2def775698d9958e5d2d251928b6fbf4736a0c5dc1828f85cee89c11508b8f9df544abace7d1893309d75198297f0fe2ff16763fb282ad4e671ad9ff20960848320e74ab379c8adbfa3ac587c2f6c39465ecc7ec8d2e7e145a628a69efdf8318a085162a6c6aaebeb5e79a7cad62040ae1d72ab338131087fb64bf9cc46d96128d3d4149710a5fe37cc5e2feba4f00e0818e97ed617e413486ba9d71750c47264a51c6b72faed7a9016aa7d110ec8f597244a5c71380630ab9916baf3605ddfda758aba570b19b8565df500f1751f64d8b637d0b2e2f3aa1872c290ede4e1775efdb4226a294a7415c6536c588bf5f954b4d35d9eb4f72c1e6ea7ecd095b58cf9a1890cacfbb6ebb0dc19d3f4be384dd8b8ccec2e614af9466b5fca0983b0d70c4dce65e991f89c2931755368471d709c8580e3d03e04dc6c5f4ad708cf2cdb74fea5ac4112ea25203fe6627ffe87a900be9d2612353b56fc922f2ea99d42b28def6f4091cd2ade09bdf33889e200eebadc5f75a5d0f647ef6b27a3b998dc562a9a0f76187c21d0bd1bffa1745533cf8e33f15718775a8002212588322abddc1d464d1c1297d89c92941848e757dd34184e8de4e572b4079348c27944d302ef149b340801f473e83f1fcd63c3c3e0edd7dc985a9e5b3d098ca499c7fbf279f16a3ba3ca5a0e7550caf64e667301fee0aecdeca122c8d779331229ca126b381f18db0b3187ee3071528c5e6fa8e8959ec9ea280f42eb8de3dd4176f2f75eecb1944f4c1d0434b6ee0e05b0bde6fbeb162719106981f0b8488fde6d700279dfac883b3d97630b77a6b9a155d2664d1edb75cb1d384360b254ebae6b09cbb40f4b1f06c2e63ad96ba5da895f4863eee561f7b60579dbc90af38e6e4a67f223f841d35dc8931bfa3c0357c9435b3a6830a089860742ede586fb3115b3b1545d4c43a33f7a2bea11feb5c67d477cbdf0e1069d463ddffade430bc260d3f7b898e85b6b30db3141e2c354a9d413ae7a11809df0d5d0e2ea2362be862b3137d80f31e97d2a8c0ca4c03424751ca155a1b413ca7f9abcf75e4e024b29c762320d1205403d6cba549ed162cf7b9f2f9847bd13693ce638d6deceea09a4bee135ca28e700441d9237ac4586a996f4d99677885a3ff2bc50e9bca859d1320edefbe3792c51b02a6f54337e97de2e12ee311dd63a124c8718faab96e870e94283032095c8e7885ec381086aebd062d31ad2a29b6014ff60a1b7e02664c66a67b0ca976e0ddcc30908698078d3be94e206a0c575fdfbd87d52c4919c98f9d9feec67ba14d430a5837a61ced5071a33ed523a489caf1b3ee7787127d91d3d9ec0ee44af1d79d64b56bed0dc37cc5ff987c446b468e3ccb905ee73065dec0df89501fbf2c046001cea989bef77275557f266743189be5b0fd980f88e3cc599e5b11dcb41cf93428f0940134cf0433bdc44c8daf2ae6c5ea40d5be3fd181a1e61b48e69d07e9777613d465046fe10d950435542ecfc6e3f93de9d7eed04141d5b4bcb14dcf468fe232a85f622b85844bb3f6633ef03fa9e9685ddfe8c725dd40bc57a1bd96891f8fa61317ba0ba89b7a195c092c7ff557db7abf89f75c28a279a2f532ea4d9489ad3ca3d0d85cc9cad7a0c92d9c82472f31d73c02a7a035d97bdc1f4152c597c51fa7c588760fcba6af0cb01eccb68dd0bcd3ed694c131e66c066432005472d90daea46ce7a0faae3cebf562607662d47bcb1d5acbb732ec80c2eb729cc47926c2fe67d6471472182ffa3a776e66105a4c9372839765d694e928ae81addff7dae2ae8ca26bd12a5d21129816257fa21405f0acbd9c3ae805a814291f0f99b87ea57a4f7660dd2a91ed6a998a6e41a1cb84a811922bd782fe4cadfd307362dbff73b48b980830ea94c95d593b366495f8d3cc2a3b70f8f2ad2f452577e7793f8c58382d48d61e8e1aac73235895a82da6cd8b1181dfb38ea2e7d6e61df0b9038f9278d8bb6a3d3fd5c941a234b9655249ab93cfe2ee9165dc22e8c96ef54086d2ed99f97642a32ae00b0adde901843ef9267ce48121b5466d230b5bdd4977c5409bc5e49db2e8b4073afaa77658f15e91ac41fc6a29a271fd6bfe1dc867ad7cb51e00140c0c3fe624dc2185f16ab9c71b9d81cc82d1772e43517d43ec975d21d0502484018366cfccb9a7fa41669dc0b2159f1d08df822e5c4c562b63de3b30f0373ac6a39503fe4566767d04238101d1480a329c8f3cf522233606882e1c920c96e36ea0082cd20640b321da40df75ba267feea7f7134815ace83544e8ca444f8b8e007efa1583580f9cb5474d29e239ed9a827e9415fde01d11b907e2cafdbd7cbc01ffcb513b4ad6aa0081fa075ad0ee4d31f2360c1bf947054d61b439e07130972420ac0e6f813dfeece6f27b7eab233d47b327a384705d0e1b58883fb10bc5488d7b56df52fe3d3145eea1f95a4acf5f9b90543a8704b24e98590499b33599792a66f944c1ba5e6a9c6e5d45115336f447ab7d833f79c003c0d83226655bd2575b407ebff0a1a98230ebb8f65ee291cdc3d896be698aa23fa25c4a148b539e5fe6205c579069999dec58d707fafd210fa0a8b07828f5c352d780eb1620c2ce0cee49e56ed99b881ce0ef361bd967a1190a95c298ce0891a7014c631d82d5df3213bddb5511750a502ddb5b82a25f79e4c66a0396b2ef3cb7067fab481f96bf68c37e9fc154608cea98dfd6779e78ee5be5b5d998d2bedd695fcf06251caddc51af6720c65d04d5c7ddea35824b10c0629ff9021b571e542be6a18285a7148e47d15f68b045b3865c767848425680a8ec2493496187c4e4c7be1e6bdd74d8dcf7a7d188531530d976a3e8f25d1ca47bd38bdeb2c5f6eeb47358de29fc29bb588984f542e979c274494d251d4dd5c37c4572aa3fd827f50914aa837268592411b94545a1576a4555a9e777fd1af6b193d8fedf68e6ca8fa9558678c5f38fcaa520c4385c095a38a4dcbf2fe113bdeaa1ef19bcf4813e674a2a1fc9f24bf4427ac8c70872f48d82ddae4a207be13470326bf70daffcf1c9187d37895bc1cf9f454e0ec9b68b57f12952f6ff5429a5fbc985ccc3ee70f2eced3f0709adb94aa2cfee2678c81beb072f961dc189cc5691448bd492e49119961daec1d6944230b53490589bb10df064687a362bcc61c38f503b5ce2bd98cbbcbcadd59af9bec90b550be662e6c2e003181937194a2dc9f021524886fefd01a7d7ff9e62c3a336fa9458d5eb789b5e028887c7d94be92162f1409b4e8bd83e273b4341e7c463c0e222bb42c4d0452f1061f18872e020b47f111db02ad1c5bb9d50d9123e49e0bc114abb91fff5bb9835d41208c72562f7bd540f725def987540f7a00f0be52b8e886b42cf125c1184e914d902c00514c3453a2afcf6a818f3a2d3f9492bcd324f32f4f57489bc6f856226ac97b2392ce5a5c6197cba7ef4eb817440a04face91b13063f7ffbde40bee28ec87604107bd27e79d085de74de4d5b2fddc5819b336c33bdcb256e24606f42cde540114f1c2de3a7ec77b6d0ee375d0e2a784bd210c3ccb409bb4455f4cd87cc306df6024de74e9b9886c3871bf71fc1ff14f7680ef84f673a997fd1184f69ad853c3abb6fc39d292ef746f4653f5c67261d8e0bf771e9c773fde024e341851c7d7dcacb5891010236b98ea9bdfb4dc34fec0f4a02949ec5569f15cb921e2c6887886b1d687bf539235825c73fe38e5660d8e8c805e911b7afb7447e0a5d31e83be98a547e51a42e13bb973e205cd3612883888bb3051d64161a92ccf71fca89bfc3a3da0d3a019e08f524a3bf4b941d10c39a760c63e4ac5a12f953826cef59339be384893a8edc06b8ba4393ea1863bf091ad8703878557d5c8a113bdf9f940c3d4cf0ea6078ce1df4689ec711f000e01239a12d7ef8b074b53050684d9f2d6ef4a5ae14cc941c9c4ebbedc1ef25bf8c09c9cfc6990a78c471aa8690da96fb42d46266a3f9f8738f95731d97d37b380c1973f044ea440a37bcc252bcc85dded6a5578dcf4b1800163107844f575cc52d4533b36a92fd678af86c970289ade4f9be0a7be5783366113245a223506c4dc4dba0fd25b26f9129d7ebeec5a63edaf31ec7218643639f3326cf34403b42d751851b4ea029498333437ad1a32e5fc5004a916780d3d0689bce8c1d530a0a187809218e31b1f0defe2fad99c8f2759aae46d72cbead78baf698db64ffa87aca6d4e151f3a431245eafb2096bf6788014bdba87e2d496c606c94434fb3648304301c6d87858576024a0c87f8ccd06a3d761b10baa7b91ce787803db5fce889047b33b3a8b862960d78d45f79420385ac69b8602f54d8ca9723896155980585588a422b0ad751d676c54ca103f50205148e49ec4ddadbbaa87a85440240cdd9f77780176418b81f9c6b3965b7ae977049549c0da5fb2332ec12c30b776b1b2795e9e5ac16f671cac023a16ed17987508024819db53aa967973611b74986c445230ede073d2361fb1dc5d939ff910da83b4a9c4e1033c3f5293dbff599067df5b93c105f8ee8cef99a9dd7742854718dc500eb6a28001040230c68f71ba07771cf9c7bb032b25ae578d045d737a924447176d3e5a6959ae165b1c2936205d2a4c88a6af61f3ada3302e3e0ba6a3cc193314941e48dec9dd17cc7b92dd10db5c333d027e31057453f465b570eb38bc05205a66d6145c90da2635651a15254a69057aea51fa94171cba7cc408a1548b97a8d906e3ecb2cd43b84045914107261ecc2c15d5ac27736dce49ff91ad289e3e16f811fac7fbe8864ef9ad8b180e156e7499c268ea3b75c192d65040d3b874fca3c593dbd290a6230b7d606db517b0388e2c46e9e8261444b0e4e919c3e26da62f99732cf3d5202ff69d7884f35cffb30fdf6859d825e36cc329ff46e9aeb6a1033373ace8331d791024aac389b2890fd3458b3fdb1c145e0c91c94cb1bf9adc60bee0c28cdbb7444945260de70accdcd60df76d227c769664dc52ee106c1da4b8d9b29159d81ab9ad9b56d11ad73b87cda34dc54ca2de3b7067d77b67cabfc84e47597cfa4c14ed4158879d856fbb61c9976444ac72339f6106b1f5f9a680d34595bd4f5312684c372d2dd63bd05178483e493d0ddaf18da4346bb02a19af11ffbe861fc1bffd704e0c64ccc7c4defb06450f035846f17351db1f4bb91da52ce9e0620809d2dd2a98b8ec69b88907818487f376b7422d7c6236186219ff4f6be546342b4966b7b4e1a3a9bc902c49634ddcf625146da59f8abf87077f193503f9bbc71c628825b7b471f0eaf8ceeecd24e24ec2fb2605573c1be7d426cc329975f3c05bdb2211c89d51f12a320699d2f83163de61c909845c828b9abdd0491ead243e5b02f4584591af306f308efe6e794ab3c4ea71c4c229d5bb8697a2e113ea8a12d3f7de38c4ea1bdb998ed4d9e5d85a54ac19c923686f857f82bcb640506469fea6e224415ba3b0996df035b26e3ce4d1479e7bb39c843956bd53bd4f432b9c12f6e0031d09b8985f5de0bb19c88c3a7265b3b4dfe5e30ceabece9526e2053927b579e78d4ccaaaf6775516b0ad67a813e5a063b3cc4b6123fa63d0e188de14c8c50ccd7e041c5ae84114ed81e11e355090800519850478e4ce163ce5596750135979e2393f83711a061eb8a4d921d38cc6fe46fad3c19122b717026cfce3b2f084f181f5d25512bcdca3ebebb5baf40105579d413da4f8c87aa2d99a1579c3b80ee396a1de17184a1f43fc9f80fe181fd734dc9dfcf3e30131e59c77001c678f17a57d2a8dd85dae1db9fc4d8ab2e1b81cc4b57036332b6c84ca698b84b1718166c1f8b9795e0557a856456ea075f043b99472f8a7ff5a8ef7c1691826699c632183153a940cdb9614d9538103a93a6b4ba36b893ceb5d29d28b53bfdfa9b26c4ccda5c0c3455aed43413eeb39b1a49c7930e72f64618c334f629cc29e4a1f1ad9554f65f786ccae55724055cd49af9f1a874a875b036cddbded4b38962b46d9edcd7a53931ac7e6f8e65145b695487ef416e4f320854d1bb897684ac138a94224cd334c8ec7f88e9fab1b4fb525ef06afccebebcd22d329b46c9ec461503a3b96b1daf50a6cbd106e61fb9c71a9d5501d7212b39e390300b17097b8e004b6c3cef6cf5fed5d5ff22bbd8bef835bf779ec33a73b53308d75ec83ca71e544a3523d09d061d459c01e72efdfd2e1a494d775f568e7b197035e3512a0b974291f91277f4603fd4b7f782a3d926c634e0dd2384630aad41bbf4df9a0156c0d7d1b8066d58db4a6f152423d509fec65bfd9085208671c3127447d99e224460a776229369071f82c901e75cb99d4468914fd24de8f88265bbff2fe26575fadc8a51854db1ab13abac07741fd27b13a55a27dc1e5e3b1cb1cac6a0c0886d62d2b4fdf4d1f873812a9f3799afd17c0d9fe03c07e7112eecdff85d517b1211cc9317f4caf9741d0e7842cdd25cf276a8b65b4caff164f85f873641a698c299a315a95ecbe072fc10e452c0fc7d53c6f7521590ec087e2060e04f988cbb8c63c6a2e1b4dd0abaf1dbcc7531b334553140c2ade47bc939271da89360bd7e1a6fbcfc6d6b95b673e7bc388436f1916b746a792b90f919ad8d513b63a734aac68e6a96f6a8c2bba0616b26612a308ba936f4511389f862aef2fdb7ea537ef9eb0d08374134414c04483ed2886eeff55bcd779d5a7c6aaf11854e7c3ed83d7b0638da34aa4d0a83cdafaf413e8bb5c763fe65c997d4c0493970cf3844ba97b1cd0a80a30984ee21a30931ace10d8811b2892a53030ce9f500c3b792b37d605926c5aad88b2567abfe9aef058ece38743e82daf1ba9e22c6fe5ee67d4b9cfaeb3343ecc32a110509dd871979a0651a77273c897c4386cc11fac985b90badce72a13c4cea1bea37d0b76a36aa649a7a1b725860db3f2363e26e3b06de35e4e0657a726bc86a98d314eaceb3179e109e9fe7432d70734bfe62053dee36b79a554846b2776077b409699ebd7f21869c6262e9c0b3b007064dbcd36b8c96d35af8e9b82081745b7adc35a26954dbd47c014c5fea7c08ff354a89baed057840ab484e564435fcae6712670f0303af01b062ec3f8d3cf5af1b2bea399e82602a107fba5aeb063047e025f40908ec7ac780c055ddecbf71873bc65ecdac75823537a1f414118044923485aaac2048b05001155f58cac6c5e8b0260a40c0ad3ea01ab84e549207f79ada7ed5fb8215008985b9ac856e535b1804ee4095f8bd2921c5243908f1610f58edf761c23daf87d2d43f19f8c16da9ea9b226819322c079855c701fb20bf2f2bf9909b9574bc0addd7efbe48cd7b091a084805fcdd67c07bf767b267cd591fd3c1d632c665d4213c441d37a4a079123892a0c514a5d8ed33fd108ba451d8bcd7056469ccf7a49d0d7b904673f0a9487b171f04aa9e3d65341e152582db6014071c9c564a35d4e50ceedf8458c0d7227b076f0e269d7579fbeb47dfe744e77d812e919e7f81672ee3efb75165a760a61e58d0ca982360bb2347ec76ca054ebddc1dc6a2437a4513cb6c24c0665bea120d73c3267aa45e6065162e40f4cee4f2352c6c1c44fcd11cac4ff18d7f946ea5713485b8fe6dd96209707e2af4689ec832cbe367d4480a2b26cca290ff0ad4ed8140ab6bb26ca9fba6a040a0e1780560443ded10fd42ee9e1e7ea6dd10076c9fa4410dab3a298b9fef61b00abd2fb946a2d48984eb885030bdb809b3fd4d74485405d79fa025ea2143d92134e5946b77cfe9387d88fee21f0baa7012588f104eb0685f293b7299b548d7250de587c6e06e673e70f48664f96d8fb13d9a73ca77c2d5acfbaa7282950d2a0d86d70b2780e2f673f6d24d66d36ca19a019ca45a60e246454309d8dd8f15be160651a97209f348912cb3be6daba234c1a06dcee6e08d3806a7c8e4b1af74a334012558d917ba902dfc88fc99cbecfde190f2888b10031ba1ce9c8d76f8d6b9594c058e03255ffa841e0de7a972455a6b19f0b8bc7d04a2a554958ed822b4690fe880a549072f00a42ca718dc855b610c73bcf8e7b226d3f00fdb9fc4f180abc3f012af8d0714dda755b42eb4b97dbb96a01bff7b2fad0e9d9e96e3d266d654cb2208f6eb6611b16d15718e427c4fb44c3fd6032f40b67151a7935b56326a3cd3e9d45c1638108e6f9bef9918552fb2313006286754c7a7f2e4092dee9201f3beb46b37be95252b8112d209bd8040f44da78c8d0776c8c9cfbd456a0d9ad67af411696bb5b210de7dbdbe3e80ad90ac95988c54e9f68fd5135b0093a96fb4ae84ecd5c5d12068942af23818be03c3e3a20764024d7b49b417c0d442380bb825ada1a9d3985e0e9f0a8420f0e04257237c76fddcfa3f853d4c62ceb014637954a237b903021b4120cc870119cb459b3321ffa0bc144330b76bebe26a01713e139c28710f0013780b2382d9d233af448322ce1f1d68fc976c6f818104af224f7300988ac13e511aa7917829bef9045b5ea3b57d2bc5b630d2fc786440503aeb7d90f9f8c3dec23bf2b85e0a63150c0b7bea42354aababb96a19ed51640f95a1ff1a40e03a0d66d44e179d3423966839862cbdfee3a1ece1a8131120c482c5aef042580bb4fcf06e59b9d3de710a7eeb912ad44fe58d437f7ab280cc1d4281e17a9032a4ed260244acc2019efc0d43a78d44e6a62f71b3a872e386a16e3e4b3943e0070df70dab6f66f5abbde9cb4bea2d4b361fb5553b6909de2bdc99299b40117aaef477e04442c01fcf2b4f274259b60762f6dca99023777ceeab6a4a47165dae03d7ea6fcad186d22a8c59995965acc4ccae323e24ef69bd2ef7b1521dd1a38974befa1f9dccdf3344512d3a4bbba3a2bec2e53902ece6e302731c4e4c3fc981fec21427b6030089d4efc12ca3fd2848c59c615d4cb5dcd34c70e46f0e9924bc344246f3894833528ab5ebb2b315949da0317900f302077e2edd1ca55dc722e696de5a8831b01d30a7fcd7ccc3277f0feab14f1a453dbac47b1a4cededd6ff38621d9945ab560821518b6d03d2872a42308b81ca07f34101d180357045e30171102bd802b001041ee0cac9723fd0300012166f86569d52945b91a36b2e3724490ebf44cb49d14b864e13a92c634cf4fef424c1825566aa45bee8e6404f5ef256232d020b9b62ee9f7945d5629d0a51b4eb8ef2850c4a99b33c5c647d33cbb80c7d7ce1420784dc262da28dba36bbea76e51e61f955b1eabfc06ccff8348e44f73de2164dbf89662006d941ffcb4baaa277f5549f03afeb5efad74bcbc1f4ebb8ac7c0673d607c9f44b7388706d43931e2e29c711a904f0d3e035c7386b752d98eeb2cc3d81a108eeedf463f6444360a55c0e91153ac5752fe13be532d1aad21dd5b55fc6bec9498c13f6968a0c30c34571b9ebab3741ea0cb3d4e7380e18be7b573618bcacdcaff9ef139ba84e61fd7c9048a4f0cf7143f7b049e2a165da6ede7e33010cdfff569d4f98c6bfaad7d5467e60f5e46942f206dd2cd1e82c4e0594c79ed03d3efa96010697ddfd18528ef9e70f87114cc1f33a46144126fd8d082a09ceae545f6aa3af68562339035fbb34a86a2c58f40270ef5fde717b7976a0e213087aef874a6438141b2626c2b6b27266a19bd38ce578d00bde4d806687f49f9b31a1a69fe1eca678edc9a691020a5dd0cc8170141c71ed4b6244d45eeffed71365d50b07b169b4767146605a9e5eae4c6ff5fa0c458958c3a0a8e79edc3b99b8803a2a523941785d311af173c96e5eecc349d78a84e762ff5e6791b05a56dc55c62c373a158a2ff043207d3d3dc311e3ba9c8a984c0a7d40e50bcb957621502b","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"Python习题","slug":"Python习题","permalink":"http://www.a2data.cn/tags/Python%E4%B9%A0%E9%A2%98/"}]},{"title":"1.Python基础知识","slug":"Python/Python速成/1、Python基础知识","date":"2019-12-05T14:43:54.000Z","updated":"2020-09-11T08:14:26.828Z","comments":true,"path":"posts/59977.html","link":"","permalink":"http://www.a2data.cn/posts/59977.html","excerpt":"Python的基础语法","text":"Python的基础语法 Python 为什么那么多培训机构？那么多的程序员呢？ 很简单啊。 因为 门槛低啊。 ==. 不信？来动手试试吧。 1、操作系统(科普一下)目标 了解操作系统及应用 操作系统接口示意图 那么没有安装操作系统的计算机, 那就是裸机 2、Python优缺点 时势造英雄 人生苦短，我用python Python可以做什么呢？ 3、Python的第一个程序 上篇已经说过一些，但是竟然有人问我如何创建！！ 此处以 jupyter 为例吧。 果真是炒鸡小白。 1、运行服务，进入web页面 2、进入你的工作目录 3、成功输出你的第一行代码 4、注释4.1、注释引入1、未使用注释 2、使用注释 3、注释的作用 通过用自己熟悉的语言，在程序中对某些代码进行标注说明，这就是注释的作用，能够大大增强程序的可读性 4.2、注释分类1、&lt;单行注释&gt;12# 我是注释，可以在里写一些功能说明之类的哦 print(&#x27;hello world&#x27;) 2、&lt;多行注释&gt; 3、&lt;注意&gt; 在python的语法规范中推荐使用的方式： （早期版本，不写的话，``print(‘努力赚钱的小风’) `就会报错哦） 1# -*- coding:utf-8 -*- 5、变量以及类型目标 掌握变量的定义和修改 了解变量有哪些类型和查看方式 5.1、&lt;变量的定义&gt; A：简单来讲就是，在程序中，我们需要对2个数据进行求和，那么该怎么做呢？ B：类比现实生活中，比如你去买早餐，一个鸡蛋，一个茄子包子等，你需要算你共花了多少钱。 所以，对于Python而言，存储一个数据，就需要一个变量 程序就是用来处理数据，而变量就是用来存储数据的。 *思考：我们应该让变量占用多大空间，保存什么样的数据？* 5.2、&lt;变量的类型&gt;生活中类型的例子(拿车来举例吧)： 挖掘机、轿车、跑车、公交车 （类型，大小，价格都不同） 程序中： 充分利用空间，有效管理内存 那么问题来了，如何知道一个变量的类型呢？ Python中，只要定义了变量，且它有数据，那么它的类型就确定了。不用去说明它的类型，系统会自动辨别。 type(变量名称)—- 查看变量类型 6、标示符和关键字6.1、标示符 开发人员在程序中自定义的一些符号和名称 标示符是自己定义的,如变量名 、函数名等 6.2、标示符的规则 标示符由字母、下划线和数字组成，且数字不能开头 找一找:（如下，哪些是对的，哪些是错的？） 12345678910111213141516171819fromNo12from#12my_Booleanmy-BooleanObj22ndObjmyInttest1Mike2jackMy_tExt_testtest!32haha(da)ttintjack_rosejack&amp;roseGUIG.U.Ia2data python中的标识符是区分大小写的 6.3、命名规则 见名知意 驼峰命名 下划线链接 6.4、关键字 python一些具有特殊功能的标示符，这就是所谓的关键字 关键字，是python已经使用的了，所以不允许开发者自己定义和关键字相同的名字的标示符 查看关键字 7、输出7.1、普通输出12# 打印提示print(&quot;hello world&quot;) 7.1、格式化输出7.1.1、格式化的目的12345print(&#x27;小风今年10岁&#x27;)print(&#x27;小风今年18岁&#x27;)print(&#x27;小风今年20岁&#x27;)# 思考，年龄多次使用，如何简化 -- 字符串可视化 7.1.2、格式化 7.1.3、换行输出12345#在输出的时候，如果有\\n那么，此时\\n后的内容会在另外一行显示print(&quot;1234567890-------&quot;) # 会在一行显示print(&quot;1234567890\\n-------&quot;) # 一行显示1234567890，另外一行显示------- 7.1.4、Python2-3输出区别 Python3 使用 print 必须要以小括号包裹打印内容，比如 print(&#39;hi&#39;) Python2 既可以使用带小括号的方式，也可以使用一个空格来分隔打印内容，比如 print &#39;hi&#39; 现在都是以python3为主 7.1.5、动手试试吧 编码完成一下名片的显示： 12345678==================================姓名: 努力赚钱的小风 QQ:xxxxxxx手机号:185xxxxxx公司地址:北京市xxxx==================================#思考，如何格式化输出？换行？ 8、输入 这里简单说一下，Python2中的输入是 raw_input()函数 而在Python3中只有input() 9、运算符 算术运算符 运算优先级 赋值运算符 复合赋值运算符 9.1、算术运算符下面以a=10 ,b=20为例进行计算 运算符 描述 实例 + 加 两个对象相加 a + b 输出结果 30 - 减 得到负数或是一个数减去另一个数 a - b 输出结果 -10 * 乘 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 / 除 x除以y b / a 输出结果 2 % 取余 返回除法的余数 b % a 输出结果 0 ** 幂 返回x的y次幂 a**b 为10的20次方， 输出结果 100000000000000000000 // 取整除 返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0 12345678&gt;&gt;&gt; 9 / 2.04.5&gt;&gt;&gt; 9 // 2.04.0&gt;&gt;&gt; 1 + 2*37&gt;&gt;&gt; (1+2) * 39 9.2、赋值运算符 运算符 描述 实例 = 赋值运算符 把=号右边的结果给左边的变量 num=1+2*3 结果num的值为7 12345&gt;&gt;&gt; a, b = 1, 2&gt;&gt;&gt; a1&gt;&gt;&gt; b2 9.3、复合赋值运算符 运算符 描述 实例 += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c ** = a 等效于 c = c ** a //= 取整除赋值运算符 c //= a 等效于 c = c // a 10、数据类型转化 了解类型转换的作用 掌握常用的类型转换 函数 说明 int(x [,base ]) 将x转换为一个整数 long(x [,base ]) 将x转换为一个长整数 float(x ) 将x转换到一个浮点数 complex(real [,imag ]) 创建一个复数 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 unichr(x ) 将一个整数转换为Unicode字符 ord(x ) 将一个字符转换为它的整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 举例 1234a = &#x27;100&#x27; # 此时a的类型是一个字符串，里面存放了100这3个字符b = int(a) # 此时b的类型是整型，里面存放的是数字100print(&quot;a=%d&quot;%b) 11、判断语句介绍 直接拿一个例子来说明吧。 &lt;重要日期判断案例&gt; 1234567891011121314151617if 今天是周六或者周日: 约妹子if 今天是情人节: 买玫瑰if 今天发工资: 先还信用卡的钱 if 有剩余: 又可以happy了，O(∩_∩)O哈哈~ else: 噢，no。。。还的等30天 小总结： 如果某些条件满足，才能做某件事情，而不满足时不允许做，这就是所谓的判断 不仅生活中有，在软件开发中“判断”功能也经常会用到 12、if语句 掌握 if 语句的语法格式 12.1、if判断语句介绍 if语句是用来进行判断的，其使用格式如下： 12if 要判断的条件: 条件成立时，要做的事情 demo1: 12345678age = 30print &quot;------if判断开始------&quot;if age&gt;=18: print &quot;我已经成年了&quot;print &quot;------if判断结束------&quot; 运行结果: 123------if判断开始------我已经成年了------if判断结束------ demo2: 12345678age = 16print &quot;------if判断开始------&quot;if age&gt;=18: print &quot;我已经成年了&quot;print &quot;------if判断结束------&quot; 运行结果: 12------if判断开始------------if判断结束------ 小总结： 以上2个demo仅仅是age变量的值不一样，结果却不同；能够看得出if判断语句的作用：就是当满足一定条件时才会执行那块代码，否则就不执行那块代码 注意： 代码的缩进为一个tab键，或者4个空格 12.2、练一练要求：从键盘获取自己的年龄，判断是否大于或者等于18岁，如果满足就输出“哥，已成年，网吧可以去了” 使用input从键盘中获取数据，并且存入到一个变量中 使用if语句，来判断 age&gt;=18是否成立 12.3、想一想 判断age大于或者等于18岁，使用的是 &gt;=，还有哪些呢？ 13、比较、关系运算符13.1、比较(即关系)运算符python中的比较运算符如下表 运算符 描述 示例 == 检查两个操作数的值是否相等，如果是则条件变为真。 如a=3,b=3则（a == b) 为 true. != 检查两个操作数的值是否相等，如果值不相等，则条件变为真。 如a=1,b=3则(a != b) 为 true. &lt;&gt; 检查两个操作数的值是否相等，如果值不相等，则条件变为真。 如a=1,b=3则(a &lt;&gt; b) 为 true。这个类似于 != 运算符 &gt; 检查左操作数的值是否大于右操作数的值，如果是，则条件成立。 如a=7,b=3则(a &gt; b) 为 true. &lt; 检查左操作数的值是否小于右操作数的值，如果是，则条件成立。 如a=7,b=3则(a &lt; b) 为 false. &gt;= 检查左操作数的值是否大于或等于右操作数的值，如果是，则条件成立。 如a=3,b=3则(a &gt;= b) 为 true. &lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是，则条件成立。 如a=3,b=3则(a &lt;= b) 为 true. 13.2、 逻辑运算符 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是 True，它返回 True，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 14、小风作业练习必做题 说出变量名字，可以由哪些字符组成 写出变量命名时的规则 说出什么是驼峰法（大驼峰、小驼峰） 编写程序，完成以下要求： 提示用户进行输入数据 获取用户的数据数据（需要获取2个） 对获取的两个数字进行求和运行，并输出相应的结果 编写程序，完成以下要求： 提示用户进行输入数据 获取用户的数据数据（需要获取2个） 对获取的两个数字进行减法运行，并输出相应的结果 编写程序，完成以下信息的显示: 1234567=================================== 欢迎进入到身份认证系统V1.0= 1. 登录= 2. 退出= 3. 认证= 4. 修改密码================================== 编写程序，从键盘获取一个人的信息，然后按照下面格式显示 123456==================================姓名: A2Data QQ:xxxxxxx手机号:185xxxxxx公司地址:北京市xxxx================================== 编写程序，从键盘获取用户名和密码，然后判断，如果正确就输出以下信息 1亲爱的xxx，欢迎登陆 A2Data学习管理系统","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"运营工具箱","slug":"Tools/运营工具箱","date":"2019-11-28T00:32:29.000Z","updated":"2020-09-11T09:28:58.969Z","comments":true,"path":"posts/41382.html","link":"","permalink":"http://www.a2data.cn/posts/41382.html","excerpt":"掌握这些工具，你就是自媒体大咖","text":"掌握这些工具，你就是自媒体大咖 126 种运营人必备工具微场景编辑器 易企秀：http://www.eqxiu.com/main 易企微：http://www.e7wei.com/ 兔展：http://www.rabbitpre.com/ 麦片 BlueMP：http://www.bluemp.cn 初页：http://www.ichuye.cn/ MAKA: http://maka.im/ 翼码旺财：http://cp.wangcaio2o.com/ 24好玩：http://24haowan.com/ 微页：http://www.zhichiwangluo.com/ 点点客海报：http://www.dodoca.com/ 秀米秀制作：http://xiumi.us/ 易传单：http://echuandan.com/ Epub360 意派：http://www.epub360.com/ LiveApp 场景应用：http://www.liveapp.cn/ Vxplo ：http://www.vxplo.cn/ 最酷网：http://www.zuiku.com/ 起飞页：http://www.qifeiye.com/#bit_elmpz WIX: http://www.wix.com/ 有图：http://www.360youtu.cn/ 图片素材来源 千图网：http://www.58pic.com/ 优美图：http://www.topit.me/ 花瓣：http://huaban.com/ 图虫：https://tuchong.com/ 图片 114：http://www.tupian114.com/ Picjumbo： https://picjumbo.com/ Pexels： https://www.pexels.com/ Gifs Categories：http://giphy.com/categories SOOGIF 动图搜索：http://soogif.com/ 素材公社：http://www.tooopen.com/ 插画家园：http://www.13cg.com/ Pixabay 免费高清图片：https://pixabay.com/ Wallpaper：http://cn.forwallpaper.com/ 图片处理网站 trikingly 建站工具：https://www.strikingly.com canva 海报设计：https://www.canva.com 暴走漫画制作器：http://baozoumanhua.com tuyitu 动图制作：http://www.tuyitu.com tagul 在线文字云制作：https://tagul.com smallpdf pdf 转换网站：https://smallpdf.com/cn Gif 录制编辑工具：GifCam 图片批量处理工具：美图秀秀批处理 创客贴：https://www.chuangkit.com/dc.html Magic Mockups：http://magicmockups.com/mockup/2/ 行业资源合作 APP换量/采量/变现/异业合作/礼品卡券 http://www.niaogebiji.com/pc/index/appchange 各大媒体平台 微信公众平台： https://mp.weixin.qq.com 企鹅媒体平台： http://om.qq.com/userAuth/index 头条号： http://mp.toutiao.com/ 搜狐公众平台： http://mp.sohu.com 网易媒体号： http://dy.163.com/wemedia/login.html UC 订阅平台： http://mp.uc.cn 百家号： http://publish.baidu.com 数据查询网站 搜狗微信搜索： http://weixin.sogou.com/ 新榜：http://www.newrank.cn/ 站长工具：http://tool.chinaz.com 百度搜索风云榜：http://top.baidu.com 百度指数：http://index.baidu.com 微指数： http://data.weibo.com/index 微博数据中心： http://data.weibo.com/datacenter/recommendapp 行业数据来源 媒体微博排行榜：http://v6.bang.weibo.com/xmt 友盟：http://www.umeng.com/ 中国新闻地图：http://vis.360.cn/open/cnnews/ 中国票房榜：http://www.cbooo.cn/ 收视率排行：http://www.tvtv.hk/archives/category/tv 农业大数据云平台：http://www.dataagri.com/agriculture/gis.action 房价指数：http://data.eastmoney.com/cjsj/newhouse.html 中国统计局：http://data.stats.gov.cn/ 主要城市拥堵实时排名：http://report.amap.com/traffic/ 中国综合社会调查：http://www.chinagss.org/ P2P 网贷指数：http://www.p2p001.com/wdzs/wdzs_p2pline.html Alexa：http://www.alexa.com/ 易车汽车指数：http://index.bitauto.com/ 旅游预测：http://trends.baidu.com/tour/ 网盘搜索网站 盘多多：http://www.panduoduo.net 网盘屋：http://www.wangpanwu.com/ 呆木瓜：http://www.daimugua.com 西林街：http://www.xilinjie.com 胖次网盘搜索引擎： http://www.panc.cc 百度网盘分享之家： http://wowenda.com/ 网盘 007：http://wangpan007.com/ 去转盘网：http://www.quzhuanpan.com/ 鸵鸟搜索：http://www.tuoniao.me/ 社群管理工具 进群宝：http://www.jinqunbao.com/ 小U管家企业版：http://www.xiaouqyfw.com/ 行业社群助手：https://xzs.jinqunla.com/ 群鲸SCRM个人号管理：http://www.qunsir.com/#/ Wetools：https://www.wxb.com/wetool 图文排版编辑器 i 排版：http://www.ipaiban.com/ 新榜编辑器：http://edit.newrank.cn/ 秀米：http://xiumi.us/ 96 微信编辑器：http://bj.96weixin.com/ 96 微信标题表情： http://bj.96weixin.com/emoji/ 135 编辑器：http://www.135editor.com/ 小蚂蚁微信编辑器：http://www.xmyeditor.com/ 易点编辑器：http://wxedit.yead.net/ 易企微微信编辑器：http://www.e7wei.cn/ 91 微信编辑器：http://www.91join.com/edit/ 微信编辑器：http://www.wxbj.cn/ 微助点微信编辑器：http://www.videaba.com/ 懒人模板：http://bj.lanrenmb.com/ 果优微信编辑器：http://guoyoo.99vu.com/ 做最好用的微信编辑器：http://editor.fzn.cc/ 微信在线编辑：http://wx.bzrw.net/ 微兔兔编辑器：http://www.weitutu.com/ 有图微信编辑器：http://bj.360youtu.com/ 排版 365：http://paiban.lizhi.in/ 乐排：http://pb.ishangtong.com/ 秀多多：http://xiudodo.com/?m=graphic#/for/new 在线问卷调查 腾讯问卷调查：http://wj.qq.com/ 麦客：http://www.mikecrm.com/ ICTR：http://cn2.ictr.cn/ 问道网：http://www.askform.cn/ 问卷星：http://www.sojump.com/ 调查派：http://www.diaochapai.com/ 问卷网：http://www.wenjuan.com/ SurveyMonkey：https://zh.surveymonkey.com/ 每日运营资讯 运营派https://www.adquan.com/ Next新产品http://next.36kr.com/posts 新榜资讯https://www.newrank.cn/public/news.html 二维码生成器 草料二维码：http://cli.im 联图网：http://www.liantu.com 二维工坊：http://www.2weima.com wwei 创意二维码：http://www.wwei.cn 二维码解码器：http://jiema.wwei.cn/ 半色调二维码生成器：https://spacekid.me/halftone-qr-code-generator/ 其他实用工具 多媒体格式转换工具：格式工厂 微信文章视频地址采集工具：http://www.hengha.tv/caiji.html 第一字体转换器：http://www.diyiziti.com/List 上传图片找字体：http://www.qiuziti.com/ 广告买卖网：http://www.admaimai.com/ GIF 压缩/水印/裁剪/制作/视频转 GIF：http://www.piggif.com/tools/compress 在线文件转换器：http://cn.office-converter.com/ PDF 转 DOC：http://pdf2doc.com/zh/ VIP 视频在线解析：http://vip.ifkdy.com/ 装逼神器：http://deepba.com/","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"}]},{"title":"打造稳定快速、高效免费图床","slug":"Tools/打造稳定快速、高效免费图床","date":"2019-11-26T13:41:06.000Z","updated":"2020-08-07T10:28:25.857Z","comments":true,"path":"posts/6059.html","link":"","permalink":"http://www.a2data.cn/posts/6059.html","excerpt":"超级图床，高速稳定","text":"超级图床，高速稳定 GitHub + jsDelivr + PicGo + Imagine 打造稳定快速、高效免费图床前言 为什么要使用图床呢？ 因为在不同平台发布同一篇文章的时候，最一个痛苦的点就是，图片存储问题，各个平台的文件存储方式各不相同，无法直接 Ctrl + C 的方式一键搞定，为了解决这个问题，使用 MarkDown + 图床 的方式进行文章的写作，将图片放到一个统一的地方，在文章中引入图片外链。所谓图床，就是将图片储存到第三方静态资源库中，其返回给你一个 URL 进行获取图片。MarkDown 支持使用 URL 的方式显示图片，我想这也是程序员为什么对其偏爱的原因之一。作为程序员，你会发现，现在很多论坛和社区都开始支持使用 MarkDown，如果你没使用图床的情况下，你分享同一篇文章，你要在不同的平台，各自重新编辑排版一遍和上传图片一次。有了图床，情况就不一样了，Ctrl+C 的方式就搞定了，根本不用再 Check 文章内容一遍。 图床的选择？ 微博图床：以前用的人比较多，从 2019 年 4 月开始开启了防盗链，凉凉 SM.MS：运营四年多了，也变得越来越慢了，到了晚上直接打不开图片，速度堪忧 其他小众图床：随时有挂掉的风险 Imgur 等国外图床：国内访问速度太慢，随时有被墙的风险 大厂储存服务：例如七牛云、又拍云、腾讯云COS、阿里云OSS等，操作繁琐，又是实名认证又是域名备案的，麻烦，而且还要花钱（有钱又不怕麻烦的当我没说） GitHub 图床：免费，但是国内访问速度慢（不过没关系，利用 jsDelivr 提供的免费的 CDN 加速 速度足够了） 使用流程 新建 GitHub 仓库 生成一个 Token 配置 PicGo 并使用 jsdelivr 作为 CDN 加速 使用 Imagine 进行图片压缩 上传图片到 PicGo 并使用图床 新建 GitHub 仓库 登录/注册 GitHub 新建一个仓库，填写好仓库名 仓库描述 将权限设置成 public 根据需求选择是否为仓库初始化一个 README.md 描述文件 新建 GitHub 仓库 生成一个 Token 点击用户头像 -&gt; 选择 Settings Settings 点击 Developer settings Developer settings 点击 Personal access tokens Personal access tokens 点击 Generate new token Generate new token 填写 Token 描述，勾选 repo，然后点击 Generate token 生成一个 Token 填写 Token 描述 获取 Token 密钥 注意这个 Token 只会显示一次，自己先保存下来，或者等后面配置好 PicGo 后再关闭此网页 获取 Token 密钥 配置 PicGo 并使用 jsdelivr 作为 CDN 加速前往下载 PicGo（点击下载），安装好后开始配置图床 设定仓库名：按照 用户名/图床仓库名 的格式填写 设定分支名：master 设定 Token：粘贴之前生成的 Token 指定存储路径：填写想要储存的路径，如 img/，这样就会在仓库下创建一个名为 img 的文件夹，图片将会储存在此文件夹中 设定自定义域名：它的的作用是，在图片上传后，PicGo 会按照自定义域名+上传的图片名的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为https://cdn.jsdelivr.net/gh/用户名/图床仓库名 配置 PicGo Text 123Q：什么是 jsdelivr ?A：jsDelivr 为开发者提供免费公共 CDN 加速服务 使用 Imagine 进行图片压缩通常情况下，图片大小都是超过 200KB 的，所以网页加载的时候会特别慢，一般我们会对图片进行压缩，这里我推荐 Imagine（点击下载） 支持全平台。 使用 Imagine 进行图片压缩 Imagine 采用的是有损压缩，介意的可以忽略这一步 顺便推荐一个无损压缩的网站：https://tinypng.com/ 上传图片到 PicGo 并使用图床配置好 PicGo 后，我们就可以进行高效创作了，将压缩后的图片拖拽到上传区，将会自动上传并复制访问链接，将链接粘贴到博文中就行了，访问速度杠杠的 上传图片到 PicGo 并使用图床 此外 PicGo 还有相册功能，可以对已上传的图片进行删除，修改链接等快捷操作，PicGo 还可以生成不同格式的链接、支持批量上传、快捷键上传、自定义链接格式、上传前重命名等，更多功能自己去探索吧！","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"}]},{"title":"如何构建知识体系","slug":"Tools/如何构建知识体系","date":"2019-11-22T17:09:07.000Z","updated":"2020-08-07T10:28:56.454Z","comments":true,"path":"posts/18572.html","link":"","permalink":"http://www.a2data.cn/posts/18572.html","excerpt":"成长是什么呢？","text":"成长是什么呢？ 成长就是孤独的把委屈和泪水拼命的咽下去不让别人知道。 只有在孤独中，才能够更好的意识到自己真正追求的是什么，才能不局限于当下的小事，放眼更远大的志向。 知识体系 是在(恰如其分、环环相扣的)提问和实践的基础上形成的概念和概念间联系的集合，知识点之间彼此形式多样的方式关联，形成了特定的结构。 知行概念 = 内涵 + 外延 + 联系（知 -&gt; 行） 外延的常用描述方式 “是什么而不是什么”，经验是用枚举外延以及枚举高价值联系的方式来对提升概念理解的精确度，即将内涵方式描述不显而易见的加入到备忘录。 理解 = 能够枚举更多概念的CASE以及概念间的联系，理解就是 识 -&gt; 记 -&gt; 忆（用场景+联系来唤醒，记的时候想着忆，写的时候想着读）。 学以致用的基础是理解概念间的高价值联系，而发挥力量的关键是显性表达。 我们可以借助“八大问”，来分析信息、观点、事件、经历等，从中整理出概念和联系。八大问是一个提问的框架，将针对信息、观点、事件、经历等的提问，分为“前、因、后、果、适、用、边、界”八类。 八大问可以分为两组，前因后果用于分析信息，适用边界用于整理信息。 123456789101112前（前车之鉴）：为什么这件事对我重要？它是怎么引出这个信息的？因（相因相生）：作者有哪些关于原因的假设？怎么验证或排除这些假设？还有其他可能性吗？后（以观后效）：从已有信息去做之后会怎样？对我的好处（效用）是什么？果（自食其果）：不这么做的后果是什么？不改变的问题有多严重？适（适得其反）：有没有相反的观点？有没有不支持这个实现的案例(CASE to CASE)？用（使用条件）：要这样做，需要具备哪些条件？（考虑 成本、收益、效率、安全、态度、能力等）这件事可以哪些方式来完成？边（旁敲边鼓）：从前有没有类似的（或乍看起来差不多的）信息？其他 （领域 | 行业 | 人）如何解决类似问题呢？界（楚河汉界）：无论是相反的还是类似的信息，和这个信息的真正区别是什么？交界在哪里？ 应用指南 在使用八大问时，不一定要原模原样地问上面列举出的示范问题，可以在理解这八类问题的前提下，针对具体情境，提出合适的问题。也就是说，八大问最重要的是提供了一种提出有洞察力的问题的框架，这是他的意义所在。如果你有能力，可以领会心法，保持心法不变，提出新的问题。 如果一开始不知道怎么用，则建议直接使用示范问题或在其基础上做变化。欢迎一起探讨哦。","categories":[{"name":"职场","slug":"职场","permalink":"http://www.a2data.cn/categories/%E8%81%8C%E5%9C%BA/"}],"tags":[{"name":"毒鸡汤","slug":"毒鸡汤","permalink":"http://www.a2data.cn/tags/%E6%AF%92%E9%B8%A1%E6%B1%A4/"}],"author":"Jack风"},{"title":"Markdown","slug":"Tools/Markdown","date":"2019-11-11T12:43:06.000Z","updated":"2020-09-14T15:19:40.228Z","comments":true,"path":"posts/17683.html","link":"","permalink":"http://www.a2data.cn/posts/17683.html","excerpt":"‘MD,原来是这么用的，你懂了吗？’","text":"‘MD,原来是这么用的，你懂了吗？’ MarkDown 用法精选Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 强力推荐: TproaMarkDown编辑器跨平台 完美运行. Hexo```MHexoEditor编辑器博客好助手 完美支持 Hexo 博文. 优点：1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可 缺点：1、需要记一些语法（当然，是很简单。五分钟学会）。2、有些平台不支持Markdown编辑模式。 一、标题 在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。 1示例：# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 123456789101112# 如上是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 二、字体 加粗要加粗的文字左右分别用两个号包起来斜体要倾斜的文字左右分别用一个号包起来斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来删除线要加删除线的文字左右分别用两个~~号包起来 示例： 1**这是加粗的文字***这是倾斜的文字*&#96;***这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下：这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 三、引用块 在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。 示例： 1234-------******** 效果如下： 可以看到，显示效果是一样的。 五、图片语法： 1234![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 1![img][A2DATA](&#x2F;resource&#x2F;image&#x2F;markdown&#x2F;1.png) 效果如下： 12- hexo 3&#123;% asset_img test.jpg This is an test image %&#125; 上传本地图片直接点击导航栏的图片标志，选择图片即可 六、超链接语法： 12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例： 12[简书](http:&#x2F;&#x2F;jianshu.com)[百度](http:&#x2F;&#x2F;baidu.com) 效果如下： 简书百度 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 1234&lt;a href&#x3D;&quot;超链接地址&quot; target&#x3D;&quot;_blank&quot;&gt;超链接名&lt;&#x2F;a&gt;示例&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&quot; target&#x3D;&quot;_blank&quot;&gt;百度&lt;&#x2F;a&gt; 七、列表 无序列表 语法： 无序列表用 - + * 任何一种都可以 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表 语法： 数字加点 123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 效果如下： 1.列表内容 2.列表内容 3.列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 八、表格语法： 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 12345姓名|技能|排行|--|:--:|--:||欢迎|关注|微信||公号|平台|A2DATA||我们|一起|加油| 效果如下： I II III 欢迎 关注 微信 公号 平台 DataScience 我们 一起 加油 九、代码语法： 单行代码：代码之间分别用一个反引号包起来 1&#96;代码内容&#96; 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 12345(```) 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例： 单行代码 1&#96;create database hero;&#96; 代码块 123456(&#96;&#96;&#96;) function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;; &#125; fun();(&#96;&#96;&#96;) 效果如下： 单行代码 1create database hero; 代码块 1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun(); 十、流程图 横向流程图 123456789101112graph LRA[方形] --&gt;B(圆角) B --&gt; C&#123;条件a&#125; C --&gt;|a&#x3D;1| D[结果1] C --&gt;|a&#x3D;2| E[结果2] F[横向流程图] 竖向流程图 1234567graph TDA[方形] --&gt;B(圆角) B --&gt;C&#123;条件a&#125; C --&gt;|a&#x3D;1|D[结果1] C --&gt;|a&#x3D;2|E[结果2] F[竖向流程图] 效果如下： 123456789101112graph LR start[开始] --&gt; input[输入A,B,C] input --&gt; conditionA&#123;A是否大于B&#125; conditionA -- YES --&gt; conditionC&#123;A是否大于C&#125; conditionA -- NO --&gt; conditionB&#123;B是否大于C&#125; conditionC -- YES --&gt; printA[输出A] conditionC -- NO --&gt; printC[输出C] conditionB -- YES --&gt; printB[输出B] conditionB -- NO --&gt; printC[输出C] printA --&gt; stop[结束] printC --&gt; stop printB --&gt; stop","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"}]},{"title":"Strive","slug":"Tools/strive","date":"2019-11-04T14:11:30.000Z","updated":"2020-08-07T10:29:35.053Z","comments":true,"path":"posts/18321.html","link":"","permalink":"http://www.a2data.cn/posts/18321.html","excerpt":"‘在你牛到一定程度前,所有的一切全是态度问题。’","text":"‘在你牛到一定程度前,所有的一切全是态度问题。’ 你为什么[努力]? 一位麦肯斯7年老员工的忠告：所谓的能力问题，全都是态度问题！ 态度哪有那么多「能力问题」，在你牛到一定程度前，全是「态度问题」 职场上有句话，「ta这是能力问题，工作态度还是好的」。 通常做得不够好的时候，「能力问题」似乎就比较容易得到谅解。 我承认，时代、机缘、天赋、性格、出身、早年教育，等等这些我们无法全然掌控的因素，关系重大，或许将我们的个人「能力」划定在某个范围内。 生活，是公平的，你选择了自己轻松，那你身边的家人一定会为你的选择付出成本和代价。 有些事情，你尝试了不一定可以成功，但是你不尝试，肯定是一丝可能都没有。· 努力的理由最近突然明白，一个人努力的理由是什么。 123456789是为了在看到自己喜欢的东西时，毫不犹豫拿起就付款的大方样子；是为了想去一个地方时再也不用精打细算的计划费用，而是领包就走毫无顾虑的潇洒样子；是为了遇到自己喜欢的人，再也不用担心自己配不上对方，而是在对方面前自信满满的样子；是为了过再也不用对别人点头哈腰的日子。 总结起来，就是一句话： 我之所以这么努力， 是为了能过上自己想要的生活， 能与自己所爱的人自信满满的打招呼， 而不是畏首畏尾，连说句“你好”都觉得卑微。 梦在远方，路在脚下 这世界上 从来没有谁能够 随随便便成功 天才也需要99%汗水的付出 相信自己可以去改变境遇，有这点志气，才能有撸起袖子去行动的能力。 正如瑞达利欧在《原则》中所写： 没有什么比「明白现实世界如何运作」并且「如何应对它」更重要的事，而你在这个过程中的心态，决定了所有的差别。 生活不止眼前的苟且，还有远方的苟且。","categories":[{"name":"职场","slug":"职场","permalink":"http://www.a2data.cn/categories/%E8%81%8C%E5%9C%BA/"}],"tags":[{"name":"毒鸡汤","slug":"毒鸡汤","permalink":"http://www.a2data.cn/tags/%E6%AF%92%E9%B8%A1%E6%B1%A4/"}]},{"title":"SublimeText","slug":"Tools/SublimeText","date":"2019-09-23T14:17:10.000Z","updated":"2020-08-07T10:18:18.005Z","comments":true,"path":"posts/55860.html","link":"","permalink":"http://www.a2data.cn/posts/55860.html","excerpt":"超级编辑器","text":"超级编辑器 SublimeText 必备插件第一步 安装 Package Control组件快捷键 Ctrl+` 12import urllib.request,os; pf = &#x27;Package Control.sublime-package&#x27;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#x27;wb&#x27;).write(urllib.request.urlopen( &#x27;http://sublime.wbond.net/&#x27; + pf.replace(&#x27; &#x27;,&#x27;%20&#x27;)).read()) 如果在Perferences-&gt;中看到package control这一项，则安装成功。 解决中文乱码问题Mac 快捷键： Cmd+ shift + p Windows : Ctrl + shift + p 1、打开 package control 2、输入： Install Package 3、安装 ： ConvertToUTF8插件 主题安装 Material theme 主题 安装方法：Ctrl(Mac下Cmd)+Shift+P install package -&gt; Material Theme install package -&gt; A File Icon 字体 装好又到之前的 首选项—–用户设置（user ）：选择字体：如果存在就修改为Fira Code，不存在就添加下面这行代码， 1&quot;font_face&quot;: &quot;Fira Code&quot; 至此大功告成，谢谢 字体安装路径 C:\\Users\\Desktop\\FiraCode-master\\FiraCode-master\\distr\\ttf FiraCode-master 字体下载已经上传到微云 更多骚操作等待你一起探讨哦 如需破解广告版本，请添加微信公众号：A2Data 联系小编获取哦。","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"}]},{"title":"Linux安装","slug":"Linux/Linux安装","date":"2019-09-13T11:15:31.000Z","updated":"2020-09-11T08:45:44.385Z","comments":true,"path":"posts/43150.html","link":"","permalink":"http://www.a2data.cn/posts/43150.html","excerpt":"linux介绍及安装","text":"linux介绍及安装 一、Linux简介linux是一种由unix衍生出来的操作系统，，操作系统是用户和计算机之间的界面. 一方面操作系统管理着所有计算机系统资源,另一方面操作系统为用户提供了一个抽象概念上的计算机. 在操作系统的帮助下, 用户使用计算机时,避免了对计算机系统硬件的直接操作.二、Linux国内流行版本介绍1、Redhat2、CentOS3、Suse4、红旗（redflag）三、Linux 优点 1.稳定2.多线程3.架构可扩展4.开源5.简单（IT）四、Linux 缺点 1.技术要求相对较强2.图形界面不够好五、安装安装RedHat系统的方法有很多种，我们主要介绍如何使用光盘安装方法安装RedHat系统。既然说Linux是一种操作系统那么最常用的操作系统就是windows日常生活中它是一般装到我们的pc上的，大多数的企业会使用Linux系统装在服务器上的，所以为了模拟环境我们用了一个软件叫做VMware它能够帮我们实现一个虚拟的网络环境还支持很多系统，下面我们就来安装一下Redhat6.4准备镜像rhel-server-6.4-x86_64-dvd.iso首先安装VMware这个直接去网上下载安装就好 安装好以后我们会看见一下这个界面建议大家使用英文版的，在企业工作大多数都是英文，先熟悉一下环境 1、首先我们新建一个虚拟机 2、选择典型 3、选择稍后安装操作系统，后期我们自己挂载镜像 4、接下来选择linux的版本，根据自己下载的镜像版本而定 5、下一步给虚拟机取一个名字，给它一个存放路径，注意：路径最好不要出现中文 6、下面是磁盘大小和，将虚拟磁盘统一成一个文件 7、检查一下如果没有问题点击finish 8、在左上方会出现一个linux这就是我们即将安装的虚拟机，然后选择镜像 9、把开始下载的镜像路径添加到上面点击ok 10、然后运行此虚拟机 Linux安装1、选择第一项，然后回车： 2、跳过光盘质量测试提示上一步回车后，将出现下面的界面，使用“Tab”键切换到“Skip”，然后回车： 3、点击next如果鼠标不能移动可用Ctrl+Alt进行切换 4、选择安装过程使用的语言选择安装过程使用的语言：中文(简体)，然后点“Next”（还是建议大家使用英文的，这里为了方便讲解就用中文了） 5、设置键盘设置键盘为“美国英语式”，然后点“下一步”： 6、选择系统使用的存储设备一般情况，均默认选择“基本存储设备”，然后点“下一步”： 7、出现下图提示时，点击“是，忽略所有数据”： 8、设置计算机名可根据实际情况，对计算机主机名进行命名也可以安装好后用命令行进行更改 9、配置网络点击界面左下角的“配置网络”，配置服务器网络：选中eth0进行配置 点击“编辑” 勾上“自动连接” 选择“IPv4设置”选项卡，“方法”选择“手动” 点击“添加” 分别点击并配置“地址”、“子网掩码”、“网关” 填上“DNS服务器”地址（如果没有可不填，多个DNS用逗号分隔） 点击“应用”完成配置可参考下图： 选择系统时区时区默认为“亚洲/上海”，注意需要去掉“系统时钟使用UTC时间”前面的勾，然后点“下一步”： 设置root账户密码建议输入一个复杂组合的密码，密码包含：大写、小写、数字、符号 10、磁盘分区创建自定义布局分区 10.1、创建第1个分区（启动分区）： 10.2、配置1.“挂载点”选择“/boot”2.“大小(MB)”填入“300”3.点击“确定” 10.3 创建第2个分区（主分区）1.“挂载点”选择“/home”2.“大小(MB)”填入“8000”（根据实际硬盘大小填写）3.点击“确定” 11、重复创建步骤1.“文件系统类型”选择“swap”2.“大小(MB)”填入“800”（根据实际内存大小填写，一般为内存的1.5-2倍，不大于8G）3.点击“确定”创建第4个分区（根分区）：重复创建步骤1.“挂载点”选择“/”2.勾选“使用全部可用分区”3.点击“确定” 点击下一步进行格式化 点击修改写入磁盘 只有一个盘所以点击下一步即可 基础软件安装 各项包含软件Desktop :基本的桌面系统，包括常用的桌面软件，如文档查看工具。Minimal Desktop :基本的桌面系统，包含的软件更少。Minimal :基本的系统，不含有任何可选的软件包。Basic Server：安装的基本系统的平台支持，不包含桌面。Database Server :基本系统平台，加上mysql和PostgreSQL数据率，无桌面。Web Server :基本系统平台，加上PHP, Web server，还有mysqI和PostgreSQL数据库的客户端，无桌面。Virtual Host :基本系统加虚拟化平台。Software Development Workstation :包含的软件包较多，基本系统，虚拟化平台，桌面环境，开发工具。注意：我们一般运行的时候都不会使用桌面，这里我们就不安装桌面了，其他的软件后期需要我们也可以再安装。 勾选ftp服务器 点击下一步开始安装 至此完成安装 进入系统 出现以下界面证明你成功了 使用root用户，输入你的密码就可以使用了","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.a2data.cn/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"Hexo图片问题","slug":"Hexo/Hexo图片问题","date":"2019-09-05T15:41:52.000Z","updated":"2020-09-11T09:28:58.961Z","comments":true,"path":"posts/ee789513.html","link":"","permalink":"http://www.a2data.cn/posts/ee789513.html","excerpt":"Hexo 上传图片相关的问题。","text":"Hexo 上传图片相关的问题。 使用hexo上传图片，但是发现在文章中引用本地图片时总是显示不出来。花费了许久时间才解决这个问题。因此将一些解决经验整理出来，希望能帮助到大家。 一、插件安装与配置 首先我们需要安装一个图片路径转换的插件，这个插件名字是hexo-asset-image 1npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save 但是这个插件的内容需要修改【不然可能会出Bug】 打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&#x27;use strict&#x27;;var cheerio = require(&#x27;cheerio&#x27;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&#x27;.&#x27;);hexo.extend.filter.register(&#x27;after_post_render&#x27;, function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &#x27;/&#x27;, 1) + 1; else var beginPos = getPosition(link, &#x27;/&#x27;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&#x27;/&#x27;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&#x27;excerpt&#x27;, &#x27;more&#x27;, &#x27;content&#x27;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&#x27;img&#x27;).each(function()&#123; if ($(this).attr(&#x27;src&#x27;))&#123; // For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;. var src = $(this).attr(&#x27;src&#x27;).replace(&#x27;\\\\&#x27;, &#x27;/&#x27;); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27;; &#125;); var srcArray = src.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27; &amp;&amp; elem != &#x27;.&#x27;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&#x27;/&#x27;); $(this).attr(&#x27;src&#x27;, config.root + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 打开根目录下的_config.yml文件，修改下述内容1post_asset_folder: true 二、问题推测1、本地图片没有有效的上传至github仓库中，导致引用无效解决方案，安装插件，请看上文如何安装 2、本地图片没有存放在同名文件夹下解决方案，将需要引用的本地图片存放在与文章名相同的文件夹中 3、图片路径出错这里多数人可能会将url 写成自己的域名。 切记：需要写成自己github项目的地址。我刚开始也错了。 4、相对路径引用的标签插件 通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 也就是说在存档页和主页不能使用和文章内容中的常规语法来引用图片。 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](/a2data.jpg) ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作） 正确的引用图片方式是使用下列的标签插件而不是 markdown ：———————————————— 1&#123;% asset_img example.jpg This is an example image %&#125; 这是一个MD引入图片 这是标签引用方式","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/tags/Hexo/"}]}],"categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"},{"name":"Git","slug":"Git","permalink":"http://www.a2data.cn/categories/Git/"},{"name":"Anaconda","slug":"Python/Anaconda","permalink":"http://www.a2data.cn/categories/Python/Anaconda/"},{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/categories/Hexo/"},{"name":"DataBase","slug":"DataBase","permalink":"http://www.a2data.cn/categories/DataBase/"},{"name":"Mysql","slug":"DataBase/Mysql","permalink":"http://www.a2data.cn/categories/DataBase/Mysql/"},{"name":"数据可视化","slug":"Python/数据可视化","permalink":"http://www.a2data.cn/categories/Python/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"},{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"},{"name":"Redis","slug":"DataBase/Redis","permalink":"http://www.a2data.cn/categories/DataBase/Redis/"},{"name":"大数据","slug":"大数据","permalink":"http://www.a2data.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"},{"name":"职场","slug":"职场","permalink":"http://www.a2data.cn/categories/%E8%81%8C%E5%9C%BA/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"Git","slug":"Git","permalink":"http://www.a2data.cn/tags/Git/"},{"name":"Anaconda","slug":"Anaconda","permalink":"http://www.a2data.cn/tags/Anaconda/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.a2data.cn/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/tags/Hexo/"},{"name":"Mysql","slug":"Mysql","permalink":"http://www.a2data.cn/tags/Mysql/"},{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"},{"name":"图床","slug":"图床","permalink":"http://www.a2data.cn/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Redis","slug":"Redis","permalink":"http://www.a2data.cn/tags/Redis/"},{"name":"数据库工具","slug":"数据库工具","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B7%A5%E5%85%B7/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://www.a2data.cn/tags/Hadoop/"},{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"资料分享","slug":"资料分享","permalink":"http://www.a2data.cn/tags/%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB/"},{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"},{"name":"MapReduce","slug":"MapReduce","permalink":"http://www.a2data.cn/tags/MapReduce/"},{"name":"面经","slug":"面经","permalink":"http://www.a2data.cn/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"Python习题","slug":"Python习题","permalink":"http://www.a2data.cn/tags/Python%E4%B9%A0%E9%A2%98/"},{"name":"毒鸡汤","slug":"毒鸡汤","permalink":"http://www.a2data.cn/tags/%E6%AF%92%E9%B8%A1%E6%B1%A4/"}]}